<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ctrl + D</title>
    <url>/archives/49905.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/06/06/IPuV6z1y24rSGws.png"  />

<center>聚合各领域链接，资源、博客、工具、素材等</center>

<span id="more"></span>

<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li><a href="https://material.io/">Material Design</a></li>
<li><a href="https://www.uplabs.com/material">Material Design, Daily - MaterialUp - MaterialUp</a></li>
<li><a href="https://www.uplabs.com/">Uplabs</a></li>
<li><a href="https://github.com/feelschaotic/AndroidKnowledgeSystem">AndroidKnowledgeSystem</a></li>
<li><a href="https://github.com/LisaDziuba/Awesome-Design-Tools">Awesome-Design-Tools</a></li>
<li><a href="https://github.com/wasabeef/awesome-android-ui">Awesome-Android-UI</a></li>
<li><a href="http://www.jcodecraeer.com/">泡在网上的日子</a></li>
<li><a href="http://www.see-source.com/">看源社区</a></li>
<li><a href="https://www.qcgzxw.cn/">小文’s blog</a></li>
<li><a href="https://github.com/FishInWater-1999/android_interviews">android interviews </a></li>
<li><a href="https://www.25xt.com/appdesign/12385.html">网易云音乐视觉设计规范文档</a></li>
</ul>
<h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><ul>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN">计算机免费书籍</a></li>
<li><a href="https://codepen.io/">CodePen</a></li>
<li><a href="https://codelabs.developers.google.com/">Codelabs</a></li>
<li><a href="https://codingpy.com/books/thinkpython2/index.html">Think Python 2e</a></li>
<li><a href="https://github.com/kdn251/interviews">interviews</a></li>
<li><a href="https://github.com/gto76/python-cheatsheet">python 语法速查</a></li>
<li><a href="https://blog.csdn.net/andrewniu/article/details/80566277">汇编语言指令</a></li>
<li><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">Best-websites-a-programmer-should-visit</a></li>
</ul>
<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><ul>
<li><a href="https://cangshui.net/">沧水的博客</a></li>
<li><a href="http://www.spiderpy.cn/blog/">烂笔头-博客</a></li>
<li><a href="https://github.com/b3log">B3log</a></li>
<li><a href="http://typecho.org/">typech0</a></li>
<li><a href="https://www.qcgzxw.cn/">小文‘s blog</a></li>
<li><a href="http://lovenight.github.io/">岁月如歌</a></li>
<li><a href="https://www.dogfight360.com/blog/">羽翼城个人博客</a></li>
</ul>
<h2 id="短视频素材"><a href="#短视频素材" class="headerlink" title="短视频素材"></a>短视频素材</h2><p><strong>视频素材</strong></p>
<ul>
<li><a href="https://www.videvo.net/">videvo</a></li>
<li><a href="https://www.free-video-footage.com/">free-video</a></li>
<li><a href="https://www.jijidown.com/">唧唧-b站视频下载</a></li>
<li><a href="https://www.pexels.com/videos">pexels</a></li>
<li><a href="https://www.videezy.com/">videezy</a></li>
</ul>
<p><strong>图片素材</strong></p>
<ul>
<li><a href="https://www.pexels.com/videos">pexels</a></li>
<li><a href="https://www.lanrentuku.com/">懒人图库</a></li>
<li><a href="https://www.unsplash.com/">Unsplash</a></li>
<li><a href="https://www.hippopx.com/">Hippopx</a></li>
<li><a href="https://www.colorhub.me/">ColorHub</a></li>
<li><a href="https://www.foodiesfeed.com/">Foodiefeed</a></li>
</ul>
<p><strong>音频素材</strong></p>
<ul>
<li><a href="https://www.audiolibrary.com.co/">Audio Library</a></li>
<li><a href="sourl.cn/hthUQX">Adobe Audition</a></li>
<li><a href="https://freemusicarchive.org/search">Free Music Archive</a></li>
<li><a href="https://www.aigei.com/">爱给网</a></li>
<li><a href="https://www.ear0.com/">耳聆网</a></li>
<li><a href="https://1soundfx.com/">1Soundfx</a></li>
</ul>
<p><strong>文案脚本素材</strong></p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://www.juben98.com/">剧本网</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.juben108.com/">原创剧本网</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.1bianju.com/">华语编剧网</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.juben68.com/">剧本联盟</a></li>
</ul>
<p><strong>选题素材来源</strong></p>
<ul>
<li>百度搜索风云榜</li>
<li>百度指数</li>
<li>微博热搜</li>
<li>新媒体管家—热点中心</li>
<li>TooBigData</li>
<li>微信指数</li>
</ul>
<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ul>
<li><a href="https://blog.csdn.net/wenxuhonghe">博客-爬虫</a></li>
<li><a href="https://github.com/Kr1s77/Python-crawler-tutorial-starts-from-zero">python-crawler-tutorial</a></li>
<li><a href="https://github.com/Kr1s77/awesome-python-login-model">awesome-python-login</a></li>
</ul>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul>
<li><a href="https://github.com/youzan/vant-weapp">Vant Weapp</a></li>
<li><a href="https://github.com/Tencent/weui/">WeUI</a></li>
<li><a href="https://github.com/Tencent/wepy">Wepy</a></li>
<li><a href="https://github.com/alsey/wxbarcode">条码、二维码</a></li>
<li><a href="https://github.com/jasondu/wxa-plugin-canvas/">二维码海报</a></li>
<li><a href="https://github.com/gooking/apifm-wxapi">api接口</a></li>
</ul>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul>
<li><a href="http://www.nicetool.net/">在线工具大全</a></li>
<li><a href="http://magnet.chongbuluo.com/">资源搜索</a></li>
<li><a href="https://www.appinn.com/">小众软件</a></li>
<li><a href="https://yunpanzhushou.com/">云盘助手</a></li>
<li><a href="http://www.mvcat.com/">电影推荐-MVCAT</a></li>
<li><a href="https://kepler.gl/">地图可视化编辑器</a></li>
<li><a href="https://shields.io/">Shields.io/</a></li>
<li><a href="https://wangyasai.github.io/Stars-Emmision/">Star Emmision</a></li>
<li><a href="https://magi.com/">Magi</a></li>
<li><a href="https://www.wenshushu.cn/">文叔叔</a></li>
<li><a href="https://6pan.cn/">6pan</a></li>
<li><a href="https://codeif.xinke.org.cn/">CodeIF-代码命名</a></li>
<li><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji</a></li>
<li><a href="https://www.nocmd.com/">NoCmd</a></li>
<li><a href="https://github.com/NGC-HenryLee/NGC.SS.JJ/">jj</a></li>
<li><a href="https://cowtransfer.com/">奶牛快传</a></li>
<li><a href="https://www.logosc.cn/">LOGO神器</a>(F12找logo对应svg代码，右键copy element)</li>
<li><a href="https://github.com/iptv-org/iptv">iptv</a></li>
<li><a href="https://uigradients.com/">渐变色</a></li>
<li><a href="https://github.com/bannedbook/fanqiang">fanqiang</a></li>
<li><a href="https://www.linshiyouxiang.net/">临时邮箱</a></li>
<li><a href="https://encycolorpedia.cn/">十六进制代码颜色表</a></li>
<li><a href="https://xbeibeix.com/api/bilibili/">B站视频下载</a></li>
<li><a href="https://www.maxthon.cn/mx5/uumail/">百变邮箱</a></li>
<li><a href="https://steamworkshopdownloader.io/">创意工坊下载</a></li>
<li><a href="https://afcano.com/">英文起名</a></li>
<li><a href="http://t.cn/AiT9X7mV">代码截图 Chrome 应用</a></li>
<li><a href="https://carbon.now.sh/">代码截图</a></li>
<li><a href="https://sketchviz.com/new">手绘图</a></li>
</ul>
<h2 id="开眼"><a href="#开眼" class="headerlink" title="开眼"></a>开眼</h2><ul>
<li><a href="http://ddrk.me/">低端影视</a></li>
<li><a href="https://tophub.today/">今日热榜</a></li>
<li><a href="https://www.cheat8.com/">奇特吧</a></li>
<li><a href="https://getitfree.cn/">正版中国</a></li>
<li><a href="http://yx.bsh.me/">异星</a></li>
<li><a href="https://www.ghpym.com/category/all/android/xposed">果核剥壳</a></li>
<li><a href="https://5kindle.com/">子午书简</a></li>
<li><a href="https://www.overwolf.com/">Overwolf</a></li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li><a href="https://zhutix.com/">致美化</a></li>
<li><a href="https://www.25xt.com/">25学堂-ui素材</a></li>
<li><a href="https://huaban.com/">花瓣网</a></li>
<li><a href="https://github.com/Tencent/QMUI_Android">QMUI_Android</a></li>
<li><a href="https://www.canva.cn/templates/">Canva</a></li>
</ul>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><ul>
<li><p><a href="https://github.com/xtaci/algorithms">C++</a></p>
</li>
<li><p><a href="https://github.com/trekhleb/javascript-algorithms">Javascript</a></p>
</li>
<li><p><a href="https://github.com/TheAlgorithms/Python">Python</a></p>
</li>
</ul>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul>
<li><a href="https://www.awesomes.cn/">Web前端开发资源库</a></li>
<li><a href="https://css-tricks.com/centering-css-complete-guide/">CSS居中</a></li>
<li><a href="https://www.30secondsofcode.org/css/p/1">30 Seconds of CSS</a></li>
<li><a href="https://www.patreon.com/onlinetutorials/posts">Online Tutorials(Paid)</a></li>
</ul>
<p><strong>Vue</strong></p>
<ul>
<li><a href="https://www.jeffjade.com/2017/03/11/120-how-to-write-vue-better/#fromHistory">如何写一手漂亮的Vue</a></li>
<li><a href="https://ppt.baomitu.com/d/52096df3#/1">Vue2.x 开发Web应用 – ppt</a></li>
</ul>
<h2 id="Art"><a href="#Art" class="headerlink" title="Art"></a>Art</h2><ul>
<li><p><a href="https://logo.shapefactory.co/">Logo by ShapeFactor</a></p>
</li>
<li><p><a href="https://www.artic.edu/collection">Discover Art &amp; Artists</a></p>
</li>
<li><p><a href="https://unsplash.com/">Unsplash</a></p>
</li>
<li><p><a href="https://www.deviantart.com/">DeviantArt</a></p>
</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git 教程</a></li>
<li><a href="https://learngitbranching.js.org/">Git 练习平台</a></li>
</ul>
<h2 id="Articles"><a href="#Articles" class="headerlink" title="Articles"></a>Articles</h2><ul>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926">MVP</a></li>
<li><a href="https://www.jianshu.com/p/e7d5c7bda783">EventBus</a></li>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083">RxJava</a></li>
<li><a href="https://mp.weixin.qq.com/s/UAEgdC2EtqSpEqvog0aoZQ">RxJava系列</a></li>
<li><a href="https://www.jianshu.com/p/6d1d063e0148">Context</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包</a></li>
<li><a href="https://muyangmin.github.io/glide-docs-cn/">Glide</a></li>
</ul>
<h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><ul>
<li><a href="http://www.secha.net/">找色差</a></li>
<li><a href="https://www.wuziqi.org.cn/">五子棋</a></li>
<li><a href="https://www.heibaiqi.com.cn/">黑白棋</a></li>
<li><a href="http://www.2043.cn/">2048</a></li>
<li><a href="https://www.yibilian.cn/">一笔连</a></li>
<li><a href="https://www.hannuota.cn/">汉诺塔</a></li>
</ul>
<h2 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h2><ul>
<li><a href="https://github.com/JessYanCoding/AndroidAutoSize">屏幕适配</a></li>
<li><a href="https://github.com/Justson/AgentWeb">WebView</a></li>
<li><a href="https://github.com/dwqs/blog/issues/51">vue中优雅使用第三方库</a></li>
</ul>
]]></content>
      <categories>
        <category>Favorite</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>深度和广度优先搜索</title>
    <url>/archives/578d0877.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/18/eQqsCz3FBWHtDiR.jpg" style="zoom:50%;" />

<p>在社交网络中，有一个六度分割理论，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p>
<p>在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。那给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？</p>
<span id="more"></span>

<h3 id="什么是“搜索”算法？"><a href="#什么是“搜索”算法？" class="headerlink" title="什么是“搜索”算法？"></a>什么是“搜索”算法？</h3><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p>
<p>图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如这两种最简单、最“暴力”的深度优先、广度优先搜索，还有 A*、IDA*等启发式搜索算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">// 无向图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>度优先搜索（Breadth-First-Search），我们平常都简称 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p>
<img data-src="https://i.loli.net/2021/08/18/DVuS7w9mAT5CBI8.jpg" style="zoom:50%;" />

<p>下面代码里，bfs() 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 s 表示起始顶点，t 表示终止顶点。我们搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印s-&gt;t的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。</p>
<p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。</p>
<p><strong>prev</strong> 用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。为了正向打印出路径，我们需要递归地来打印。</p>
<img data-src="https://i.loli.net/2021/08/18/f513vUuR42prk6a.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/18/YMK954CkxLmSWwG.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/18/EFjHTwLK2bgmlqh.jpg" style="zoom:50%;" />

<p>广度优先搜索的时间、空间复杂度是多少呢？</p>
<p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。</p>
<p>广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p>
<h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。</p>
<p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略</p>
<p>看下图，搜索的起始顶点是 s，终止顶点是 t，我们希望在图中寻找一条从顶点 s 到顶点 t 的路径。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径。</p>
<img data-src="https://i.loli.net/2021/08/18/z7E48td9X2H63ZM.jpg" style="zoom:50%;" />

<p>深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深度优先搜索的时间、空间复杂度是多少呢？</p>
<p>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。</p>
<p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的表示</title>
    <url>/archives/2f590e8e.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/18/cJ3h8xXgzmMdfSo.jpg" style="zoom:50%;" />

<p>微博、微信、LinkedIn 这些社交软件我想你肯定都玩过吧。在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。那你知道，，如何存储微博、微信等这些社交网络的好友关系吗？</p>
<span id="more"></span>

<h3 id="如何理解“图”（Graph）？"><a href="#如何理解“图”（Graph）？" class="headerlink" title="如何理解“图”（Graph）？"></a>如何理解“图”（Graph）？</h3><p>图中的元素我们叫做<strong>顶点</strong>（vertex），顶点之间建立的连接关系叫做<strong>边</strong>（edge），跟顶点相连接的边的条数叫做顶点的<strong>度</strong>（degree）。拿微信举例子，我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边，每个用户有多少好友对应到图中就是顶点的度。</p>
<img data-src="https://i.loli.net/2021/08/18/bCxUjkyIY2wH1eT.jpg" style="zoom:50%;" />

<p>我们还把边有方向的图叫做“有向图”，把边没有方向的图叫做“无向图”。有向图中又把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。微博的社交关系就需要用到有向图，它允许单向关注，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。</p>
<img data-src="https://i.loli.net/2021/08/18/l1mUSZFCvcTkhDq.jpg" style="zoom:50%;" />

<p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p>
<p>再来看QQ，它里面的社交关系要更复杂一点，其中的QQ亲密度功能不仅记录了用户间的好友关系，还记录了两个用户间的亲密度，这里就需要用到另一种图，<strong>带权图</strong>（weighted graph），每条边都有一个权重（weight），依次表示QQ好友间的亲密度。</p>
<img data-src="https://i.loli.net/2021/08/18/sRNGC6YnBmDh8lw.jpg" style="zoom:50%;" />

<h3 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h3><p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）。</p>
<p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。</p>
<img data-src="https://i.loli.net/2021/08/18/t7pSoh9XeB56yiv.jpg" style="zoom:50%;" />

<p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p>
<p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。无向图的二维数组中，如果我们将其用对角线划分为上下两部分，可知一半空间都浪费了。</p>
<p>还有，如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p>
<p>邻接矩阵的存储方法也有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall</a>算法，就是利用矩阵循环相乘若干次得到结果。</p>
<h3 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h3><p>针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，<strong>邻接表</strong>（Adjacency List）。</p>
<p>乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p>
<img data-src="https://i.loli.net/2021/08/18/rQ3DlCLZMR42Gsg.jpg" style="zoom:50%;" />

<p>还记得我们之前讲过的时间、空间复杂度互换的设计思想吗？邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p>
<p>比如图中的例子，如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p>
<p>当然，如果链过长，也可以将链表换成其他更高效的数据结构，比如平衡二叉查找树（红黑树）、跳表等</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的应用</title>
    <url>/archives/629ab5f5.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/f8rB9iq4zHYaTQt.jpg" style="zoom:50%;" />

<p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？</p>
<span id="more"></span>

<h3 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h3><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<ol>
<li> <strong>合并有序小文件</strong></li>
</ol>
<p>我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p>
<p>假设，这个最小的字符串来自于 13.txt 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p>
<p>这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</p>
<p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p>
<p>我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 $O(logn)$，n 表示堆中的数据个数，这里就是 100，这样就比原来数组存储的方式高效多了。</p>
<ol start="2">
<li><strong>高效能定时器</strong></li>
</ol>
<p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p>
<img data-src="https://i.loli.net/2021/08/17/486vhqnBfGMzUjL.jpg" style="zoom:50%;" />

<p>这样每过 1 秒就扫描一遍任务列表的做法比较低效：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p>
<p>针对这些问题，我们可以采用优先级队列来解决。按照任务的执行时间，将这些任务存储到优先级队列中，队里首部（小顶堆堆顶）存储的是最先执行的任务。</p>
<p>它可以拿首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。定时器便可以设定在时间 T 之后，再执行任务，从当前时间到（T-1）秒这段时间不需要做任何事情。</p>
<p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</p>
<h3 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h3><p>首先把这种求 Top K 的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p>
<p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p>
<p>遍历数组需要 $O(n)$ 的时间复杂度，一次堆化操作需要 $O(logK)$ 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 $O(nlogK)$。</p>
<p>针对动态数据求得 Top K 就是实时 Top K。我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。</p>
<h3 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h3><p>中位数，顾名思义，就是处在中间位置的数。如果数的个数是奇数，取第 $\frac n2+1$ 个；如果个数是偶数，就取第 $\frac n2$ 个或第 $\frac n2 + 1$ 个中一个。</p>
<p>对于一组<strong>静态数据</strong>，可以想先排序，直接取中位数。如果面对<strong>动态数据</strong>集合，中位数在不断变动，如果也采用先排序的方式，那效率就不高了。</p>
<p>我们借助堆就能高效解决这个问题。需要维护两个堆，一个大顶堆，一个小顶堆，大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆数据都大于大顶堆中数据。如此，大顶堆堆顶元素便是需要的中位数：</p>
<img data-src="https://i.loli.net/2021/08/17/VIqdAzwDiZWbLtm.jpg" style="zoom:50%;" />

<p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p>
<p>当两个堆中的数据个数不符合约定时便需要调整：</p>
<img data-src="https://i.loli.net/2021/08/17/3PQBvqkG74oXemT.jpg" style="zoom:50%;" />

<p>实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。</p>
<p>比如求 99% 响应时间。大顶堆中保存 99% 个数据，小顶堆中保存 1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p><strong>有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？</strong></p>
<p>限定内存为 1GB。</p>
<p>考虑到关键词中有很多重复的，首先统计每个关键词的频率，可以通过散列表、平衡二叉查找树等记录关键词及其出现次数。</p>
<p>假设选用散列表顺序扫描这10亿个关键词，统计存储后，在用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表即可。</p>
<p>这里有个漏洞，10亿关键词还是很多的，假设不重复的有1 亿条，每条关键词平均长度为 50 字节，那存储这些关键词需要5GB的内存空间，而且散列表为了避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间更多。</p>
<p>这时可以用到哈希算法，通过哈希算法现将10亿条关键词分片到10个文件中。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和堆排序</title>
    <url>/archives/2fad594d.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/qHFQo1w4nR7bfZP.jpg" style="zoom:50%;" />

<p>“堆”（Heap），是一种特殊的树，其应用场景广泛，最经典的莫过于堆排序了，它是一种原地的、时间复杂度为 $O(nlogn)$ 的排序算法。</p>
<p>快速排序，平均情况下的时间复杂度也为 $O(nlogn)$，而且堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？</p>
<span id="more"></span>

<h3 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h3><ul>
<li><p>堆是一个完全二叉树；</p>
</li>
<li><p>堆中每一个节点的值都必须大于等于&lt;“大顶堆”&gt;（或小于等于&lt;“小顶堆”&gt;）其子树中每个节点的值。</p>
</li>
</ul>
<h3 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h3><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。下面是一个用数组存储堆的例子。</p>
<img data-src="https://i.loli.net/2021/08/17/GVpPJMldQrnKh2O.jpg" style="zoom:50%;" />

<p>从图中我们可以看到，数组中下标为 $i$ 的节点的左子节点，就是下标为 $i∗2$ 的节点，右子节点就是下标为 $i∗2+1$ 的节点，父节点就是下标为 $\frac i2$ 的节点。</p>
<p>知道了如何存储一个堆，那我们再来看看，堆上的操作有哪些呢？下面罗列了几个非常核心的操作，分别是往堆中插入一个元素和删除堆顶元素。（如果没有特殊说明，下面都是拿大顶堆来讲解）。</p>
<ol>
<li><strong>往堆中插入一个元素</strong></li>
</ol>
<p>插入一个元素后，就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做<strong>堆化（heapify）</strong>。</p>
<p>堆化实际上有两种，从下往上和从上往下。这里我先讲<strong>从下往上</strong>的堆化方法。</p>
<img data-src="https://i.loli.net/2021/08/17/a98pArTQdcs5VhU.jpg" style="zoom:50%;" />

<p>我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p>
<img data-src="https://i.loli.net/2021/08/17/L1eGUftBPFo75TY.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span>; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="keyword">int</span> i = count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>删除堆顶元素</strong></li>
</ol>
<p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p>
<p>不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。</p>
<img data-src="https://i.loli.net/2021/08/17/1gOwol4Zkqu5FpQ.jpg" style="zoom:50%;" />

<p>我们可以把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下</strong>的堆化方法。</p>
<p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p>
<img data-src="https://i.loli.net/2021/08/17/cWuQKwbgV6IeANJ.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个包含 $n$ 个节点的完全二叉树，树的高度不会超过 $log_2n$。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 $O(logn)$。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 $O(logn)$。</p>
<h3 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h3><p>堆排序的过程大致分解成两个大的步骤，建堆和排序</p>
<ol>
<li> <strong>建堆</strong></li>
</ol>
<p>首先将数组原地建成一个堆。</p>
<p>第一种是利用前面往堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</p>
<p>第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</p>
<p>下面给出一个第二种实现思路的建堆分解步骤图，因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从最后一个非叶子节点开始，依次堆化就行了。</p>
<img data-src="https://i.loli.net/2021/08/17/XIefBErOHumhAlG.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/17/K1UcDmZoiYEBMNQ.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们对下标从 $\frac n2$开始到 $1$ 的数据进行堆化，下标是 $\frac n2+1$ 到 $n$ 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 $\frac n2+1$到 $n$ 的节点都是叶子节点。</p>
<p>每个节点堆化的时间复杂度是 O(logn)，那 2n+1 个节点堆化的总时间复杂度是不是就是 O(nlogn) 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是 O(n)。</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。</p>
<img data-src="https://i.loli.net/2021/08/17/Af983kbiWyKuTgv.jpg" style="zoom:50%;" />

<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<img data-src="https://i.loli.net/2021/08/17/iMdwhqcXyWLentA.jpg" style="zoom:50%;" />

<p>这个公式的求解稍微有点技巧，不过我们高中应该都学过：把公式左右都乘以 2，就得到另一个公式 S2。我们将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。</p>
<img data-src="https://i.loli.net/2021/08/17/xJVF8otqHfybPzm.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/17/GAdKjWn2MiNa8FQ.jpg" style="zoom:50%;" />

<p>因为 h=log2n，代入公式 S，就能得到 S=O(n)，所以，建堆的时间复杂度就是 O(n)。</p>
<ol start="2">
<li><strong>排序</strong></li>
</ol>
<p>建堆结束后，按照大顶堆的特性，第一个元素就是堆顶，也是最大的元素，将其与最后一个元素交换。下一步将剩下的 $n-1$ 个元素重新构建成堆，堆化完成后，再取堆顶的元素，放到 $n-1$ 的位置，不断重复此过程，直到排序完成。</p>
<img data-src="https://i.loli.net/2021/08/17/GVO3nxRcWLp9qF5.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlogn)$，所以，堆排序整体的时间复杂度是 $O(nlogn)$。</p>
<p>堆排序不是稳定的排序算法，因为在排序过程中，存在将堆的最后一个节点与堆顶节点互换的操作，有可能改变值相同数据的原始顺序。</p>
<h3 id="在实际开发中，为什么快速排序要比堆排序性能好？"><a href="#在实际开发中，为什么快速排序要比堆排序性能好？" class="headerlink" title="在实际开发中，为什么快速排序要比堆排序性能好？"></a>在实际开发中，为什么快速排序要比堆排序性能好？</h3><ul>
<li><strong>堆排序数据访问的方式没有快速排序友好</strong></li>
</ul>
<p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的，对cpu缓存不友好</p>
<ul>
<li><strong>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</strong></li>
</ul>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归树</title>
    <url>/archives/66071d43.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/6jh1Rva2smYKbrw.jpg" style="zoom:50%;" />

<p>我们可以借助借助递归树来分析递归算法的时间复杂度</p>
<span id="more"></span>

<h3 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h3><p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p>
<p>如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作递归树。下图是斐波那契数列的递归树，结点数字表示数据规模，一个节点的求解可以分解为左右子节点两个问题的求解。</p>
<img data-src="https://i.loli.net/2021/08/17/YoIO3L29iPKdxwF.jpg" style="zoom:50%;" />

<p>我们借助归并排序来看看如何用递归树来分析递归代码的时间复杂度。</p>
<img data-src="https://i.loli.net/2021/08/17/MhHqG5vgtmOJE1n.jpg" style="zoom:50%;" />

<p>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。</p>
<p>现在，我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 $O(n∗h)$。从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。</p>
<p>满二叉树的高度大约是 $log_2n$，所以，归并排序递归实现的时间复杂度就是 $O(nlogn)$。我这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。</p>
<h3 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h3><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 $T(n)=2T(2n)+n$​，很容易就能推导出时间复杂度是 $O(nlogn)$。但是，我们并不可能每次分区都这么幸运，正好一分为二。</p>
<p>我们假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 $T(n)=T(10n)+T(109n)+n$。</p>
<p>我们还是取 k 等于 9，也就是说，每次分区都很不平均，一个分区是另一个分区的 9 倍。如果我们把递归分解的过程画成递归树:</p>
<img data-src="https://i.loli.net/2021/08/17/4iToLW3h2HlRtXy.jpg" style="zoom:50%;" />

<p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 $h$，这个快排过程遍历的数据个数就是 $h∗n$ ，也就是说，时间复杂度就是 $O(h∗n)$。因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？</p>
<p>我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 $\frac{1}{10}$​​，最长的一个路径每次都乘以$\frac{9}{10}$​​。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 $log_{10}n$​​，最长的路径是 $log_{\frac{10}{9}}n$​​。</p>
<img data-src="https://i.loli.net/2021/08/17/WqNR1oJbO4euB2X.jpg" style="zoom:50%;" />

<p>所以，遍历数据的个数总和就介于 $log_{10}n$​ 和 $log_{\frac{10}{9}}n$​ 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 $logn$​，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 $O(nlogn)$​。</p>
<p>依次类推，k=99 甚至更大时，时间复杂度仍是$O(nlogn)$</p>
<h3 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面代码画成递归树：</p>
<img data-src="https://i.loli.net/2021/08/17/jvwqh5yZo4GJ6rV.jpg" style="zoom:50%;" />

<p>f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 $\frac n2$。</p>
<p>每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 $2^2$。依次类推，第 k 层的时间消耗就是 $2^{k−1}$，​那整个算法的总的时间消耗就是每一层时间消耗之和。</p>
<p>如果路径长度都为 n，那这个总和就是 $2^n−1$。</p>
<img data-src="https://i.loli.net/2021/08/17/OTFrIJL4jR1yQnD.jpg" style="zoom:50%;" />

<p>如果路径长度都是 $\frac n2$ ，那整个算法的总的时间消耗就是 $2^{\frac n2}−1$​。</p>
<img data-src="https://i.loli.net/2021/08/16/XO7VnQdpHcPZeK2.jpg" style="zoom:50%;" />

<p>所以，这个算法的时间复杂度就介于 O($2^n$​​) 和 O($2^{\frac n2}$​​) 之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。</p>
<h3 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h3><p>在高中的时候都学过排列组合。“如何把 n 个数据的所有排列都找出来”，这就是全排列的问题。</p>
<p>如果我们确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。</p>
<p>如果我们把它写成递推公式，就是下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设数组中存储的是<span class="number">1</span>，<span class="number">2</span>， <span class="number">3.</span>..n。</span><br><span class="line">        </span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,...n) = &#123;最后一位是<span class="number">1</span>, f(n-<span class="number">1</span>)&#125; + &#123;最后一位是<span class="number">2</span>, f(n-<span class="number">1</span>)&#125; +...+&#123;最后一位是n, f(n-<span class="number">1</span>)&#125;。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用方式：</span></span><br><span class="line"><span class="comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span></span><br><span class="line"><span class="comment">// k表示要处理的子数组的数据个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPermutations</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      System.out.print(data[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = data[i];</span><br><span class="line">    data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">    data[k-<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    printPermutations(data, n, k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    tmp = data[i];</span><br><span class="line">    data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">    data[k-<span class="number">1</span>] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们来看下，如何借助递归树，轻松分析出这个代码的时间复杂度。不过，这个递归树已经不是标准的二叉树了。</p>
<img data-src="https://i.loli.net/2021/08/17/f42UkMeC6EIc3lQ.jpg" style="zoom:50%;" />

<p>第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 $n∗(n−1)$。第三层有 $n∗(n−1)$ 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 $n∗(n−1)∗(n−2)$。</p>
<p>以此类推，第 k 层总的交换次数就是 $n∗(n−1)∗(n−2)∗…∗(n−k+1)$。最后一层的交换次数就是 $n∗(n−1)∗(n−2)∗…∗2∗1$。每一层的交换次数之和就是总的交换次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n + n*(n-<span class="number">1</span>) + n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>) +... + n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>)*...*<span class="number">2</span>*<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个公式的求和比较复杂，我们看最后一个数，$n∗(n−1)∗(n−2)∗…∗2∗1$ 等于 $n!$，而前面的 $n−1$ 个数都小于最后一个数，所以，总和肯定小于 $n∗n!$，也就是说，全排列的递归算法的时间复杂度大于 $O(n!)$，小于 $O(n∗n!)$，虽然我们没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。</p>
<p>假设细胞是先分裂再死亡，三个小时后开始死亡的细胞个数，也就是存活了三个小时的细胞，即四个小时前的细胞个数。由此得到递推公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(0) &#x3D; 1;</span><br><span class="line">f(1) &#x3D; 2;</span><br><span class="line">f(2) &#x3D; 4;</span><br><span class="line">f(4) &#x3D; 7;</span><br><span class="line">f(n) &#x3D; 2*f(n-1) - f(n-4);</span><br></pre></td></tr></table></figure>

<p>和斐波那契数列类似，复杂度介于 O($2^n$​) 和 O($2^{\frac n4}$​​) 之间，也是指数级</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/archives/f89cb603.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/6DqeRPSahmWwAYF.jpg" style="zoom:50%;" />

<p>二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)，要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树。</p>
<p>很多书籍里，但凡讲到平衡二叉查找树，就会拿红黑树作为例子。不仅如此，如果你有一定的开发经验，你会发现，在工程中，很多用到平衡二叉查找树的地方都会用红黑树。你有没有想过，<strong>为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</strong></p>
<span id="more"></span>

<h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。</p>
<p>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是[AVL](<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树 - 维基百科，自由的百科全书 (wikipedia.org)</a>) 树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p>
<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p>
<p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，它的定义是不严格符合平衡二叉查找树的定义的。红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重</strong>。</p>
<p>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。</p>
<p>首先，我们来看，如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？</p>
<p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p>
<img data-src="https://i.loli.net/2021/08/17/iFYVgouaCSKzs84.jpg" style="zoom:50%;" />

<p>前面红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p>
<p>完全二叉树的高度近似 log2n，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 log2n。我们现在知道只包含黑色节点的“黑树”的高度，那我们现在把红色节点加回去，高度会变成多少呢？</p>
<p>从上面红黑树的例子和定义看，在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。</p>
<p>所以，红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>几种动态数据结构对比：</p>
<ul>
<li><p>散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。</p>
</li>
<li><p>跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。</p>
</li>
<li><p>红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。</p>
</li>
</ul>
<hr>
<img data-src="https://i.loli.net/2021/08/17/D4Gh3ySZAavLlQ8.jpg" style="zoom:50%;" />

<p>上一节，我们讲到红黑树定义的时候，提到红黑树的叶子节点都是黑色的空节点。当时我只是粗略地解释了，这是为了代码实现方便，那更加确切的原因是什么呢？</p>
<h3 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h3><p>红黑树的平衡过程跟魔方复原非常神似，大致过程就是：<strong>遇到什么样的节点排布，我们就对应怎么去调整</strong>。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p>
<p>先介绍两个非常重要的操作，<strong>左旋（rotate left）、右旋（rotate right）</strong>。左旋全称其实是叫<strong>围绕某个节点的左旋</strong>，那右旋的全称估计你已经猜到了，就叫<strong>围绕某个节点的右旋</strong>。</p>
<img data-src="https://i.loli.net/2021/08/17/2RMTkCSpXZWD358.jpg" style="zoom:50%;" />

<h3 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h3><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</p>
<ul>
<li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li>
</ul>
<p>除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p>
<p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫做<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p>
<p>新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。</p>
<p><strong>CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色</strong>，我们就依次执行下面的操作：</p>
<ul>
<li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；</li>
<li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li>
<li>关注节点变成 a 的祖父节点 c；</li>
<li>跳到 CASE 2 或者 CASE 3。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/JDXZ1aEyduUKekG.jpg" style="zoom:50%;" />

<p><strong>CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点</strong>，我们就依次执行下面的操作：</p>
<ul>
<li>关注节点变成节点 a 的父节点 b；</li>
<li>围绕新的关注节点b 左旋；</li>
<li>跳到 CASE 3。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/Gb9yfuQrqJ5MlwH.jpg" style="zoom:50%;" />

<p><strong>CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</strong>，我们就依次执行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的祖父节点 c 右旋；</li>
<li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</li>
<li>调整结束。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/Ernv3yQxod1SOaw.jpg" style="zoom:50%;" />

<h3 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h3><p>删除操作的平衡调整分为两步，第一步是<strong>针对删除节点初步调整</strong>。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是<strong>针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p>
<ol>
<li><strong>针对删除节点初步调整</strong></li>
</ol>
<p>这里需要注意一下，红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p>
<p>在下面的讲解中，如果一个节点既可以是红色，也可以是黑色，在画图的时候，我会用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，我会用左上角的一个小黑点来表示额外的黑色。</p>
<p><strong>CASE 1：如果要删除的节点是 a，它只有一个子节点 b</strong>，那我们就依次进行下面的操作：</p>
<ul>
<li>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li>
<li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li>
<li>调整结束，不需要进行二次调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/15/31TUMeu7Ymi6Xvg.jpg" style="zoom:50%;" />

<p><strong>CASE 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</strong>。我们就依次进行下面的操作：</p>
<ul>
<li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li>
<li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li>
<li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；</li>
<li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/fg3K8FRyrde4Hqj.jpg" style="zoom:50%;" />

<p><strong>CASE 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；</li>
<li>将节点 a 替换成后继节点 d；</li>
<li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li>
<li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；</li>
<li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/N8HPL5yF1DQzoAU.jpg" style="zoom:50%;" />

<ol start="2">
<li><strong>针对关注节点进行二次调整</strong></li>
</ol>
<p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p>
<p><strong>CASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的父节点 b 左旋；</li>
<li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li>
<li>关注节点不变；</li>
<li>继续从四种情况中选择适合的规则来调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/J6VTUz3wRKhi5bc.jpg" style="zoom:50%;" />

<p><strong>CASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li>
<li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li>
<li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；</li>
<li>关注节点从 a 变成其父节点 b；</li>
<li>继续从四种情况中选择符合的规则来调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/8Tvira7pKY9gOnZ.jpg" style="zoom:50%;" />

<p><strong>CASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的兄弟节点 c 右旋；</li>
<li>节点 c 和节点 d 交换颜色；</li>
<li>关注节点不变；</li>
<li>跳转到 CASE 4，继续调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/MxRpFfetV2N7TSj.jpg" style="zoom:50%;" />

<p><strong>CASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的父节点 b 左旋；</li>
<li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li>
<li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li>
<li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li>
<li>将关注节点 a 的叔叔节点 e 设置为黑色；</li>
<li>调整结束。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/7YRw2l4mSnZ9K1Q.jpg" style="zoom:50%;" />

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p><strong>为什么红黑树的定义中，要求叶子节点是黑色的空节点？</strong></p>
<p>要我说，之所以有这么奇怪的要求，其实就是为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为我们刚刚讲的那几种情况。</p>
<p>还是有点不好理解，我通过一个例子来解释一下。假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”，我们往一棵红黑树中插入一个数据，新插入节点的父节点也是红色的，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。那我们应该如何调整呢？</p>
<img data-src="https://i.loli.net/2021/08/17/6Wb15uI2RdHPDFS.jpg" style="zoom: 50%;" />

<p>你会发现，这个时候，我们前面在讲插入时，三种情况下的平衡调整规则，没有一种是适用的。但是，如果我们把黑色的空节点都给它加上，变成下面这样，你会发现，它满足 CASE 2 了。</p>
<img data-src="https://i.loli.net/2021/08/17/iDdTgm5YP2BhbSt.jpg" style="zoom:50%;" />

<p>你可能会说，你可以调整一下平衡调整规则啊。比如把 CASE 2 改为“如果关注节点 a 的叔叔节点 b 是黑色或者不存在，a 是父节点的右子节点，就进行某某操作”。当然可以，但是这样的话规则就没有原来简洁了。</p>
<p>你可能还会说，这样给红黑树添加黑色的空的叶子节点，会不会比较浪费存储空间呢？答案是不会的。虽然我们在讲解或者画图的时候，每个黑色的、空的叶子节点都是独立画出来的。实际上，在具体实现的时候，我们只需要像下面这样，共用一个黑色的、空的叶子节点就行了。</p>
<img data-src="https://i.loli.net/2021/08/17/mapBqIcMj9Furyz.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础</title>
    <url>/archives/84ac9751.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/1ZjWmtS6UAJiwdR.jpg" style="zoom:50%;" />

<p>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</p>
<span id="more"></span>

<h3 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h3><p>“树”里面每个元素我们叫做“节点”，用来连接相邻节点之间的关系，我们叫做“父子关系”。下图中，A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p>
<img data-src="https://i.loli.net/2021/08/17/twphd5oCvk8yUrf.jpg" style="zoom:50%;" />

<p>除此之外，关于“树”，还有三个比较相似的概念：<strong>高度</strong>（Height）、<strong>深度</strong>（Depth）、<strong>层</strong>（Level）。它们的定义是这样的：</p>
<img data-src="https://i.loli.net/2021/08/17/GRuwFW2Irmg18PZ.jpg" style="zoom:50%;" />

<p>这三个概念的定义比较容易混淆，描述起来也比较空洞。我举个例子说明一下，你一看应该就能明白。</p>
<img data-src="https://i.loli.net/2021/08/15/B5oAS48XL1f7lwj.jpg" style="zoom:50%;" />

<h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点。</p>
<img data-src="https://i.loli.net/2021/08/17/ZmAI6zVs9rhJKtY.jpg" style="zoom:50%;" />

<p>上图中三个都是二叉树，其中，编号 2 的二叉树也叫做满二叉树，特征是除叶子结点外每个结点都有两个子节点。</p>
<p>编号 3 的二叉树叫做完全二叉树，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。</p>
<p>为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？</p>
<p>这是由二叉树的实现来定义的，先来了解下如何表示（存储）一棵二叉树？</p>
<p>先来看比较简单、直观的链式存储法。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<img data-src="https://i.loli.net/2021/08/17/e7qhUGwbBAurHy6.jpg" style="zoom:50%;" />

<p>我们再来看，基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p>
<img data-src="https://i.loli.net/2021/08/17/PFXASywYujfskgx.jpg" style="zoom:50%;" />

<p>上图是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。</p>
<img data-src="https://i.loli.net/2021/08/17/D9ndF2U1Gtm3pwH.jpg" style="zoom:50%;" />

<p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。</p>
<ul>
<li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li>
<li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li>
<li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/Dbtuwo1W6dzVPNe.jpg" style="zoom:50%;" />

<p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure>

<p>每个结点最多会被访问两次，时间复杂度为O(n)。</p>
<hr>
<img data-src="https://i.loli.net/2021/08/17/matwhKI5B8WyPkp.jpg" style="zoom:50%;" />

<h3 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h3><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<img data-src="https://i.loli.net/2021/08/17/dBWGVTJRNfZ9LkF.jpg" style="zoom:50%;" />

<ol>
<li><strong>二叉查找树的查找操作</strong></li>
</ol>
<p>先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<img data-src="https://i.loli.net/2021/08/17/lRQ9wpMSBDOu3hb.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>二叉查找树的插入操作</strong></li>
</ol>
<p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<img data-src="https://i.loli.net/2021/08/17/XrRk1AvWdhZwMKo.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>二叉查找树的删除操作</strong></li>
</ol>
<p>针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p>
<ul>
<li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</li>
<li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</li>
<li>如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/IvxqRQrony9WNjC.jpg" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。</p>
<p>还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p>
<h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。</p>
<p>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？</p>
<p>第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
<p>第二种方法比较不好理解，不过更加优雅。每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
<img data-src="https://i.loli.net/2021/08/17/mIt9126wc4szkGl.jpg" style="zoom:50%;" />

<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<img data-src="https://i.loli.net/2021/08/17/f8tLTjS64iFsb7R.jpg" style="zoom:50%;" />

<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
<img data-src="https://i.loli.net/2021/08/17/Mz1PEAvi9ydDSeF.jpg" style="zoom:50%;" />

<h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<img data-src="https://i.loli.net/2021/08/15/cCs2r4I61GBNz3U.jpg" style="zoom:50%;" />

<p>现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。</p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p>
<p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p>
<p>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt;&#x3D; 1+2+4+8+...+2^(L-2)+1</span><br><span class="line">n &lt;&#x3D; 1+2+4+8+...+2^(L-2)+2^(L-1)</span><br></pre></td></tr></table></figure>

<p>借助等比数列的求和公式，我们可以计算出，L 的范围是[log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，<strong>那我们为什么还要用二叉查找树呢？</strong></p>
<ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
<li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
<li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ul>
<p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p>
<p><strong>如何通过编程，求出一棵给定二叉树的确切高度呢？</strong></p>
<ul>
<li><p>确定二叉树高度有两种思路：第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。</p>
</li>
<li><p>递归法，根节点高度=max(左子树高度，右子树高度)+1</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/archives/22e30075.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/14/ZHdMhOrVlLy8Cba.jpg" style="zoom:50%;" />

<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</p>
<span id="more"></span>

<p>如果想要设计一个哈希算法，需要满足以下几点要求：</p>
<ul>
<li><p>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</p>
</li>
<li><p>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</p>
</li>
<li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p>
</li>
<li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</p>
</li>
</ul>
<h3 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h3><p>说到哈希算法的应用，最先想到的应该就是安全加密。最常用于加密的哈希算法是 <strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 <strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。除了这两个之外，还有很多其他加密算法，比如 <strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p>
<p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p>
<p>不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。</p>
<p>这基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。这个原理本身很简单，它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p>
<p>比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p>
<p>没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。</p>
<h3 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h3><p>可以先举一个例子。如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那我们该如何搜索呢？</p>
<p>我们知道，任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时。有没有比较快的方法呢？</p>
<p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p>
<p>如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p>
<p>如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p>
<h3 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h3><p>BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p>
<p>具体的 BT 协议很复杂，校验方法也有很多，来谈谈其中的一种思路。</p>
<p>我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p>
<h3 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h3><p>散列函数也是哈希算法的一种应用。</p>
<p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p>
<p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
<hr>
<img data-src="https://i.loli.net/2021/08/14/qfg315so42LFanQ.jpg" style="zoom:50%;" />

<h3 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h3><p>我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p>
<p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p>
<ul>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li>
</ul>
<p>如果借助哈希算法，这些问题都可以非常完美地解决。<strong>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号</strong>。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h3 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h3><ol>
<li><strong>如何统计“搜索关键词”出现的次数？</strong></li>
</ol>
<p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？</p>
<p>我们来分析一下。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p>
<p>针对这两个难点，<strong>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度</strong>。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
<p>实际上，这里的处理过程也是 MapReduce 的基本设计思想。</p>
<ol start="2">
<li><strong>如何快速判断图片是否在图库中？</strong></li>
</ol>
<p>假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。</p>
<p>我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p>
<p>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
<p>现在，我们来估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。</p>
<p>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。</p>
<p>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。</p>
<p>实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。应用七：分布式存储</p>
<h3 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h3><p>现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。</p>
<p>该如何决定将哪个数据放到哪个机器上呢？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p>
<p>但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。</p>
<p>原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。</p>
<p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生[雪崩效应](<a href="https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94">雪崩效应 - 维基百科，自由的百科全书 (wikipedia.org)</a>)，压垮数据库。</p>
<p>所以，我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<a href="https://www.zsythink.net/archives/1182">一致性哈希算法</a>就要登场了。</p>
<p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（下）</title>
    <url>/archives/feeabc3.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/vuCV4SjXpI1UJaf.jpg" style="zoom:50%;" />

<p>为什么散列表和链表经常会一起使用？</p>
<span id="more"></span>

<p>在链表那一节，有讲到如何用链表来实现 LRU 缓存淘汰算法，但是链表实现的 LRU 缓存淘汰算法的时间复杂度是 O(n)，当时也提到了，通过散列表可以将这个时间复杂度降低到 O(1)。</p>
<p>在跳表那一节，提到 Redis 的有序集合是使用跳表来实现的，跳表可以看作一种改进版的链表。当时也提到，Redis 有序集合不仅使用了跳表，还用到了散列表。</p>
<p>除此之外，如果你熟悉 Java 编程语言，你会发现 LinkedHashMap 这样一个常用的容器，也用到了散列表和链表两种数据结构。</p>
<h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p>具体结构是下面这个样子：</p>
<img data-src="https://i.loli.net/2021/08/17/TEmRAHlkZQCtKVs.jpg" style="zoom:50%;" />

<p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？</p>
<p>因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的<strong>双向链表</strong>，另一个链是散列表中的<strong>拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中</strong>。</p>
<p>首先，我们来看如何<strong>查找一个数据</strong>。我们前面讲过，散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。</p>
<p>其次，我们来看如何<strong>删除一个数据</strong>。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</p>
<p>最后，我们来看如何<strong>添加一个数据</strong>。添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p>
<h3 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h3><p>在有序集合中，每个成员对象有两个重要的属性，key（键值）和 score（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。</p>
<p>举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。</p>
<p>如果我们细化一下 Redis 有序集合的操作，那就是下面这样：</p>
<ul>
<li><p>添加一个成员对象；</p>
</li>
<li><p>按照键值来删除一个成员对象；</p>
</li>
<li><p>按照键值来查找一个成员对象；</p>
</li>
<li><p>按照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象；</p>
</li>
<li><p>按照分值从小到大排序成员变量；</p>
</li>
</ul>
<p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。</p>
<h3 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h3><p>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</p>
<ul>
<li><p>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；</p>
</li>
<li><p>查找积分在某个区间的猎头 ID 列表；</p>
</li>
<li><p>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</p>
</li>
</ul>
<p>采用跳表+散列表两种数据结构进行实现。 以key为猎头ID， vlaue为积分信息存储到散列表中，并根据积分将节点存储到跳表中，跳表中的数据都是有序的。 更新猎头的积分信息？ 先维护散列表猎头信息，再将跳表中的猎头信息删除，删除完成以后进行重新添加。 如何根据积分范围查找猎头呢？ 跳表中的数据是有序的，先在跳表中找到最小值，开始依次查找，直到查找到的数据大于积分范围为止。将中间的猎头数据进行返回即可。 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表 从跳表中依次遍历。但是时间复杂度为O(n); 时间复杂度分析： 1. 增加：O(logn); 2.删除：O(1); 3.查找：O(1); 4.积分范围查找：O(logn);</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（中）</title>
    <url>/archives/8ab75b21.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/vhNzF4WfudjAVgc.jpg" style="zoom:50%;" />

<p>如何打造一个工业级水平的散列表？</p>
<span id="more"></span>

<p>通过上节的学习，我们知道，散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p>
<p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p>
<p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p>
<h3 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h3><p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，我举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。</p>
<p>第一个例子就是我们上一节的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫做“数据分析法”。</p>
<p>第二个例子就是上一节的开篇思考题，如何实现 Word 拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 nice，我们转化出来的散列值就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(<span class="string">&quot;nice&quot;</span>)=((<span class="string">&quot;n&quot;</span> - <span class="string">&quot;a&quot;</span>) * <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">&quot;i&quot;</span> - <span class="string">&quot;a&quot;</span>)*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">&quot;c&quot;</span> - <span class="string">&quot;a&quot;</span>)*<span class="number">26</span>+ (<span class="string">&quot;e&quot;</span>-<span class="string">&quot;a&quot;</span>)) / <span class="number">78978</span></span><br></pre></td></tr></table></figure>

<p>实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些你只要了解就行了，不需要全都掌握。</p>
<h3 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h3><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p>
<p>对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p>
<p>这个时候，我们该如何处理呢？还记得我们前面多次讲的“动态扩容”吗？你可以回想一下，我们是如何做数组、栈、队列的动态扩容的。针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p>
<p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。</p>
<img data-src="https://i.loli.net/2021/08/17/NfytnJAzZDplHwu.jpg" style="zoom:50%;" />

<p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
<p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p>
<p>我们前面讲到，当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p>
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<h3 id="如何避免低效的扩容？"><a href="#如何避免低效的扩容？" class="headerlink" title="如何避免低效的扩容？"></a>如何避免低效的扩容？</h3><p>举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？</p>
<p>如果我们的业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。</p>
<p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p>
<p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<img data-src="https://i.loli.net/2021/08/17/Dz46ejmGlZYVt3L.jpg" style="zoom:50%;" />

<p>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p>
<h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><ol>
<li><strong>开放寻址法</strong></li>
</ol>
<p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。我们后面就有一节会讲什么是数据结构序列化、如何序列化，以及为什么要序列化。</p>
<p>上一节我们讲到，用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>
<p><strong>总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p>
<ol start="2">
<li><strong>链表法</strong></li>
</ol>
<p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</p>
<p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p>
<p>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p>
<p>当然，如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p>
<p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p>
<img data-src="https://i.loli.net/2021/08/17/CpwTSxUV7g6o9uh.jpg" style="zoom:50%;" />

<p><strong>总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p>
<h3 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h3><p>现在，我就拿一个具体的例子，Java 中的 HashMap 这样一个工业级的散列表，来具体看下，这些技术是怎么应用的。</p>
<ol>
<li><strong>初始大小</strong></li>
</ol>
<p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p>
<ol start="2">
<li><strong>装载因子和动态扩容</strong></li>
</ol>
<p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>
<ol start="3">
<li><strong>散列冲突解决办法</strong></li>
</ol>
<p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p>
<p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p>
<ol start="4">
<li><strong>散列函数</strong></li>
</ol>
<p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。我把它摘抄出来，你可以看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capicity -<span class="number">1</span>); <span class="comment">//capicity表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何设计一个工业级的散列函数？"><a href="#如何设计一个工业级的散列函数？" class="headerlink" title="如何设计一个工业级的散列函数？"></a>如何设计一个工业级的散列函数？</h3><p>首先，我会思考，<strong>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</strong></p>
<p>结合已经学习过的散列知识，我觉得应该有这样几点要求：</p>
<ul>
<li><p>支持快速地查询、插入、删除操作；</p>
</li>
<li><p>内存占用合理，不能浪费过多的内存空间；</p>
</li>
<li><p>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</p>
</li>
</ul>
<p><strong>如何实现这样一个散列表呢？</strong>根据前面讲到的知识，我会从这三个方面来考虑设计思路：</p>
<ul>
<li><p>设计一个合适的散列函数；</p>
</li>
<li><p>定义装载因子阈值，并且设计动态扩容策略；</p>
</li>
<li><p>选择合适的散列冲突解决方法。</p>
</li>
</ul>
<p>关于散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，我们前面都讲过了，具体如何选择，还要结合具体的业务场景、具体的业务数据来具体分析。不过只要我们朝这三个方向努力，就离设计出工业级的散列表不远了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（上）</title>
    <url>/archives/b752cca6.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/z1tIcxdis9orCSO.jpg" style="zoom:50%;" />

<p>Word 这种文本编辑器你平时应该经常用吧，那你有没有留意过它的拼写检查功能呢？一旦我们在 Word 里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”。Word 的这个单词拼写检查功能，虽然很小但却非常实用。你有没有想过，这个功能是如何实现的呢？</p>
<span id="more"></span>

<h3 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h3><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”</p>
<p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p>举个例子，假设有88名选手参加运动会，每个选手胸前都会贴上自己的参赛号码，现在要通过编程实现通过编号快速找到选手信息。简单考虑，可以将信息放到数组里，编号为k的选手放到数组中下标为k的位置，这里就用到了散列的思想。</p>
<p>又假如校长要求，参赛编号不能这么简单，需要加上年级、班级等信息，编号变成051167的形式，前两位表示年级，中间两位表示班级，最后两位还是原来的编号。思路和前面一致，尽管我们不能直接将编号作为下标，但可以截取编号后两位作为下标，查询时用同样方法取后两位读取数组数据。</p>
<p>这就是典型的散列思想。其中，参赛选手的编号我们叫做<strong>键</strong>（key）或者<strong>关键字</strong>。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作<strong>散列函数</strong>（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作<strong>散列值</strong>（或“Hash 值”“哈希值”）。</p>
<img data-src="https://i.loli.net/2021/08/17/kDVYWCrbiuJfnLq.jpg" style="zoom:50%;" />

<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>三点散列函数设计的基本要求：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li>
</ol>
<p>第三点理解起来可能会有问题，我着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<p>所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><ol>
<li><strong>开放寻址法</strong></li>
</ol>
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，<strong>线性探测</strong>（Linear Probing）。</p>
<p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p>我说的可能比较抽象，我举一个例子具体给你说明一下。这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。</p>
<img data-src="https://i.loli.net/2021/08/17/EoPwd7RNAIT8jea.jpg" style="zoom:50%;" />

<p>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
<p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？</p>
<p>还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p>
<p>我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<img data-src="https://i.loli.net/2021/08/17/hHAL2brjgdWk78f.jpg" style="zoom:50%;" />

<p>线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。</p>
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p>
<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。</p>
<p>装载因子的计算公式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">散列表的装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度</span><br></pre></td></tr></table></figure>

<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<ol start="2">
<li><strong>链表法</strong></li>
</ol>
<p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<img data-src="https://i.loli.net/2021/08/17/aXpmxTIMPN8tczQ.jpg" style="zoom:50%;" />

<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p>
<p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
<h3 id="Word-文档中单词拼写检查功能是如何实现的？"><a href="#Word-文档中单词拼写检查功能是如何实现的？" class="headerlink" title="Word 文档中单词拼写检查功能是如何实现的？"></a>Word 文档中单词拼写检查功能是如何实现的？</h3><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p>
<p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol>
<li><strong>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</strong></li>
</ol>
<p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p>
<p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<ol start="2">
<li><strong>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</strong></li>
</ol>
<p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/archives/2e152a56.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/08/xe4MyIJXcmufOQa.jpg" style="zoom:50%;" />

<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）</p>
<span id="more"></span>

<p>对于存储在链表中的数据，只需要对链表稍加改造，就可以支持类似“二分”的查找算法，我们把改造后的数据结构叫做<strong>跳表</strong>（Skip list）</p>
<h3 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h3><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<img data-src="https://i.loli.net/2021/08/17/xjHD5CGnqP3bKsW.jpg" style="zoom:50%;" />

<p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<strong>索引</strong>或<strong>索引层</strong>。</p>
<img data-src="https://i.loli.net/2021/08/17/BGqbofPdxgiJ3C4.jpg" style="zoom:50%;" />

<p>假如现在要查找结点16，我们可以先在索引层遍历，当遍历到索引值为13时，发现下一结点是17，那要查找的结点16就在这两结点之间。然后我们通过索引层结点的down指针，下降到原始链表层，继续遍历即可。原来需要遍历10个结点，现在只需要7个结点。</p>
<p>从这个例子里，我们看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。</p>
<p>数据量大的话，可以添加多层索引提升效率。<strong>这种链表加多级索引的结构，就是跳表</strong>。</p>
<img data-src="https://i.loli.net/2021/08/08/tKFQ2YcO1dnWS9E.jpg" style="zoom:50%;" />

<h3 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h3><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，**第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 $n/(2k)$**。</p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>
<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点，即 m=3。</p>
<img data-src="https://i.loli.net/2021/08/08/2tfn93XdPqk5oKi.jpg" style="zoom:50%;" />

<h3 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h3><p>跳表就是通过空间换时间的设计思路来实现了和二分查找一样的时间复杂度。根据前面的公式，可以得到跳表的空间复杂度就是$n/2+n/4+n/8…+8+4+2=n-2$​。</p>
<p>如果想要降低索引占用的内存空间，也可以选择三个结点或五个结点抽取一个到上级索引。</p>
<p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了</p>
<h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。因为插入、删除操作的耗时都在查找遍历上，要注意删除时如果结点在索引中也有出现，那要同事删除原始链表和索引的结点</p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<img data-src="https://i.loli.net/2021/08/17/GqCEabQFgxnKP93.jpg" style="zoom:50%;" />

<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<img data-src="https://i.loli.net/2021/08/17/rZVm9lJ1P3Rzd4Q.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序优化</title>
    <url>/archives/7418344d.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/05/5DAt1oVdSKu4Bqr.jpg" style="zoom:50%;" />

<p>如何实现一个通用的、高性能的排序函数？</p>
<span id="more"></span>

<h3 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h3><p>先回顾下前面讲过的几种算法</p>
<img data-src="https://i.loli.net/2021/08/17/6l3qPzWkIYei7bp.jpg" style="zoom:50%;" />

<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p>
<p>堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。一般不适用归并排序的原因是它不是原地排序算法，空间复杂度是$O(n)$。​</p>
<h3 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h3><p>快排在最坏情况下时间复杂度是$O(n^2)$​，主要原因还是因为我们分区点选得不够合理。最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。下面介绍两个常用简单的分区算法。</p>
<ol>
<li><strong>三数取中法</strong></li>
</ol>
<p>区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”</p>
<ol start="2">
<li><strong>随机法</strong></li>
</ol>
<p>每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>
<p>递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p>
<h3 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h3><p>这里拿 Glibc 中的 qsort() 函数举例说明一下</p>
<p>qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。</p>
<p>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。那 qsort() 是如何选择快速排序算法的分区点的呢？如果去看源码，你就会发现，qsort() 选择分区点的方法就是“三数取中法”。</p>
<p>还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的.</p>
<p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</p>
<p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p>
<p>在 qsort() 插入排序的算法实现中，也利用了哨兵这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/archives/89c5f6b.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/fVpL8jIaYTs5yv6.jpg" style="zoom:50%;" />

<p>如何根据年龄给 100 万用户排序？</p>
<span id="more"></span>

<p> 这个问题用归并、快排也能搞定，但时间复杂度最低也是$O(nlongn)$，这次我们学习几种线性排序（Linear sort）：桶排序、计数排序、基数排序，时间复杂度都是$O(n)$。</p>
<h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<img data-src="https://i.loli.net/2021/08/17/6jH2cPAJTQvBYqS.jpg" style="zoom:50%;" />

<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong></p>
<p>当然是否定的。首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p>
<p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<p>举个例子，有10GB的订单数据需要按照订单金额进行排序（假设金额都是正数），但我们内存有限，只有几百MB，无法一次性加载10GB数据。</p>
<p>首先可以扫描一遍文件，看订单金额数据范围，假设扫描后得到金额在1元到10万元间，我们将订单金额划分到100个桶里，第一个桶存储1元到1000元之间的订单，第二桶存储1001元到2000元之间的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p>
<p>理想情况下，订单金额在1元到10万元之间均匀分布， 那订单就会均匀划分到100个文件中，每个小文件存储约100MB数据，再依次对其进行快排排序，等文件都排好序后，再按照文件编号，从小到大依次取出每个文件中的订单数据即可。</p>
<p>不过，你也发现了，订单按照金额不一定是均匀分布的，假如金额在1元到1000元之间的较多，那还可以将这个区间在此划分为跨度为100元的10个小区间，甚至继续划分，直到所有文件可以读入内存为止。</p>
<h3 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h3><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>现在假设所在省有 50 万考生，如何通过成绩快速排序得出名次呢？考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>
<p>这就是计数排序的算法思想，跟桶排序非常类似，只是桶的大小粒度不一样。<strong>不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</strong></p>
<p>要搞明白这个问题，先简化下数据规模，假设只有8个考生，分数在0~5分之间，将其放到一个数组A[8]中：2,5,3,0,2,3,0,3</p>
<p>用C[6]表示桶，遍历考生分数，容易得到：</p>
<img data-src="https://i.loli.net/2021/08/05/kT19nlmAj87CShK.jpg" style="zoom:50%;" />

<p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。</p>
<img data-src="https://i.loli.net/2021/08/05/fn1N4psSJZb3W26.jpg" style="zoom:50%;" />

<p>现在问题是如何快速计算出每个分数的考生在有序数组中对应的存储位置呢？</p>
<p>我们先对C[6]数组顺序求和，C[k]里存储小于等于分数 k 的考生个数。</p>
<img data-src="https://i.loli.net/2021/08/05/DnK3VLPW6ywCQbk.jpg" style="zoom:50%;" />

<p>我们<strong>从后往前</strong>（为了稳定排序）扫描数组A，比如扫描到3，从数组C中取出下标为3的值7，表示分数小于等于3的考生有7个，即3是数组R的第7个元素，取出3放入数组R中，相应的C[3]减1。依次类推，扫描完整个数组A，数组R中的数据就是按照分数大小有序排序了。</p>
<img data-src="https://i.loli.net/2021/08/17/uViQdJvcwxEpasU.jpg" style="zoom:50%;" />

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，利用另一个数组来计数的实习方式就是将其称为计数排序的原因。</p>
<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p>
<p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p>
<h3 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h3><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p>
<p>之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，就可以用上基础排序了。</p>
<p>可以先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。先来看张过程分解图：</p>
<img data-src="https://i.loli.net/2021/08/17/JCgDPliSdn9K5BA.jpg" style="zoom:50%;" />

<p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p>
<p>当要排序的数据不是等长的，比如英文单词，可以把所有的单词补齐到相同长度，位数不够可以在后面补“0”。</p>
<p>总结一下，基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/archives/a444b428.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/iJeg93A6Kup8Vzq.jpg" style="zoom:50%;" />

<p>插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</p>
<span id="more"></span>

<h3 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h3><p><strong>排序算法的执行效率</strong></p>
<ul>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数 、低阶</li>
<li>比较次数和交换（或移动）次数</li>
</ul>
<p><strong>排序算法的内存消耗</strong></p>
<p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p>
<p><strong>排序算法的稳定性</strong></p>
<p><strong>稳定性</strong>这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变 – 稳点排序算法 &amp; 不稳定排序算法</p>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>下面用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样。</p>
<img data-src="https://i.loli.net/2021/08/17/cgnRoLkXQsBrp4a.jpg" style="zoom:50%;" />

<p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p>
<img data-src="https://i.loli.net/2021/08/17/O2KRjEaZXmAlhYI.jpg" style="zoom:50%;" />

<p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p>
<img data-src="https://i.loli.net/2021/08/17/NPkJSEplcDQ7jbo.jpg" style="zoom:50%;" />

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在思考上面说的排序算法的三个方面。</p>
<ol>
<li>冒泡排序是原地排序算法吗？</li>
</ol>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法</p>
<ol start="2">
<li>冒泡排序是稳定的排序算法吗？</li>
</ol>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<ol start="3">
<li>冒泡排序的时间复杂度是多少？</li>
</ol>
<p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。</p>
<p>再来分析下平均情况下的时间复杂度。对于包含n个数据的数组，有n!种排列方式，不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里换一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p>
<p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure>

<img data-src="https://i.loli.net/2021/08/17/VwFJOH4bhkLPpUu.jpg" style="zoom:50%;" />

<p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 $n*(n-1)/2$，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p>
<p>逆序度的定义正好跟有序度相反。关于这三个概念，我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了</p>
<p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 $n*(n-1)/2=15$。</p>
<img data-src="https://i.loli.net/2021/08/04/rSBdM6AUv7FTuxD.jpg" style="zoom:50%;" />

<p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<em><em>逆序度，也就是$n</em>(n-1)/2$初始有序度</em>*。此例中就是 15–3=12，要进行 12 次交换操作。</p>
<p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行$n*(n-1)/2$​次交换。最好情况下，初始状态的有序度是 $n*(n-1)/2$​，就不需要进行交换。我们可以取个中间值 $n*(n-1)/4$，来表示初始有序度既不是很高也不是很低的平均情况。</p>
<p>换句话说，平均情况下，需要 $n*(n-1)/4$​ 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2)$​，所以平均情况下的时间复杂度就是 $O(n^2)$​。</p>
<p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用</p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p>
<img data-src="https://i.loli.net/2021/08/17/xtl2sXg3VwWCmNu.jpg" style="zoom:50%;" />

<p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p>
<img data-src="https://i.loli.net/2021/08/17/gZkxSJaH9fAtRjs.jpg" style="zoom:50%;" />

<p>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p>
<p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p>
<p>为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是$n*(n-1)/2=15$，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。</p>
<img data-src="https://i.loli.net/2021/08/17/pf5bgNZAy7VC1sJ.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序空间复杂度为$O(1)$​，是原地排序算法，也是稳定排序算法。最好时间复杂度是$O(n)$​，最坏是$O(n^2)$​，我们在数组中插入一个数据的平均时间复杂度是$O(n)$，所以插入排序循环n次插入操作的平均时间复杂度就是$O(n^2)$。​</p>
<h3 id="选择排序（Sort）"><a href="#选择排序（Sort）" class="headerlink" title="选择排序（Sort）"></a>选择排序（Sort）</h3><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<img data-src="https://i.loli.net/2021/08/17/Ac1jt2esPpBQYoZ.jpg" style="zoom:50%;" />

<p>选择排序空间复杂度为 $O(1)$，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n2)$。但是，选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<h3 id="为什么插入排序要比冒泡排序更受欢迎呢？"><a href="#为什么插入排序要比冒泡排序更受欢迎呢？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎呢？"></a>为什么插入排序要比冒泡排序更受欢迎呢？</h3><p>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。对于数据规模大的问题，插入排序更有效率。而且插入排序的算法有很大的优化空间，参考[希尔排序](<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序 - 维基百科，自由的百科全书 (wikipedia.org)</a>)。</p>
<img data-src="https://i.loli.net/2021/08/17/tyJarYoQHW8Zfis.jpg" style="zoom:50%;" />

<p>再讲两种时间复杂度为 $O(nlogn)$ 的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序。</p>
<p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<strong>如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</strong></p>
<h3 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h3><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<img data-src="https://i.loli.net/2021/08/17/Tc2pXM8F4oaZV7z.jpg" style="zoom:50%;" />

<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p>
<p>分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p>
<p>归并排序的递推公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r 不用再继续分解</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序算法, A是数组，n表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归终止条件</span><br><span class="line">  if p &gt;&#x3D; r  then return</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取p到r之间的中间位置q</span><br><span class="line">  q &#x3D; (p+r) &#x2F; 2</span><br><span class="line">  &#x2F;&#x2F; 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  &#x2F;&#x2F; 将A[p...q]和A[q+1...r]合并为A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge()函数示意图：</p>
<img data-src="https://i.loli.net/2021/08/17/fr8VXwpbyTHcRB5.jpg" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i :&#x3D; p，j :&#x3D; q+1，k :&#x3D; 0 &#x2F;&#x2F; 初始化变量i, j, k</span><br><span class="line">  var tmp :&#x3D; new array[0...r-p] &#x2F;&#x2F; 申请一个大小跟A[p...r]一样的临时数组</span><br><span class="line">  while i&lt;&#x3D;q AND j&lt;&#x3D;r do &#123;</span><br><span class="line">    if A[i] &lt;&#x3D; A[j] &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[i++] &#x2F;&#x2F; i++等于i:&#x3D;i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start :&#x3D; i，end :&#x3D; q</span><br><span class="line">  if j&lt;&#x3D;r then start :&#x3D; j, end:&#x3D;r</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp</span><br><span class="line">  while start &lt;&#x3D; end do &#123;</span><br><span class="line">    tmp[k++] &#x3D; A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将tmp中的数组拷贝回A[p...r]</span><br><span class="line">  for i:&#x3D;0 to r-p do &#123;</span><br><span class="line">    A[p+i] &#x3D; tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序是稳定排序算法</p>
<p>来分析一下归并排序的时间复杂度，假设对 n 个元素进行归并排序需要的时间是 $T(n)$，那分解成两个子数组排序的时间都是 $T(n/2)$。merge() 函数合并两个有序子数组的时间复杂度是 $O(n)$，归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C;   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n   &#x2F;&#x2F; n&gt;1</span><br><span class="line">     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n</span><br><span class="line">     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n</span><br><span class="line">     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     &#x3D; 2^k * T(n&#x2F;2^k) + k * n</span><br><span class="line">     ......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这样一步一步分解推导，我们可以得到 $T(n) = 2^k*T(n/2^k)+kn$​​。当 $T(n/2^k)=T(1)$ 时，也就是 $n/2^k=1$，我们得到 $k=log_2n$ 。我们将 k 值代入上面的公式，得到 $T(n)=Cn+nlog_2n$ 。如果我们用大 O 标记法来表示的话，$T(n)$ 就等于 $O(nlogn)$​​​​​。</p>
<p>从原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 $O(nlogn)$。</p>
<p>归并排序不是原地排序算法（致命“弱点”）,递归代码的空间复杂度并不能像时间复杂度那样累加，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 $O(n)$。</p>
<h3 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h3><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。再使用递归处理思想，用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1。</p>
<img data-src="https://i.loli.net/2021/08/17/SMWPsEmnFlhdKHt.jpg" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;&#x3D; r then return</span><br><span class="line">  </span><br><span class="line">  q &#x3D; partition(A, p, r) &#x2F;&#x2F; 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和归并排序的merge函数类似，这里也有一个partition分区函数，如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p….r]。</p>
<img data-src="https://i.loli.net/2021/08/17/hpOQUKrdAwDNSBH.jpg" style="zoom:50%;" />

<p>我们希望快排是原地排序算法，有一个巧妙地实现思路：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot :&#x3D; A[r]</span><br><span class="line">  i :&#x3D; p</span><br><span class="line">  for j :&#x3D; p to r-1 do &#123;</span><br><span class="line">    if A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i :&#x3D; i+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  return i</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图示：</p>
<img data-src="https://i.loli.net/2021/08/17/jZzt1Q6qYr2mI9X.jpg" style="zoom:50%;" />

<p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p>
<p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢?</p>
<img data-src="https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg" style="zoom:50%;" />

<p>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 $O(nlogn) $的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题</p>
<p><strong>快速排序的性能分析</strong></p>
<p>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 $O(nlogn)$​；如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 $n$ 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 $n/2$ 个元素，这种情况下，快排的时间复杂度就从 $O(nlogn) $退化成了 $O(n^2)$​​</p>
<p>刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p>
<p>假设每次分区操作都将区间分成大小为 9:1 的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。T(n) = T(n/10) + T(9*n/10) + n； n&gt;1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; T(n&#x2F;10) + T(9*n&#x2F;10) + n； n&gt;1</span><br></pre></td></tr></table></figure>

<p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树。这里直接给你结论：T(n) 在大部分情况下的时间复杂度都可以做到 $O(nlogn)$，只有在极端情况下，才会退化到 $O(n^2)$。而且，我们也有很多方法将这个概率降到很低。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/archives/c6654282.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/VdcAmps3zq26fw4.jpg" style="zoom:50%;" />

<p>现在很多APP都有注册返佣的功能，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p>
<p><strong>那给定一个用户ID，如何查找该用户的“最终推荐人”？</strong></p>
<span id="more"></span>

<h3 id="如何理解递归？"><a href="#如何理解递归？" class="headerlink" title="如何理解递归？"></a>如何理解递归？</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。</p>
<p>举个例子，周末带着女票去看电影，她问你咱们坐在第几排啊？电影院太黑没法数，这会递归法就能上场了，你可以问你前面一排的哥们是第几排，你只要在他的数字上加一就能知道了。但是，前面的人也不清楚，所以他也问前面的人，依次前推，知道第一排的人说了答案，然后再一排排传回数字，最终你就能告诉女票位置了。</p>
<p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n)&#x3D;f(n-1)+1 其中，f(1)&#x3D;1</span><br></pre></td></tr></table></figure>

<p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return f(n-1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归需要满足的三个条件？"><a href="#递归需要满足的三个条件？" class="headerlink" title="递归需要满足的三个条件？"></a>递归需要满足的三个条件？</h3><p>只要问题满足以下三个条件，就可以用递归来解决。</p>
<ol>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ol>
<h3 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h3><p>最关键的就是<strong>写出递推公式，找到终止条件</strong>。</p>
<p>举个例子。假设有n个台阶，每次你可以跨越1个台阶或2个台阶，请问走着n个台阶有多少种走法？如果有7个台阶，可以选择2,2,2,1走上去，也可以选择1,2,1,1,2走上去。</p>
<p>仔细思考，走法可以分为两类，第一步走1个台阶，以及第一步走2个台阶。n个台阶的走法就等于先走1阶后，n-1的走法，加上先走2阶后，n-2个台阶的走法，公式表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure>

<p>有了递推公式，再来考虑终止条件。当只有一个台阶时，不需要递归，只有一种走法。所以$f(1)=1$​​。这个条件够了吗？我们可以用$n=2，n=3$靠近临界点的数试验。</p>
<p>$n=2$​时，$f(2)=f(1)+f(0)$。如果终止条件只有$f(1)=1$​，那f(2)​就无法求解了，还需要满足$f(0)=1$，表示走0个台阶有一种走法，但这不符合逻辑。所以，还要把$f(2)=2$​也作为一种终止条件，表示走2个台阶有两种走法，一次走完或两次一步。</p>
<p>最后得到，递归终止条件就是$f(1)=1，f(2)=2$，当然，可以也应该再拿n=3，n=4来验证是否正确。得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(<span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">f(n) = f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>转成递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，写递归代码的关键就是<strong>找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong>。</p>
<p>前面电影院的例子比较简单，递归只调用一个分支，但实际问题往往更为复杂，需要分解为多个子问题。</p>
<p>人脑是有限的，更倾向于平铺直叙的思维方式，不要试图想清楚递和归的过程，这就进入了一个思维误区，重复的事让计算机来完成。</p>
<p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p>
<p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p>
<h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p><strong>那么，如何避免出现堆栈溢出呢？</strong></p>
<p>可以通过在代码中限制调用递归的最大深度的方法来解决，递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度。</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ++depth；</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p>
<h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h3><p>除此之外，使用递归时还会出现重复计算的问题。刚才第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的:</p>
<img data-src="https://i.loli.net/2021/08/17/KcLTQAmVSOGhWaj.jpg" style="zoom:50%;" />

<p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>
<p>改造代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这两个常见问题，递归还有很多其他问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p>
<h3 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h3><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p>
<p>电影院的例子，抛开场景，只看f(n)=f(n-1)+1这个递推公式，可以改写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = ret + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子也可以改写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，所有的递归代码都可以改为这种迭代循环的非递归写法，因为递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h3 id="调试递归"><a href="#调试递归" class="headerlink" title="调试递归"></a>调试递归</h3><ol>
<li>打印日志发现，递归值。</li>
<li>结合条件断点进行调试。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/archives/b6c47025.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/03/jAIGtd1VcyDXRLP.jpg" style="zoom:50%;" />

<p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p>
<span id="more"></span>

<h3 id="如何理解队列？"><a href="#如何理解队列？" class="headerlink" title="如何理解队列？"></a>如何理解队列？</h3><p><strong>先进先出者，就是典型的“队列”</strong></p>
<p>队列和栈十分相似，基本操作也是两个：**入队 enqueue()<strong>，放一个数据到队列尾部；</strong>出队 dequeue()**，从队列头部取一个元素</p>
<img data-src="https://i.loli.net/2021/08/17/J7Z5h34Yt8W2MXw.jpg" style="zoom:50%;" />

<p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p>
<p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p>
<h3 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h3><p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
<p>对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p>
<p>你可以结合下面这张图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p>
<img data-src="https://i.loli.net/2021/08/17/xmNQEBogrnG64hX.jpg" style="zoom:50%;" />

<p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p>
<img data-src="https://i.loli.net/2021/08/17/TEbdjKAhzRM2otr.jpg" style="zoom:50%;" />

<p>当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p>
<img data-src="https://i.loli.net/2021/08/03/wB1kazey4TXJsli.jpg" style="zoom:50%;" />

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面用数组实现队列时，当 tail == n，会有数据搬移操作，循环队列就能解决这个问题</p>
<img data-src="https://i.loli.net/2021/08/03/ulLfAPcW8H29kDx.jpg" style="zoom:50%;" />

<p>要想写出没有 bug 的循环队列的实现代码，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p>
<p>队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。</p>
<img data-src="https://i.loli.net/2021/08/17/iUzB8e5HanR6xpD.jpg" style="zoom:50%;" />

<p>就像图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。</p>
<h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<img data-src="https://i.loli.net/2021/08/17/YNc2VTa4zRjBI7e.jpg" style="zoom:50%;" />

<p>上述的定义其实就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p>
<p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p>
<p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p>
<img data-src="https://i.loli.net/2021/08/17/6rcIPkt9WKdDO1F.jpg" style="zoom:50%;" />

<p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/archives/1f4ac2fb.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/c7CFMPLGHKIS12r.jpg" style="zoom:50%;" />

<p>后进者先出，先进者后出，这就是典型的“栈”结构。</p>
<span id="more"></span>

<h3 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h3><img data-src="https://i.loli.net/2021/08/17/psIU7Lv3A8jXtgm.jpg" style="zoom:50%;" />

<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p>
<p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p>
<p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。</p>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Stack based upon linked list</span></span><br><span class="line"><span class="string">    基于链表实现的栈(Python) - linked_stack.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data: <span class="built_in">int</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line">        self._next = <span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A stack based upon singly-linked list.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._top: Node = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span></span><br><span class="line">        new_top = Node(value)</span><br><span class="line">        new_top._next = self._top</span><br><span class="line">        self._top = new_top</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; Optional[int]:</span></span><br><span class="line">        <span class="keyword">if</span> self._top:</span><br><span class="line">            value = self._top._data</span><br><span class="line">            self._top = self._top._next</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        current = self._top</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            nums.append(current._data)</span><br><span class="line">            current = current._next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span>]&quot;</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    stack = LinkedStack()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        stack.push(i)</span><br><span class="line">    print(stack)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        stack.pop()</span><br><span class="line">    print(stack)</span><br></pre></td></tr></table></figure>



<p>时间复杂度和空间复杂度均为 O(1)。</p>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p><strong>函数调用栈</strong>：操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<p><strong>表达式求值</strong>：为方便解释，将算术表达式简化为只包含加减乘除四则运算。</p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p>下面将 3+5*8-6 这个表达式的计算过程画成了一张图，结合图来理解刚讲的计算过程。</p>
<img data-src="https://i.loli.net/2021/08/17/IZquxRpiWfKBVN8.jpg" style="zoom:50%;" />

<p><strong>括号匹配</strong>：我们可以借助栈来检查表达式中的括号是否匹配。假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。</p>
<p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<h3 id="如何实习浏览器的前进、后退功能？"><a href="#如何实习浏览器的前进、后退功能？" class="headerlink" title="如何实习浏览器的前进、后退功能？"></a>如何实习浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 引用当前文件夹下的single_linked_list</span></span><br><span class="line">sys.path.append(<span class="string">&#x27;linked_stack.py&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> linked_stack <span class="keyword">import</span> LinkedStack</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewLinkedStack</span>(<span class="params">LinkedStack</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._top</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.forward_stack = NewLinkedStack()</span><br><span class="line">        self.back_stack = NewLinkedStack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Open new url %s&quot;</span> % url, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        self.forward_stack.push(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        top = self.forward_stack.pop()</span><br><span class="line">        self.back_stack.push(top)</span><br><span class="line">        print(<span class="string">&quot;back to %s&quot;</span> % top, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        top = self.back_stack.pop()</span><br><span class="line">        self.forward_stack.push(top)</span><br><span class="line">        print(<span class="string">&quot;forward to %s&quot;</span> % top, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    browser = Browser()</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> browser.can_back():</span><br><span class="line">        browser.back()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> browser.can_forward():</span><br><span class="line">        browser.forward()</span><br><span class="line"></span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br></pre></td></tr></table></figure>





<h3 id="为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"><a href="#为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？" class="headerlink" title="为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"></a>为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</h3><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p>
<p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
<h3 id="JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？"><a href="#JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？" class="headerlink" title="JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？"></a>JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？</h3><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/archives/2362a8ea.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/07/29/Y576HhpLyZSwtdR.jpg" style="zoom:50%;" />

<p>链表（Linked list）有一个经典应用场景：<strong>LRU缓存淘汰算法</strong>。</p>
<span id="more"></span>

<p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p>
<h3 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h3><p>链表，是通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，常见的有三种链表结构：单链表、双向链表和循环链表。</p>
<img data-src="https://i.loli.net/2021/07/29/HniWdagVZIUA9MS.jpg" style="zoom:50%;" />

<p>先来看<strong>单链表</strong>，所谓的内存块我们称为<strong>“结点”</strong>，为了将结点串起来，每个链表结点除了存储数据外，还要记录下一个结点地址，我们这个记录指针叫做<strong>后继指针next</strong></p>
<img data-src="https://i.loli.net/2021/07/29/z3OrpVFKA98bLxW.jpg" style="zoom:50%;" />

<p>我们习惯性把第一个结点叫做<strong>头结点</strong>，记录链表的基地址，最后一个结点叫做尾结点，指向一个<strong>空地址NULL</strong> 。</p>
<p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。</p>
<img data-src="https://i.loli.net/2021/07/29/7Z5nfTOEFGueJbv.jpg" style="zoom:50%;" />

<p>有利就有弊，链表的随机访问效率教数组差，因为需要一个结点一个结点依次遍历，需要 O(n)的时间复杂度。</p>
<p><strong>循环链表</strong>是一种特殊的单链表，区别在于尾结点是指向链表的头结点。</p>
<img data-src="https://i.loli.net/2021/07/29/QYUpe2c1oOZSVGt.jpg" style="zoom:50%;" />

<p>在实际软件开发中，更加常用的链表结构是另外一种：<strong>双向链表</strong>。它需要额外的两个空间来存储后继结点和前驱结点的地址，占用更多内存空间，但可以支持双向遍历，以此换来操作的灵活性。</p>
<img data-src="https://i.loli.net/2021/07/29/n3ZDTsVouNEgGvl.jpg" style="zoom:50%;" />

<p>要明白双向链表的高效性体现在哪里，我们可以看一下<strong>删除操作</strong>。</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点；</li>
<li>删除给定指针指向的结点。</li>
</ul>
<p>第一种情况，单链表和双向链表都需要遍历查找值而后进行删除，仅删除操作复杂度为 O(1)，但遍历查找是主要耗时步骤，复杂度为 O(n)。</p>
<p>第二种情况，已经明确要删除的结点，而单链表不支持获取前驱结点，仍需要从头遍历，直到 <code>p-&gt;next=q</code>,说明 p 是 q 的前驱结点。双向链表就可以在 O(1) 复杂度内完成，插入、查询操作同理分析。</p>
<p>在java语言中，LingedHashMap容器就是使用了双向链表结构。</p>
<p>一个很重要的知识点，<strong>用空间换时间</strong>的设计思想在实际开发中应用广泛。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p>
<p>将循环链表和双向链表整合到一起，就是一个新的版本：<strong>双向循环链表</strong></p>
<img data-src="https://i.loli.net/2021/07/29/wZFghGe3OvS8iPs.jpg" style="zoom:50%;" />

<h3 id="链表-VS-数组性能对比"><a href="#链表-VS-数组性能对比" class="headerlink" title="链表 VS 数组性能对比"></a>链表 VS 数组性能对比</h3><img data-src="https://i.loli.net/2021/07/29/Iizay4gULP2dmKR.jpg" style="zoom:50%;" />

<p>不过，实际软件开发中，不能仅用复杂度分析就决定使用那个数据结构。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，对CPU缓存不友好，没法有效预读。</p>
<p>数组缺点是大小固定，一经声明就要占用连续内存空间，如果数组过小，就要重新申请一个更大的空间，将原数组拷贝进去，非常费时。链表本身没有大小限制，天然支持动态扩容，这也是它与数组最大区别。</p>
<h3 id="如何实现LRU缓存淘汰算法"><a href="#如何实现LRU缓存淘汰算法" class="headerlink" title="如何实现LRU缓存淘汰算法?"></a>如何实现LRU缓存淘汰算法?</h3><p>通过哈希表辅以双向链表实现</p>
<ul>
<li>双向链表按照使用顺序存储键值对，越靠近头部是最近使用的，靠近尾部则是最久未使用的</li>
<li>哈希表通过缓存数据的键映射到双向链表中的结点位置</li>
</ul>
<p>如此便可使用哈希表定位，找出缓存项在双向链表中位置，再将其移到头部即可在 O(1) 时间内完成 get 或者 put 操作</p>
<ul>
<li>get 操作，首先判断 key 是否存在<ul>
<li>如果 key 存在，返回 -1</li>
<li>如果 key 存在，通过 hash 表定位后将结点移到头部位置，返回结点值</li>
</ul>
</li>
<li>put 操作，首先判断 key 是否存在<ul>
<li>如果key 存在，更新结点值，将其移动到头部</li>
<li>如果key 不存在，使用 key 和 value 创建一个新结点，在链表头部添加盖结点，并将key 和结点添加到哈希表中。然后判断双向链表结点数是否超出容量，是则删除尾结点，并删除哈希表中对应项 </li>
</ul>
</li>
</ul>
<p>Tips：在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p>
<hr>
<img data-src="https://i.loli.net/2021/07/29/JCDU5BngouvNVYh.jpg" style="zoom:50%;" />

<h3 id="如何轻松写出正确的链表代码？"><a href="#如何轻松写出正确的链表代码？" class="headerlink" title="如何轻松写出正确的链表代码？"></a>如何轻松写出正确的链表代码？</h3><p><strong>理解指针或引用的含义</strong></p>
<p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<p><strong>警惕指针丢失和内存泄漏</strong></p>
<p>看下面代码，现在需要在结点 a 和相邻的结点 b 之间插入结点 x，假设当前 p 指向结点 a，下面写法就会发生指针丢失和内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;next &#x3D; x;  &#x2F;&#x2F; 将p的next指针指向x结点；</span><br><span class="line">x-&gt;next &#x3D; p-&gt;next;  &#x2F;&#x2F; 将x的结点的next指针指向b结点；</span><br></pre></td></tr></table></figure>

<p>p-&gt;next 指针在完成第一步后已经不再指向结点 b 而是结点 a，第二行代码相当于将 x 赋值给 x-&gt;next。</p>
<p>插入结点时，一定要注意操作顺序，同理，删除结点时，也一定要记得手动释放内存空间。</p>
<ul>
<li>利用哨兵简化实现难度</li>
</ul>
<p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。引入哨兵结点后不管链表是否为空，head指针都会指向这个哨兵结点，我们把这种链表叫<strong>带头链表</strong>，没有哨兵结点的链表就叫做<strong>不带头链表</strong>。如此便可统一相同的代码实现逻辑。</p>
<img data-src="https://i.loli.net/2021/08/17/NdDxtkZ9u2HfyCl.jpg" style="zoom:50%;" />

<p>哨兵是用来解决边界问题的，可以理解为它可以减少特殊情况的判断，比如判空、越界等，增加效率。</p>
<p>代码一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 边界条件处理，如果a为空，或者n&lt;=0，说明数组中没有数据，就不用while循环比较了</span></span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里有两个比较操作：i&lt;n和a[i]==key.</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="comment">// 我举2个例子，你可以拿例子走一下代码</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 7</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 6</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span></span><br><span class="line">  <span class="keyword">if</span> (a[n<span class="number">-1</span>] == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。</span></span><br><span class="line">  <span class="comment">// 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span></span><br><span class="line">  <span class="keyword">char</span> tmp = a[n<span class="number">-1</span>];</span><br><span class="line">  <span class="comment">// 把key的值放到a[n-1]中，此时a = &#123;4, 2, 3, 5, 9, 7&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = key;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// while 循环比起代码一，少了i&lt;n这个比较操作</span></span><br><span class="line">  <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复a[n-1]原来的值,此时a= &#123;4, 2, 3, 5, 9, 6&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = tmp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (i == n<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，返回i，就是等于key值的元素的下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p>
<p><strong>重点留意边界条件处理</strong></p>
<ul>
<li><p>如果链表为空时，代码是否能正常工作？</p>
</li>
<li><p>如果链表只包含一个结点时，代码是否能正常工作？</p>
</li>
<li><p>如果链表只包含两个结点时，代码是否能正常工作？</p>
</li>
<li><p>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</p>
</li>
</ul>
<p><strong>举例画图，辅助思考</strong></p>
<p>找个具体例子，释放脑容量，进行更多的逻辑思考，有助于思路清晰。比如往单链表中插入一个数据，如图所示：</p>
<img data-src="https://i.loli.net/2021/08/17/u1SUf6shp8JoF3O.jpg" style="zoom:50%;" />

<p><strong>多写多练，没有捷径</strong></p>
<p>5个常见的链表操作：</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测 </li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第 n 个结点</li>
<li>求链表的中间结点</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/archives/6096f3d5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/archives/340249a9.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/07/28/OoNQVyXiz58dxjb.jpg" style="zoom: 50%;" />

<p>数组，不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构</p>
<span id="more"></span>

<p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<img data-src="https://i.loli.net/2021/08/17/t4qp6ylwrWk7bY3.jpg" style="zoom:50%;" />

<p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<img data-src="https://i.loli.net/2021/08/17/hHwBdIPnLC2z8K7.jpg" style="zoom:50%;" />

<p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<h3 id="数组是如何实现根据下标随机访问数组元素的？"><a href="#数组是如何实现根据下标随机访问数组元素的？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的？"></a>数组是如何实现根据下标随机访问数组元素的？</h3><p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p>
<img data-src="https://i.loli.net/2021/08/17/nAQj6iLWDYCTOrv.jpg" style="zoom:50%;" />

<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>其中 data_type_size 表示数组中每个元素的大小.。</p>
<p>数组适合查找操作，支持随机访问，<strong>根据下标随机访问</strong>的时间复杂度为 O(1)</p>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>先看<strong>插入操作</strong>，假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？</p>
<p>最好时间复杂度是 O(1)，最坏时间复杂度是 O(n)，平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p>
<p>而如果数组中存储的数据没有规律，只是当做存储集合，为避免大规模数据迁移，还有个办法就是直接将第 k 位的数据移到数组最后，新元素放到 k 位置。</p>
<p>再看<strong>删除操作</strong>，复杂度分析过程类似，结果是一样的。</p>
<p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p>
<p>我们再看个例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>
<img data-src="https://i.loli.net/2021/08/17/fXTq6t7gPMHuAcF.jpg" style="zoom:50%;" />

<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<p>其实这也就是 JVM 标记清除垃圾回收算法的核心思想。数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p>
<p><strong>JVM标记清除垃圾回收算法</strong></p>
<blockquote>
<p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC（Garbage Collection， 垃圾回收）ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。<br>不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片</p>
</blockquote>
<h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h3><p>现在聊聊数据访问越界的问题，先分析以下这段 C 语言代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int arr[3] &#x3D; &#123;0&#125;;</span><br><span class="line">    for(; i&lt;&#x3D;3; i++)&#123;</span><br><span class="line">        arr[i] &#x3D; 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果并非是三行“hello world”，而是会无限打印（不同编辑器表现可能会不一样）</p>
<p>编译器按照内存地址<strong>递减</strong>的方式给变量分配内存</p>
<h3 id="为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？"><a href="#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？" class="headerlink" title="为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</h3><p>根据寻址公式，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure>

<p>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
<p>不过最主要的原因可能是历史原因。C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法学习路线</title>
    <url>/archives/c754dd43.html</url>
    <content><![CDATA[<h3 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h3><img data-src="https://i.loli.net/2021/07/27/W2Ds79noOQjvH43.png" alt="数据结构与算法学习路线"  />



<h3 id="学习书单"><a href="#学习书单" class="headerlink" title="学习书单"></a>学习书单</h3><img data-src="https://i.loli.net/2021/07/27/ZIaeVGOrXckR3uY.png" alt="数据结构与算法学习书单"  />



<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><img data-src="https://i.loli.net/2021/07/27/INry6zw7fdFkHPo.png" alt="数据结构与算法知识点" style="zoom:67%;" />



<hr>
<p>没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</p>
<img data-src="https://i.loli.net/2021/07/27/jGrCabD9t4FOlms.jpg" style="zoom:50%;" />

<p>不要浮躁，不要丧失思考能力，不要丧失学习能力</p>
<img data-src="https://i.loli.net/2021/07/27/3fh5uHRktqopaez.jpg" style="zoom:50%;" />

<p>只有做好打硬仗的心理准备，遇到困难才能心态平和</p>
<img data-src="https://static001.geekbang.org/resource/image/d3/42/d3c715012b855aaca2b186b5cf862642.jpg" style="zoom:50%;" />

<p>“放弃”的念头像是一个心魔，它会一直围绕着你</p>
<img data-src="https://static001.geekbang.org/resource/image/61/f4/6118ba4f07e5c1f8f1a7a0a18ba6f7f4.jpg" style="zoom:50%;" />

<p>入门是一个非常漫长和煎熬的过程，谁都逃不过</p>
<img data-src="https://i.loli.net/2021/07/27/uv6eYGlFdi87PWS.jpg" style="zoom:50%;" />

<p>情商比智商更重要。对于很多学科的学习，智商并不是瓶颈，最终能够决定你能达到的高度的，还是情商，而情商中最重要的，我觉得就是逆商（逆境商数，Adversity Quotient），也就是，当你遇到困难时，你会如何去面对，这将会决定你的人生最终能够走多远。</p>
<img data-src="https://i.loli.net/2021/07/27/ZFXGd6r1wyD249N.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/archives/aaaaf04a.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/5ukKbHUPmwVdvgt.jpg" style="zoom: 50%;" />

<p><strong>如何分析、统计算法的执行效率和资源消耗？</strong></p>
<p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p>
<span id="more"></span>

<h3 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h3><p>平时跑代码通过统计、监控来得到算法执行的时间和占用的内存大小的统计方法有很大的局限性（也称为<strong>事后统计法</strong>）</p>
<p><strong>1. 测试结果非常依赖测试环境</strong></p>
<p>测试环境中硬件的不同会对测试结果有很大的影响</p>
<p><strong>2. 测试结果受数据规模的影响很大</strong></p>
<p>对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性</p>
<p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>，也就是本文所要讲述的时间、空间复杂度分析方法。</p>
<h3 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h3><img data-src="https://i.loli.net/2021/07/27/q6WUtBvMd9ZD4O5.png" style="zoom:50%;" />

<p>T(n) 表示代码执行的时间，n 表示数据规模的大小，f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p><strong>大 O 时间复杂度</strong>实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p><strong>1.只关注循环执行次数最多的一段代码</strong></p>
<p>核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度</p>
<p><strong>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
<p><strong>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p>
<p>T(n) = T1(n) * T2(n) = O(n*n) = O(n2)</p>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><img data-src="https://i.loli.net/2021/07/27/jRgEOxP7C6Lst5k.png" style="zoom: 50%;" />

<p>对于罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度在此不展开讲。我们主要来看几种常见的<strong>多项式时间复杂度</strong>。</p>
<p><strong>1. O(1)</strong></p>
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码</p>
<p><strong>2. O(logn)、O(nlogn)</strong></p>
<p>通过一个例子说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123; </span><br><span class="line">	i = i * <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p>
<img data-src="https://i.loli.net/2021/07/27/qab9dmInWu67GDQ.jpg" style="zoom:50%;" />

<p>$x=log_2n$，所以，这段代码的时间复杂度就是 $O(log_2n)$。</p>
<p>而对数之间是可以互相转换的，$log_3n$就等于$ log_32 * log_2n$，所以 $O(log_3n) = O(C * log2n)$，其中$ C=log_32$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $O(Cf(n)) = O(f(n))$。所以，$O(log_2n)$ 就等于 $O(log_3n)$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为$ O(logn)$。</p>
<p><strong>3. (m+n)、O(m*n)</strong></p>
<p>代码的复杂度由两个数据的规模来决定</p>
<p>加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))</p>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p><strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong></p>
<p>和时间复杂度分析一样。常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时用不到。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低</p>
<img data-src="https://i.loli.net/2021/07/27/tiReMnHlyrqVUDY.png" style="zoom: 50%;" />



<hr>
<img data-src="https://i.loli.net/2021/08/17/UKy5b2THVPStiaG.jpg" style="zoom:50%;" />

<p><strong>浅析最好、最坏、平均、均摊时间复杂度</strong></p>
<p>同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的由此区分出四个复杂度方面的分析，<strong>最好情况时间复杂度</strong>（best case time complexity）、<strong>最坏情况时间复杂度</strong>（worst case time complexity）、<strong>平均情况时间复杂度</strong>（average case time complexity）、<strong>均摊时间复杂度</strong>（amortized time complexity）</p>
<p>先看一个例子，在一个无序的数组（array）中，查找变量 x 出现的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123; </span><br><span class="line">	int i &#x3D; 0; </span><br><span class="line">	int pos &#x3D; -1; </span><br><span class="line">	for (; i &lt; n; ++i) &#123; </span><br><span class="line">		if (array[i] &#x3D;&#x3D; x) &#123; </span><br><span class="line">			pos &#x3D; i; break; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h3><p>在最理想的情况下，执行这段代码的时间复杂度，即 O(1)</p>
<h3 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h3><p>在最糟糕的情况下，执行这段代码的时间复杂度，即 O(n)</p>
<h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>在上面这个例子中，查找变量 x 在数组中位置，有 n+1 种情况：<strong>在数组的 0~n-1 位置中</strong>和<strong>不在数组#中</strong>，同时，还要考虑每种情况发生的概率，最终计算过程为：</p>
<img data-src="https://i.loli.net/2021/08/17/tqSKWINGvD2PTUa.jpg" style="zoom: 50%;" />

<p>这个值在概率论中称为<strong>加权平均值</strong>，也叫做期望值，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者期望时间复杂度。用大 O 表示法来表示，去掉系数和常量，加权平均时间复杂度仍然是 O(n)。</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>首先，均摊时间复杂度就是一种特殊的平均时间复杂度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; array表示一个长度为n的数组</span><br><span class="line">&#x2F;&#x2F; 代码中的array.length就等于n</span><br><span class="line">int[] array &#x3D; new int[n];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count &#x3D;&#x3D; array.length) &#123;</span><br><span class="line">      int sum &#x3D; 0;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum &#x3D; sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] &#x3D; sum;</span><br><span class="line">      count &#x3D; 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] &#x3D; val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例中平均时间复杂度为：</p>
<img data-src="https://i.loli.net/2021/08/17/L8DvC2AhO3PwMTj.jpg" style="zoom:50%;" />

<p>这里引入<strong>摊还分析法</strong>，每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路，得到的就是均摊时间复杂度。</p>
<p>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel 使用技巧</title>
    <url>/archives/740b22a4.html</url>
    <content><![CDATA[<h3 id="源数据表"><a href="#源数据表" class="headerlink" title="源数据表"></a>源数据表</h3><ul>
<li>一维数据</li>
<li>一个标题行</li>
<li>字段分类清晰</li>
<li>数据属性完整</li>
<li>数据连续</li>
<li>无合并单元格</li>
<li>无合计行</li>
<li>无分隔行 / 列</li>
<li>数据区域中无空白单元格</li>
<li>单元格内容禁用短语或句子</li>
</ul>
<span id="more"></span>

<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="移动行列位置"><a href="#移动行列位置" class="headerlink" title="移动行列位置"></a>移动行列位置</h4><ul>
<li>选中行或列后，按 Shift 拖动到指定行列位置</li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>Ctrl + Enter  批量修改单元格</li>
<li>Ctrl + ;  当前日期</li>
<li>Ctrl + Shift + ;  当前时间 16:10</li>
<li>Alt + =  自动求和</li>
<li>Ctrl + A   输入函数名称后，调出函数面板</li>
<li>Shift + F3  插入函数</li>
<li>F2  使单元格进入编辑状态</li>
<li>F4  使单元格引用在相对、绝对、混合引用中循环切换</li>
<li>F9  是Excel进行一次计算，对象可以是引用数据区域，函数或公式</li>
<li>Ctrl + `  公式单元格从显示结果切换到显示公式</li>
</ul>
<h4 id="批量取消合并单元格"><a href="#批量取消合并单元格" class="headerlink" title="批量取消合并单元格"></a>批量取消合并单元格</h4><ul>
<li>选中数据点击取消合并单元格</li>
<li>F5定位空值数据</li>
<li>输入公式 “=B2”（当前单元格上一格坐标）</li>
<li>Ctrl + Enter 批量录入 </li>
</ul>
<h4 id="“切”和“拼”"><a href="#“切”和“拼”" class="headerlink" title="“切”和“拼”"></a>“切”和“拼”</h4><ul>
<li>切：数据 &gt; 分列</li>
<li>拼：=B2&amp;C2</li>
</ul>
<h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><ul>
<li>=A2=TODAY()</li>
</ul>
<blockquote>
<p>确保当天录入数据，结合保护工作表可防止修改（exc. 修改计算机日期可以达目的）</p>
</blockquote>
<ul>
<li>=LEN(A1)&lt;&gt;0</li>
</ul>
<blockquote>
<p>但A1单元格有数据时才允许录入，确保数据按序录入</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="VLOOKUP"><a href="#VLOOKUP" class="headerlink" title="VLOOKUP"></a>VLOOKUP</h4><p> VLOOKUP (要查找的项、要查找位置、包含要返回的值的单元格区域中的列号、返回近似或精确匹配 - 指示为 1/TRUE 或 0/FALSE)  </p>
<ul>
<li>普通查找</li>
</ul>
<blockquote>
<p>=VLOOKUP(E2,$B$1:$C$15,2,0) </p>
</blockquote>
<ul>
<li>屏蔽错误值查找</li>
</ul>
<blockquote>
<p>=IFERROR(VLOOKUP(E2,$A$1:$C$15,3,0),”查找不到”) </p>
</blockquote>
<ul>
<li>逆向查找</li>
</ul>
<blockquote>
<p>=VLOOKUP(E2,IF({1,0},$B$2:$B$15,$A$2:$A$15),2,0)<br>IF{1,0}，就是把1对应的范围和0对应的范围组合成新的区域。 </p>
</blockquote>
<ul>
<li>按顺序返回多列值内容</li>
</ul>
<blockquote>
<p>=VLOOKUP($E2,$A$1:$C$15,COLUMN(B1),0) </p>
</blockquote>
<ul>
<li>多条件查询</li>
</ul>
<blockquote>
<p>=VLOOKUP(E2&amp;F2,IF({1,0},$A$2:$A$15&amp;$B$2:$B$15,$C$2:$C$15),2,0)<br>此处的IF{1,0}的用法是把A2:A15及B2:B5的区域合并成一个区域使用 </p>
</blockquote>
<ul>
<li>一对多查询</li>
</ul>
<blockquote>
<p>查询一个部门对应所有人员数<br>首先添加辅助列， =B2&amp;COUNTIF($B$2:B2,B2) ，确保用 VLOOKUP 函数查找值是唯一的=IFERROR(VLOOKUP($G$2&amp;ROW(A1),$A$1:$C$27,3,0),””) </p>
</blockquote>
<ul>
<li>VLOOKUP + Match</li>
</ul>
<blockquote>
<p>MATCH(查找的值，查找的区域，0为精确匹配)，实现的结果是返回查找值在查找区域的第几行第几列<br>=VLOOKUP(A20,$A$2:$M$16,MATCH(B20,$A$2:$M$2,0),0) </p>
</blockquote>
<ul>
<li>VLOOKUP + 通配符查找</li>
</ul>
<blockquote>
<p>=VLOOKUP(“<em>“&amp;C2&amp;”</em>“,$A$1:$A$6,1,0) </p>
</blockquote>
<h4 id="MATCH"><a href="#MATCH" class="headerlink" title="MATCH"></a>MATCH</h4><p> MATCH（lookup_value,lookuparray,match-type） </p>
<blockquote>
<p>match-type： 1或省略，查找小于或等于指定内容最大值，数据必须升序排列；0，查找等于指定内容的第一个值；-1或省略，查找大于或等于指定内容最大值，数据必须降序排列</p>
</blockquote>
<h4 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h4><p>row(reference) </p>
<blockquote>
<p>返回 reference 行数， 若无参数，则返回当前行数</p>
</blockquote>
<h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p>MOD(number, divisor) </p>
<blockquote>
<p>求余数</p>
</blockquote>
<h4 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h4><p>INDEX(array, row_num, [column_num])</p>
<blockquote>
<p>返回由行号和列号索引选中的表或数组中元素的值 </p>
</blockquote>
<h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><p> RANK(number,ref,[order]) </p>
<blockquote>
<p> 返回一列数字的数字排位 </p>
</blockquote>
]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 批量重命名文件</title>
    <url>/archives/e6a92538.html</url>
    <content><![CDATA[<p>使用 python 遍历文件目录，批量重命名文件，已支持功能包括</p>
<ul>
<li>添加前后缀，支持默认序列（输入 seq ）和自定义</li>
<li>选择文件类型</li>
<li>选择是否遍历子目录</li>
<li>选择是否保留原文件名（python读取文件名顺序与文件管理器不同）</li>
<li>如果已存在序列，可使用正则替换序列格式</li>
</ul>
<p><img data-src="https://i.loli.net/2021/06/07/s6bzIfUTL7S5N4r.png"></p>
<span id="more"></span>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prompt_info</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Prefix/Suffix: When &quot;seq&quot; is input, the auto-increasing sequence is output;</span></span><br><span class="line"><span class="string">        Use spaces to distinguish the file type you entered;</span></span><br><span class="line"><span class="string">        Replace existing sequence by regular</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_boolean</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;y&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> s == <span class="string">&#x27;n&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># return get_boolean(input(&#x27;Please enter y(yes) or n(no): &#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_re</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenameFiles</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for RenameFiles&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RenameFiles, self).__init__()</span><br><span class="line"></span><br><span class="line">        prompt_info()</span><br><span class="line"></span><br><span class="line">        self.desPath = <span class="string">&#x27;C:\\Users\\MSI-PC\\Desktop\\desktop-pet\\images\\meizi&#x27;</span></span><br><span class="line">        self.oriPath = <span class="string">&#x27;C:\\Users\\MSI-PC\\Desktop\\desktop-pet\\images\\meizi&#x27;</span></span><br><span class="line">        <span class="comment"># 文件前缀</span></span><br><span class="line">        self.prefix = <span class="built_in">input</span>(<span class="string">&#x27;Please enter the file name prefix: &#x27;</span>)</span><br><span class="line">        <span class="comment"># 文件后缀</span></span><br><span class="line">        self.suffix = <span class="built_in">input</span>(<span class="string">&#x27;Please enter the file name suffix: &#x27;</span>)</span><br><span class="line">        <span class="comment"># 是否保留原文件名</span></span><br><span class="line">        self.is_keep = get_boolean(<span class="built_in">input</span>(<span class="string">&#x27;whether to keep the original file name(y/n: &#x27;</span>))</span><br><span class="line">        <span class="comment"># 使用正则替换已存在序列</span></span><br><span class="line">        self.pattern = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter the re pattern: &#x27;</span>))</span><br><span class="line">        <span class="comment"># 文件类型</span></span><br><span class="line">        self.file_type = <span class="built_in">list</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter the file type(separated by spaces): &#x27;</span>).split())</span><br><span class="line">        <span class="keyword">if</span> self.file_type <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.file_type == []:  <span class="comment"># 默认全部类型</span></span><br><span class="line">            self.file_type = [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">        print(<span class="string">&#x27;pattern: &#x27;</span>, self.pattern, <span class="string">&#x27;file_type: &#x27;</span>, self.file_type)</span><br><span class="line">        <span class="comment"># 是否遍历子目录</span></span><br><span class="line">        self.sub_dir = get_boolean(<span class="built_in">input</span>(<span class="string">&#x27;Whether to traverse subdirectories(y/n): &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Modify file names in batches</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, names <span class="keyword">in</span> os.walk(self.oriPath):</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">                file_name = os.path.splitext(name)[<span class="number">0</span>]</span><br><span class="line">                ext = os.path.splitext(name)[<span class="number">1</span>]</span><br><span class="line">                ori_path = os.path.join(root, name)</span><br><span class="line">                <span class="keyword">if</span> self.file_type <span class="keyword">and</span> (<span class="string">&#x27;*&#x27;</span> <span class="keyword">in</span> self.file_type <span class="keyword">or</span> ext[<span class="number">1</span>:] <span class="keyword">in</span> self.file_type):</span><br><span class="line">                    <span class="comment"># 目标命名</span></span><br><span class="line">                    des_name = (self.prefix <span class="keyword">if</span> self.prefix != <span class="string">&#x27;seq&#x27;</span> <span class="keyword">else</span> <span class="built_in">str</span>(count + <span class="number">1</span>) + <span class="string">&#x27;_&#x27;</span>) + (</span><br><span class="line">                        re.sub(self.pattern, <span class="keyword">lambda</span> x: re.findall(<span class="string">r&#x27;\d+&#x27;</span>, x.group(<span class="number">0</span>))[<span class="number">0</span>],</span><br><span class="line">                               file_name) <span class="keyword">if</span> self.is_keep <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + (</span><br><span class="line">                                   self.suffix <span class="keyword">if</span> self.suffix != <span class="string">&#x27;seq&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(count + <span class="number">1</span>)) + ext</span><br><span class="line"></span><br><span class="line">                    move_path = os.path.join(self.desPath, des_name)</span><br><span class="line">                    <span class="keyword">if</span> name != os.path.basename(__file__):  <span class="comment"># 防止重命名本文件</span></span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            os.rename(ori_path, move_path)</span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                            print(name + <span class="string">&#x27; 已重命名为 &#x27;</span> + des_name)</span><br><span class="line">                        <span class="keyword">except</span> FileExistsError:</span><br><span class="line">                            print(name + <span class="string">&#x27;更名失败! 已有同名文件存在：&#x27;</span> + move_path)</span><br><span class="line">                        <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">                            print(<span class="string">&#x27;目标文件夹不存在，请检查后重试&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.sub_dir:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">&#x27;共有 &#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27; 个文件更名成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main = RenameFiles()</span><br><span class="line">    main.rename()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用及问题总结</title>
    <url>/archives/58793.html</url>
    <content><![CDATA[<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>blog 文件夹目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml   &#x2F;&#x2F; 网站配置信息</span><br><span class="line">├── package.json  &#x2F;&#x2F; 应用程序信息</span><br><span class="line">├── scaffolds     &#x2F;&#x2F; 模板文件夹</span><br><span class="line">├── source        &#x2F;&#x2F; 资源文件夹</span><br><span class="line">|   ├── _drafts   &#x2F;&#x2F; 草稿</span><br><span class="line">|   └── _posts    &#x2F;&#x2F; 发布的文件</span><br><span class="line">└── themes        &#x2F;&#x2F; 主题</span><br></pre></td></tr></table></figure>


<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>新建文章 <code>hexo new [layout] &lt;title&gt;</code></p>
<blockquote>
<p>没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来</p>
</blockquote>
<p>启动服务 <code>hexo s(server) [--debug]</code></p>
<p>生成静态文件 <code>hexo g(generate)</code></p>
<p>生成部署 <code>hexo g -d </code></p>
<p>发布草稿 <code>hexo publish [layout] &lt;filename&gt;</code></p>
<p>清除缓存（db.json）和静态文件（public）<code>hexo clean</code></p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在头部添加以下信息：</p>
<blockquote>
<p>password: 123<br>abstract: 密码：123<br>message: Enter the password to view the article</p>
</blockquote>
<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><ul>
<li><p>Accessing non-existent property xxxx of module exports inside circular dependency</p>
<p>使用命令 <code>npx cross-env NODE_OPTIONS=&quot;--trace-warnings&quot; hexo s</code>跟踪错误，发现是nib 这个包里的 stylus 的问题，网上说的降低 node 版本是一种方法，但我们不能如此将就。</p>
<p>nib 中的 dependencies 为 <code>&quot;stylus&quot;: &quot;0.54.5&quot;</code>，nib最后一次更新已经是2016年了，指望不了别人，就靠自己吧</p>
<p>始终相信，同样的问题，别人一定提出过，查官方 issues，看到有人已经<a href="https://github.com/stylus/stylus/pull/2538">修复</a>，并且推到了 <a href="https://github.com/stylus/stylus/pull/2538/commits/16e2a6c6f96f80b0d700411879f1c13991a0a1a5">dev</a> 上，几句代码我们就直接改吧</p>
</li>
</ul>
<p>​      打开 node_modules\nib\node_modules\stylus\lib\nodes\index.js 在前面添加以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.lineno = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.column = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.filename = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬取百度文库数据</title>
    <url>/archives/62201.html</url>
    <content><![CDATA[<p>使用 python3 抓取百度文库特点文章数据，只对可查看的内容有效。通过分析查找传输内容数据的 js 链接，而后请求即可</p>
<img data-src="https://i.loli.net/2021/06/07/igN6U5TuVYI7wrC.png"  />

<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>经过排查，发现数据所在文件位置</p>
<p><img data-src="https://i.loli.net/2021/06/05/BRLcKDuITevVJSf.png"></p>
<p>查看其 url 请求，发现有个 <code>authorization</code></p>
<p><img data-src="https://i.loli.net/2021/06/05/geCMP8j7KS3wxzH.png"></p>
<p>开启 Ctrl F 大法，找到了 url 请求的出处，用正则把其中的链接给提前出来就可以取到数据了</p>
<p><img data-src="https://i.loli.net/2021/06/05/FVmD7PR8nYULI6t.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WenKu</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.get_url()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&quot;https://wenku.baidu.com/view/b35a73c5ee3a87c24028915f804d2b160b4e86c6&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;wenku.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.get(url=url,headers=headers)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        script_content = html.xpath(<span class="string">&#x27;//script[2]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        recompile = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?var pageData = (.*?);.*?window.pageData = pageData;.*?&#x27;</span>,re.S)</span><br><span class="line">        page_data = json.loads(recompile.findall(script_content)[<span class="number">0</span>])</span><br><span class="line">        js = json.loads(page_data[<span class="string">&#x27;readerInfo2019&#x27;</span>][<span class="string">&#x27;htmlUrls&#x27;</span>])[<span class="string">&#x27;json&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> page_load_urls <span class="keyword">in</span> js:</span><br><span class="line">            page_load_url = page_load_urls[<span class="string">&#x27;pageLoadUrl&#x27;</span>]</span><br><span class="line">            self.get_data(page_load_url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;wkbjcloudbos.bdimg.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.get(url=url,headers=headers)</span><br><span class="line">        print(response.content.decode(<span class="string">&#x27;unicode_escape&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    WenKu()</span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img data-src="https://i.loli.net/2021/06/05/HzgZkCqL15JyNTj.png"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 登录土巴兔，解决 RSA 加密</title>
    <url>/archives/6310.html</url>
    <content><![CDATA[<p>使用 python3 模拟登录土巴兔装修网，主要解决 RSA 加密问题</p>
<p><img data-src="https://i.loli.net/2021/06/07/b6g9NspVKuXcPd8.png"></p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先进行一次登录，在开发者工具里搜索关键词</p>
<p><img data-src="https://i.loli.net/2021/06/05/NZC3DYEXJbIwtFc.png"></p>
<p>可以看到账号和密码都经过了加密处理，接下来就继续找加密函数，可以看到名为 loginAndReg.js 的文件，点进去一看很明显是 <code>jQuery </code>的语法，其中对数据进行了 RSA 算法加密</p>
<p><img data-src="https://i.loli.net/2021/06/05/u4JBDqfwbyI96Ev.png"></p>
<p>开始常规操作，下断点，一步步找到关键的 <code>public_key</code></p>
<p><img data-src="https://i.loli.net/2021/06/05/dAKpw9cBjFrRqHT.png"></p>
<p><img data-src="https://i.loli.net/2021/06/05/P9pxErM6cBwYnoU.png"></p>
<p><img data-src="https://i.loli.net/2021/06/05/DzshSRTyMqLUwvV.png"></p>
<p><img data-src="https://i.loli.net/2021/06/05/XE4OMspPUx37NZI.png"></p>
<p><code>public_key</code> 找到了，即 RSA 算法的公钥，关键的解决掉了，接下来就是一个验证码的处理过程，不细展开了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">To8To</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,username,password</span>):</span></span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.username = self.RSAString(username)</span><br><span class="line">        self.password = self.RSAString(password)</span><br><span class="line">        self.login()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># RSA算法并进行urlencode编码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RSAString</span>(<span class="params">self,text</span>):</span></span><br><span class="line">        publickeystr = <span class="string">&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhNhuAr4UjFv+cj99PbAQWWx9H</span></span><br><span class="line"><span class="string">X+3jSRThJqJdXkWUMFMTRay8EYRtPFIiwiOUU4gCh4ePMxiuZJWUBHe1waOkXEFc</span></span><br><span class="line"><span class="string">Kg17luhVqECsO+EOLhxa3yHoXA5HcSKlG85hNV3G4uQCr+C8SOE0vCGTnMdnEGmU</span></span><br><span class="line"><span class="string">nG1AGGe44YKy6XR4VwIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----&quot;&quot;&quot;</span></span><br><span class="line">        result = rsa.encrypt(text.encode(<span class="string">&#x27;utf-8&#x27;</span>),rsa.PublicKey.load_pkcs1_openssl_pem(publickeystr.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> requests.utils.quote(base64.b64encode(result).decode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登陆土巴兔</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&quot;https://www.to8to.com/new_login.php&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;439&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="comment"># &#x27;Cookie&#x27;: &#x27;uid=CgoLDl+fxedYQcbnA9+SAg==; sourcepath=b1; to8to_landtime=1604306408; to8to_keywordlist=,,,,,,,,,土巴兔; tracker2019session=%7B%22session%22%3A%22175881d12a348b-054bffcd976ceb-c781f38-2073600-175881d12a4664%22%7D; tracker2019jssdkcross=%7B%22distinct_id%22%3A%22175881d12a823b-0b99c9a8d8c678-c781f38-2073600-175881d12a93b1%22%7D; to8to_tcode=sz; to8to_tname=%E6%B7%B1%E5%9C%B3; to8to_townid=1130; Hm_lvt_dbdd94468cf0ef471455c47f380f58d2=1604306408; to8tocookieid=16ca84d48a125ffcf2b9c3901c5edc0f853582; to8tosessionid=s_ab26dc179eaefefdea5b3b108cbf2bf1; to8to_cook=OkOcClPzRWV8ZFJlCIF4Ag==; tender_popup_flag=true; layer-popup=true; to8to_landpage=http%3A//sz.to8to.com/; to8to_sourcepage=; to8to_nowpage=http%253A%252F%252Fsz.to8to.com%252F; PHPSESSID=bo9224bbpec2hms9upgn240105; agreementRead=true; Hm_lpvt_dbdd94468cf0ef471455c47f380f58d2=1604307019; act=freshen&#x27;,</span></span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.to8to.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://www.to8to.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;val&#x27;</span>: self.username,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: self.password</span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.post(url=url,headers=headers,data=data)</span><br><span class="line">        print(response.text)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;用户名不存在&quot;</span> <span class="keyword">in</span> response.text <span class="keyword">or</span> <span class="string">&quot;登录失败次数过多，请30分钟后再试！&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            html = etree.HTML(response.text)</span><br><span class="line">            yzm_url = <span class="string">&#x27;https:&#x27;</span> + html.xpath(<span class="string">&#x27;//img[@id=&quot;passport&quot;]/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            data[<span class="string">&#x27;yzm&#x27;</span>] = self.img_to_text(yzm_url)</span><br><span class="line">            response = self.session.post(url=url, headers=headers, data=data)</span><br><span class="line">            print(response.text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证码识别</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">img_to_text</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        parses = requests.utils.urlparse(url)</span><br><span class="line">        path = parses.path + parses.params + <span class="string">&#x27;?&#x27;</span> + parses.query</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;referrer&#x27;</span>:<span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;path&#x27;</span>: path,</span><br><span class="line">            <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-user&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url=url,headers=headers)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;yzm.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.content)</span><br><span class="line">        yzm = Image.<span class="built_in">open</span>(<span class="string">&#x27;yzm.png&#x27;</span>)</span><br><span class="line">        yzm = yzm.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        threshold = <span class="number">127</span></span><br><span class="line">        table = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">1</span>)</span><br><span class="line">        yzm.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pytesseract.image_to_string(yzm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    To8To(<span class="string">&#x27;账号&#x27;</span>,<span class="string">&#x27;密码&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img data-src="https://i.loli.net/2021/06/05/GCSr5vm9MTwgjpt.png"></p>
<h2 id="声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。"><a href="#声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。" class="headerlink" title="声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。"></a>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>谁动了我的奶酪</title>
    <url>/archives/43828.html</url>
    <content><![CDATA[<p>《谁动了我的奶酪》（Who　Moved　My　Cheese?），生动的阐述了“变是唯一的不变”这一生活真谛，据说已经成为全世界最畅销的书。或许每一个人看完的感受都不一样，但千万不要说这个道理我懂，如果那样就说明你依然惧怕改变自己。</p>
<span id="more"></span>

<p><em>作者：（美）约翰逊</em> </p>
<h3 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h3><p>　　《谁动了我的奶酪？》是个简单的寓言故事，内容充满了人生中有关变化寓意深长的真理。这是个有趣且能启蒙智慧的故事，内容是在描绘四个住在“迷宫”里的人物，他们竭尽所能地在寻找能滋养他们身心、使他们快乐的“奶酪”的过程。 这四个小人物中，有两只是名叫“嗅嗅”和“匆匆”的老鼠；其他两位则是身体大小和老鼠差不多的小人，名叫“唧唧”和“哼哼”，而且这两个小人的外型与行为和现今的人类差不多。 这里所谓的“奶酪”是一种比喻，它可以被当成我们生命中最想得到的东西。它可能是一份工作、人际关系、金钱、财产、健康、心灵的宁静。 书中所谓的“迷宫”，代表的是一个你花费时间与精力追寻你所欲求的东西的地方，它可以是你所服务的机构或你所居住的社区。 在故事里，这些人物面临突如其来的变化。最后，他们之中有一个成功地对这些变化做出适当的应变，并在迷宫的墙上写下他改变自己的心路历程及从中所得到的经验。 当你看到那些墙上的标语时，你就能自己找出处理变化的方法，了解了这些方法，你就不会感到太多压力，并且能够在生活中或工作中得到更多的成就感（不管你怎么定义这些成就感和压力）。 这本书适合任何的年龄层，而且阅读这故事花费你不到一小时的时间，但其中独特的真知灼见却能对你产生一辈子的影响力和帮助。</p>
<hr>
<blockquote>
<p>再完美的计划也时常遭遇不测<br>生活并不是笔直通畅的走廊，<br>让我们轻松自在地在其中旅行，<br>生活是一座迷宫，<br>我们必须从中找到自己的出路，<br>我们时常会陷入迷茫，<br>在死胡同中搜寻。<br>但如果我们始终深信不疑，<br>有扇门就会向我们打开，<br>它也许不是我们曾经想到的那一扇门，<br>但我们最终将会发现，<br>它是一扇有益之门。<br>…….. </p>
</blockquote>
<p>故事中虚构的四个角色：老鼠嗅嗅和匆匆，小矮人哼哼和唧唧，用来代表我们的不同方面，即我们简单的一面和复杂的一面。</p>
<p>我们每个人都具有这些不同的方面，不论我们的年龄、性别、种族和国籍如何。</p>
<p>有时我们的行为象：嗅嗅，他能够及早嗅出变化的气息；或者像：匆匆，他能够迅速行动；或者像：哼哼，他因为害怕改变而否认和拒绝变化，这会使事情变得更糟，或者像：唧唧，当他看到变化会使事情变得更好时，能够及时地调整自己去适应变化!</p>
<p>不管我们选择哪一面，我们都有共同的方面，那就是：</p>
<p>需要在迷宫中找到我们自己的道路，帮助我们在变化的时代获得成功。 </p>
<hr>
<h3 id="故事背后的故事"><a href="#故事背后的故事" class="headerlink" title="故事背后的故事"></a>故事背后的故事</h3><p>— <em>肯尼思·布兰查德博士</em></p>
<p>　　几年前，斯宾塞·约翰逊和我一起合著《一分钟经理人》的时候，给我讲了一个精彩的故事—-“奶酪的故事”。自从我听到这个寓意深长的故事以后，我就一直盼望着他能把这个故事写成书，使我们大家都能读到它，一起分享书中的带给我们的快乐和教益，因为从那时起，我就一直在回味这个绝妙的故事，惊叹于它带给我的启迪。</p>
<p>　　现在，我怀着激动的心情向大家介绍这本《谁动了我的奶酪》，并给各位讲述有关这个故事背后的故事。</p>
<p>　　《谁动了我的奶酪》讲的是一个关于“变化”的故事。故事发生在一个迷宫中，有四个可爱的小生灵在迷宫中寻找他们的奶酪。故事里的“奶酪”是对我们在现实生活中所追求目标的一种比喻，它可以是一份工作，一种人际关系，可以是金钱，一幢豪宅，还可以是自由、健康、社会的认可和老板的赏识。它只是一种精神上的宁静，甚至还可以只是一项运动，如马术、高尔夫球等等。 我们每个人的内心都有自己想要的“奶酪”，我们追寻它，想要得到它，因为我们相信，它会带给我们幸福和快乐。而一旦我们得到了自己梦寐以求的奶酪，又常常会对它产生依赖心理，甚至成为的附庸；这时如果我们忽然失去了它，或者它被人拿走了，我们将会因此而受到极大的伤害。 故事里的“迷宫”代表着你花时间寻求着的东西所在的地方，它可以是你效力的机构，你生活的社区，亦或是你生活中的某种人际关系。</p>
<p>　　我到世界各地演讲时就时常讲到这个各位即将在本书中读到的“奶酪的故事”，并且我常常听到人们在听完这个故事以后所发出的由衷的感叹，感叹这个故事带给他们的影响与改变。</p>
<p>　　信不信由你，这个小小的“奶酪的故事”已经获得了普遍的赞誉，它帮助了许许多多的人，因为它挽救了他们的事业、婚姻以及他们的生活!</p>
<p>　　这里我经大家讲一个真实的故事，主人翁就是深孚众望的NBC电视节目主持人查理·琼斯。他就是因为这个“奶酪的故事”，而使自己的事业生涯获得了转机。虽然电视节目主持人的职业很特殊，但是查理从故事中所学到的道理都适合于任何一种职业特性，并且人人都可以学习和掌握。</p>
<p>　　以下就是发生在查理·琼斯身上的故事。</p>
<p>　　查理早期所从的主要工作，是报道奥运会的田径项目，他在这项工作上很努力而且一直都干得非常出色。但是，突然有一天老板告诉他，下一届奥运会将派他去报道游泳和跳水项目。听到这个消息，查理既吃惊又难过。</p>
<p>　　因为他对游泳和跳水这两个项目完全不熟悉，这样的安排使他有一种挫折感，觉得自己不被重用和赏识。他说当时他感到这样的安排对他来说太不公平了，他为此而愤愤不平。并且这种愤怒的情绪几乎影响到了他所做的每一件事情，他的生活开始变得一团糟。 就在这时，他听到了这个故事—-“谁动了我的奶酪”。</p>
<p>　　听完故事后，他觉得自己以前的态度和行为十分可笑并迅速采取行动，进行调整。从此，他的工作和行为大大地改善了。因为他已经明白，老板只是拿走了他的奶酪而已，而他所应该做的就是调整自己，适应变化。于是他很快调整好自己的状态，以便适应新的工作，并开始下功夫去熟悉、了解游泳和跳水项目。在开展新工作的过程中，他惊奇地发现，做新的事情竟然使他感觉又焕发了青春。 不久，老板发现查理改变了工作态度，并且重新焕发出了新的活力，于是，给他分派了更多的新的有挑战的工作。从此查理走上了不断成功的道路，并从中享受到了前所未有的喜悦。后来，他被推选为“职业足球名人堂”最佳播音员之一。</p>
<p>　　我听到很多人表示，这个故事对他们的职业生涯和情感生活产生了巨大的冲击和震憾，而查理·琼斯的故事只是真实生活中这许许多多例子中的一个。</p>
<p>　　我是如此地相信“谁动了我的奶酪”这个故事所具有的影响力和震撼力，以致于我把这个故事成书之前的一个版本，送给每一位同我们公司有合作的人(大约二百多人)。我为什么这样做呢？</p>
<p>　　因为，一个公司的经营，不能只停留在求生存的阶段，而必须始终保持一种竞争的状态。我们布兰查德培训公司就是在不断地改变着，有人不断地拿走我们的“奶酪”。过去，传统的公司喜欢忠诚刻板的员工；而今天，我们更需要的是迅捷灵活的人而不是那种习惯于“按部就班”工作的雇员。</p>
<p>　　我们都知道，工作与生活就像不断翻滚的浪花，各种变化都在时时发生。生活在其中，的确使人感到紧张不安，除非有一种办法能使我们关注到这些变化，并且能够从中得到启迪。有一条找到这种办法的途径，那就是走进“奶酪的故事”。</p>
<p>　　当人们听我讲起这个故事后，就纷纷开始去读《谁动了我的奶酪》。而在阅读过程中，几乎每个人都感觉到这个故事让人有一种释放压力并开始放松的神奇作用。各个部门的人一个又一个地跑来感谢我向他们介绍了这本书，并且告诉我这本书对他们的帮助是多么巨大，使得他们能够从不同的角度看待公司正面临的种种变化。</p>
<p>　　请相信我，这则简短的寓言只需花费你不多的时间，但它带给你的影响将是深远的。</p>
<p>　　本书包括三个部分。</p>
<p>　　第一部分，“同学聚会”—-讲述一群过去的同窗在一次聚会上讨论如何应对生活中的种种变化。</p>
<p>　　第二部分是全书的核心—-“谁动了我的奶酪”的故事。</p>
<p>　　在故事里，你会发现，当面对变化时两个老鼠做得比两个小矮人要好，因为他们总是把事情简单化；而当两个小矮人所具有的复杂的脑筋和人类的情感，却总是把事情变得复杂化。这并不是说老鼠比人更聪明，我们都知道人类更具智慧。但换个角度想，人类那些过于复杂的智慧和情感有时又何尝不是前进道路上的阻碍呢？</p>
<p>　　当你观察故事中四个角色的行为时，你会发现，其实老鼠和小矮人代表我们自身的不同方面—-简单的一面和复杂的一面。当事物发生变化时，或许简单行事会给我们带来许多的便利和益处。</p>
<p>　　本书的第三部分，“讨论”—-是那些同窗好友们围绕这个故事展开的讨论，他们讨论这个故事的意味，以及如何把这个故事带给人们的启迪运用到生活与工作中去。</p>
<p>　　有些读过成书之前的手稿的读者读完故事本身后就停下来，不再继续阅读关于这个故事的讨论。另外一些人则更乐于阅读故事后面的“讨论”，因为他们认为从中可以受到启发，可以思考如何将从故事中的东西运用到他们的实际生活中去。</p>
<p>　　无论怎样，我都真诚地希望各位像我一样，在每次阅读这个故事的时候，都能从中领悟到一些新的、有用的东西；希望它能帮助你妥善地应对各种变化，不论你的成功目标是什么，它都能助你走向成功。</p>
<p>　　我希望你们能欢欣于你们从故事中所发现的道理，并能享受到这一发现的乐趣。祝你们一切顺利。 请记住一句话：<strong>随着‘奶酪’的变化而变化，并且享受变化</strong>。</p>
<hr>
<h3 id="芝加哥的同学聚会"><a href="#芝加哥的同学聚会" class="headerlink" title="芝加哥的同学聚会"></a>芝加哥的同学聚会</h3><p>　　芝加哥一个阳光明媚的星期天，许多过去在学校曾是好朋友的同班同学聚在一起搞午餐会。前一天晚上，他们刚参加完全体高中同学的聚会。在一阵打闹嬉笑和丰盛的午餐后，他们坐下来开始了饶有兴致的交谈，希望彼此多了解一些后的生活经历。</p>
<p>　　安杰拉曾是班上最受欢迎的人之一，她第一个发表感慨：“生活真和是跟我们做学生时想象的完全不一样，变化太多了。”</p>
<p>　　“的确如此!”内森附和道。内森正如大家所预料的那样，毕业后就进入了他的家族企业。这家企业的经营模式经年未变，在当地人的记忆中，那可是一家历史悠久的老字号了。因此，当内森若有所思地附和着安杰拉，并发出如此感叹时，大家都感到有些吃惊。 内森好像并未注意到大家的诧异，表情忧郁地接着说：“你们是否注意到，当周围的事情已经发生变化时，我们都不想对自己有所改变。”</p>
<p>　　卡洛斯接着说道：“我们拒绝改变，是因为我们害怕改变。”</p>
<p>　　杰西拉接过他的话：“噢，卡洛斯，你可是学校的足球队长，我们心目中的英雄，我从没想过还有什么东西可以让你害怕的。”</p>
<p>　　大家都笑起来。他们意识到，尽管大家毕业后都在各自不同的方面发展—-从在家工作到在外经营管理公司—-但好像都有类似的感觉—-害怕改变。</p>
<p>　　这些年来，每个人都试图对发生在生活中的各种意想不到的变化。但大家都承认，他们找不到一种很好的应对方法。</p>
<p>　　这时，迈克尔发话了：“我过去也一直害怕改变，直到有一天，我们的生意出现了一个重大的变故，但我们公司所有的人都不知道怎样去应付，由于我们没有及时做出调整，使我们几乎丢掉了全部的生意。”</p>
<p>　　“后来，”迈克尔继续讲道：“我听到了一个故事，这个故事使一切都改变了。”</p>
<p>　　“此话怎讲？”内森问道。</p>
<p>　　“喔，因为这个故事改变了我害怕改变的个性以及我对变化的看法—-从害怕失去某些东西到期待获得某些东西—-它教会我如何去做。从那以后，我的一切都迅速地改善了—-无论工作还是生活。”</p>
<p>　　“是什么故事这么神奇？”好几个人异口同声地问道。</p>
<p>　　“一开始，我被这个故事显而易见的简单给惹恼了，它就像我们小时候听腻了的那些寓言故事一样。”</p>
<p>　　“后来我发现，其实我是被自己惹恼了，我为自己不懂得这样简单明白的道理，在事情发生变化时不能采取有效的举动而感到恼怒。”</p>
<p>　　“再后来，我把这个故事告诉我们公司里的其他人，其他人又讲给其他人听。很快，公司里的业务有了明显的改进，因为我们大家都能及时地做出很好的调整以随时应对变化。与我的感受一样，许多人都说，这个故事使他们的个人生活大受裨益。”</p>
<p>　　“当然，也有人说他们从中没有得到什么，他们或者是知道这样的教训而且已经领教多次了。或者，更普遍的是，他们觉得自己已经懂得够多，不需要再学习什么了。他们甚至假装看不到如此多的人正在从中受益。”</p>
<p>　　“我的一位有些呆板的高级主管就说，读这个故事只是浪费时间。然而大家都取笑他，把他比做故事中的一个角色—-从不学习新的东西而且从不愿意改变。“</p>
<p>　　安杰拉有些迫不及待：“别卖关子了，这究竟是一个什么样的故事？”</p>
<p>　　“故事的名字叫作‘谁动了我的奶酪’。”</p>
<p>　　大家都哄笑起来。卡洛斯说：“我想仅凭这个名字，我就己经喜欢上这个故事了。你能讲给我们听听吗？或许我们也会从中有所收获。”</p>
<p>　　“当然，”迈克尔答道：“我非常愿意把这个故事讲给你们听。它并不长。”于是，他开始给大家讲述这个故事。</p>
<hr>
<h3 id="“谁动了我的奶酪-”的故事"><a href="#“谁动了我的奶酪-”的故事" class="headerlink" title="“谁动了我的奶酪?”的故事"></a>“谁动了我的奶酪?”的故事</h3><p>　　从前，在一个遥远的地方，住着四个小家伙。为了填饱肚子和享受乐趣，他们每天在不远处的一座奇妙的迷宫里跑来跑去，在哪里寻找一种叫做“奶酪”的黄橙橙、香喷喷的食物。</p>
<p>　　有两个小家伙是老鼠，一个叫“嗅嗅”，另一个叫“匆匆”。另外两个家伙是小矮人，和老鼠一样大小，但和人一个模样，而且他们的行为也和我们今天的人类差不多。他俩的名字，一个叫“哼哼”，另一个叫“唧唧”。</p>
<p>　　由于他们四个实在太小了，他们在干什么当然不太会引起旁人的注意。但如果你凑近去仔细观察，你会发现许多令人惊奇不已的事情！ 两个小老鼠和两个小矮人每天都在迷宫中度过，在其中寻找他们各自喜欢的奶酪。嗅嗅、匆匆的大脑和其他啮齿类动物的差不多一样简单，但他们有很好的直觉。和别的老鼠一样，他们喜欢的是那种适合啃咬的、硬一点的奶酪。</p>
<p>　　而那两个小矮人，哼哼和唧唧，则靠脑袋行事，他们的脑袋里装满了各种各样的信念和情感。他们要找的是一种带字母“C”的那奶酪。他们相信，这样的奶酪会给他们带来幸福。使他们成功。</p>
<p>　　尽管小老鼠和小矮人的目标各不相同，但他们做的事情是差不多的。每天早上，他们会各自穿上运动服和慢跑鞋，离开他们的小房子，跑进迷宫寻找他们各自钟爱的奶酪。</p>
<p>　　迷宫中有许多曲折的走廊和好像蜂窝的房间，其中的一些房间里藏着美味的奶酪，但更多的地方是黑暗的角落和隐藏的死胡同，任何人走进去都很容易迷路。</p>
<p>　　同时，这座迷宫还有一种神奇的力量，对那些找到出路的人，它能使他们享受到美好的生活。</p>
<p>　　两个小老鼠，嗅嗅和匆匆，总是运用简单低效的反复尝试的办法找奶酪。他们跑进一条走廊，如果走廊的房间都是空的，他们就返回来，再去另一条走廊搜寻。没有奶酪的走廊都会记住。就这样，很快地他们从一个地方找到另一个地方。嗅嗅可以用他那了不起的鼻子嗅出奶酪大致的方向，匆匆则跑在前面开路。然而迷宫太大太复杂，如你所料，他们经常会迷路，离开正道走错了方向，有时甚至还会撞倒墙上。</p>
<p>　　两个小矮人，哼哼和唧唧，则运用他们思考的能力，从过去的经验中学习。他们靠复杂的脑筋，搞出了一套复杂的寻找奶酪的方法。</p>
<p>　　哼哼和唧唧的方法比他们的老鼠朋友要高效，因此他们走进死胡同和碰壁的情况要比小老鼠们少得多。他们也为此而时常沾沾自喜很是得意，甚至有些看不起低智商的老鼠朋友。然而有时候，人类复杂的头脑所带来的复杂感情也会战胜他们的理性思维，使他们看问题的眼光变得暗淡起来。这也使得他们在迷宫里的生活更加复杂化，也更具有挑战性了。</p>
<p>　　但不管怎样，这四个家伙嗅嗅和匆匆，哼哼和唧唧，都以他们各自不同的方式不懈的追寻着他们想要得到的东西。最后，终于有一天，在某个走廊的尽头，在奶酪C站，他们都找到了自己想要的奶酪。</p>
<p>　　这里真是一个天堂，四个小家伙被眼前的情景惊呆了，无数各种各样的奶酪堆积如山，闪着诱人的光亮。四个小家伙呆了半晌，然后就疯了般地冲进奶酪堆，开始狂欢。 从那以后，这四个家伙，小老鼠和小矮人，每天早上穿上他们的跑步装备后便毫不犹豫地直奔奶酪C站。不久，他们都建立了熟悉的路线，并形成了各自的生活习惯。</p>
<p>　　嗅嗅和匆匆仍旧每天都起得很早，然后沿着相同的路线跑进迷宫中。</p>
<p>　　当老鼠们到达目的地后，他们脱下自己的跑鞋，有条不紊地将两只鞋系在一起，挂在脖子上;以便需要的时候很快穿上。然后他们才开始尽情地享用奶酪。</p>
<p>　　在开始一段时间里，哼哼和唧唧也是如此行事，每天早上赶到奶酪C站，按部就班的把鞋子挂在脖子上，享用在那里等着他们的美味佳肴。</p>
<p>　　然而不久以后，小矮人们改变了他们的常规。</p>
<p>　　哼哼和唧唧每天起得比老鼠们晚一些，懒懒地穿好运动服，然后信步走到奶酪C站。不管怎样，反正已经找到了奶酪。</p>
<p>　　他们从没想过，奶酪是从哪里来的，是谁把他们放在那里的。他们只是理所当然地认为，奶酪总是会在 那里的。</p>
<p>　　每天，哼哼和唧唧到奶酪C站以后，就像回到自己的家一样，舒服的呆在哪里。他们脱下运动衣，把它们挂起来，甩掉脚上的鞋子，换上拖鞋。他们找到了奶酪，感觉实在是太惬意了。</p>
<p>　　“真是太好了！”哼哼说：“这里有这么多奶酪，足够我们享用一辈子了。”小矮人们充满了幸福和成功的感觉，觉得从此可以无忧无虑了。</p>
<p>　　不久，哼哼和唧唧更理所当然地认定，他们在奶酪C站发现的奶酪就是“他们自己的”奶酪了。这里的奶酪库存是如此的丰富，于是他们决定把家搬到各靠近奶酪C站的地方，还在周围一带开展了他们的社交活动。 </p>
<p>　　为了使这里更像家的感觉，哼哼和唧唧把墙壁装饰了一通，还在墙上写了一些格言，并精心地画上了一些非常可口的奶酪的图案。他们看着这些图画和格言，会心地笑了，其中一幅图画的内容是：</p>
<p><strong>拥有奶酪，就拥有幸福。</strong></p>
<p>　　有时，他们会带朋友来参观他们在奶酪C站里成堆的奶酪，自豪地指着这些奶酪说：“多么美妙可口的奶酪呀，不是吗？”有时，他们还会与朋友们一起分享这些奶酪，而有时则是单独享用。</p>
<p>　　“我们应该拥有这些奶酪，”哼哼说，“为了找到它们，我们可是付出了长期而艰苦的努力的，我们当然有资格拥有它们。”他一边说着一边拿起一块鲜美的奶酪放进嘴里，享用起来，脸上流露出幸福的光彩。</p>
<p>　　然后，就像往常一样，哼哼享受完奶酪便睡着了，梦里还路除满足而惬意的笑容。</p>
<p>　　每天晚上，小矮人们在美美地饱餐了奶酪后，就摇摇摆摆地走回家，第二天早上他们又会信心十足地走进奶酪C站，去享用更多的奶酪。</p>
<p>　　这样的境况维持了相当长的一段时间。</p>
<p>　　逐渐地，哼哼和唧唧的自信开始膨胀起来。面对成功，他们开始变得妄自尊大。在这种安逸的生活中，它们丝毫没有察觉到正在发生的变化。</p>
<p>　　随着时间的流逝，嗅嗅和匆匆日复一日地重复着他们的生活。每天早早地赶到奶酪C站，四处闻一闻、抓一抓，看看这区域和前一天有什么不一样。等到确定没有任何异常后他们才会坐下来细细品味奶酪，好好享受一番。</p>
<p>　　一天早上，当嗅嗅和匆匆到达奶酪C站时，发现这里已经没有奶酪了。<br>　　对此，他们并不感到吃惊，因为他们早已察觉到，最近好像有一些奇异的事情正在奶酪C站里发生，因为这里的奶酪已经越来越小，并且一天比一天少了。他们对这种不可避免的情况早有心理准备，而且直觉地知道该怎么办。</p>
<p>　　他们相互对望了一眼，毫不犹豫地取下挂在脖子上的跑鞋，穿上脚并系好鞋带。</p>
<p>　　两只小老鼠对此并没有做什么全面细致的分析，事实上，也没有足够复杂的脑细胞可以支持他们进行这么复杂的思维。</p>
<p>　　对老鼠来说，问题和答案都是一样的简单。奶酪C站的情况发生了变化，所以，他们也决定随之而变化。</p>
<p>　　他们同时望向迷宫深处。嗅嗅扬起他的鼻子闻了闻，朝匆匆点点头，匆匆立刻拔腿跑向迷宫的深处，嗅嗅则紧跟其后。</p>
<p>　　他们开始迅速行动，去别的地方寻找新的奶酪，甚至连头都没有回一下。</p>
<p>　　同一天的晚些时候，哼哼和唧唧也像往常一样溜溜达达地来到奶酪Ｃ站，一路上哼着小曲。他们过去一直没有察觉到这里每天都在发生的细小变化，而想当然地以为他们地奶酪还在那里。</p>
<p>　　面对新的情况，他们毫无准备。</p>
<p>　　“怎么！竟然没有奶酪？”哼哼大叫道，然后他开始不停地大喊大叫，“没有奶酪？怎么可能没有奶酪？”好像他叫喊地声音足够大的话，就会谁把奶酪送回来似的。</p>
<p>　　“谁动了我的奶酪？”他声嘶力竭地呐喊着。</p>
<p>　　最后，他把手放在屁股上，脸憋得通红，用他最大的嗓门叫道：“这不公平！”</p>
<p>　　唧唧则站在那里，一个劲的摇头，不相信这里已经发生的变化。对此，他同样没有任何心里准备，他满以为在这里照旧可以找到奶酪。他长时间地站在那里，久久不能动弹，完全被这个意外给惊呆了。</p>
<p>　　哼哼还在疯狂地叫嚷着什么，但唧唧不想听，他不想面对眼前的现实，他拼命告诉自己，这只是一个噩梦，他只想回避这一切。</p>
<p>　　他们的行为并不可取，而且也于事无补，但我们总还是能够理解的。</p>
<p>　　要知道找到奶酪并不是一件容易的事情。更何况，对这两个小矮人来说，奶酪绝不仅仅只是一样填饱肚子的东西，它意味着他们悠闲的生活、意味着他们的荣誉、意味着他们的社交关系以及更多重要的事情。</p>
<p>　　对他们来说，找到奶酪是获得幸福的唯一途径。根据不同的偏爱，他们对奶酪的意义有各自不同的看法。对有些人而言，奶酪代表的是一种物质上的享受；而对另一些人来说，奶酪则意味着健康的生活，或者是一种安宁富足的精神世界。</p>
<p>　　对唧唧来说，奶酪意味着安定，意味着某一天能够拥有一个可爱的家庭，生活在名人社区的一座舒适的别墅里。</p>
<p>　　对哼哼来说，拥有奶酪可以使他成为大人物，可以领导很多的人，而且可以在卡米伯特山顶上拥有一座华丽的宫殿。</p>
<p>　　由于奶酪对他们实在太重要了，所以这两个小矮人花了很长时间试图决定该怎么办。但他们所能够想到的，只是在奶酪Ｃ站里寻找，看看奶酪是否真的不存在了。</p>
<p>　　当嗅嗅和匆匆已经迅速行动的时候，哼哼和唧唧还在那里不停地哼哼唧唧、犹豫不决。</p>
<p>　　他们情绪激动地大声叫骂这世界的不公平，用尽一切恶毒的语言去诅咒那个搬走了他们奶酪的黑心贼。然后唧唧开始变的消沉起来，没有了奶酪，明天会怎样？他对未来的计划完全都建立在这些奶酪的基础上面的啊！</p>
<p>　　这两个小矮人不能接受这一切。这一切怎么可能发生呢？没有任何人警告过他们，这是不对的，事情不应该是这个样子的，他们始终无法相信眼前的事实。</p>
<p>　　那天晚上，哼哼和唧唧饥肠辘辘、沮丧地回到家里。在离开之前，唧唧在墙上写下了一句话：</p>
<p><strong>奶酪对你越重要，你就越想抓住它。</strong></p>
<p>　　第二天，辗转难眠了一晚上的哼哼和唧唧早早地离开家又回到奶酪C站，不管怎样，他们抱着一线希望，他们不断地欺骗自己，假定昨天走错了地方，他们仍然希望找回他们的奶酪。奶酪站的位置没有变化，然而奶酪的的确确早已不复存在。两个小矮人顿时手足无措，不知道该怎么办。哼哼和唧唧只是站在那里，一动不动，就像两座毫无生气的雕像。</p>
<p>　　唧唧紧紧闭上眼睛，用手捂住自己的耳朵，他只想把一切都堵在外面。他不愿相信奶酪是逐渐变得越来越小的，他宁愿相信奶酪是突然之间被全部拿走的。</p>
<p>　　哼哼则把现在的情况分析了又分析，他用他复杂的大脑把他所有的信条都翻了个遍。“他们为什么要这样做？”他终究没能找到答案，“这里究竟发生了什么事情？” 终于，唧唧睁开了眼睛，朝周围看了看说：“顺便问一下，嗅嗅和匆匆现在在哪里？你是否觉得他们知道某些我们还不知道的事情？”</p>
<p>　　“那两个弱智，他们能知道些什么？”哼哼的语气中充满了不屑。</p>
<p>　　他继续说：“他们只是头脑简单的老鼠，他们只会对发生的事情做出简单的反应。而我们是机伶聪明的小矮人，我们比老鼠有头脑。我们应该能够推测出这里的情况。”</p>
<p>　　“我知道我们更聪明，”唧唧说，“但是，我们现在的行为好像并不怎么聪明。我们周围的情况已经发生了变化，哼哼，也许我们需要做出一些改变，去做点什么不同的事情。”</p>
<p>　　“我们为什么要改变？”哼哼问道，“我们是小矮人，我们是不一样的。这样的事情不应该发生在我们的身上。即使出现了这样的情况，我们至少也应该从中得到一些补偿。”</p>
<p>　　“为什么我们应该得到一些补偿呢？”唧唧问。</p>
<p>　　“因为我们有这样的权利。”哼哼宣称。</p>
<p>　　“有什么样的权利？”唧唧不明白。</p>
<p>　　“有拥有我们奶酪的权利。”</p>
<p>　　“为什么？”唧唧还是不明白。</p>
<p>　　“因为这个问题不是我们引起的，”哼哼说，“是某些别有用心的人制造了这个局面，而不是我们，所 以我坚持认为我们总应该从中得到些补偿。”</p>
<p>　　“也许我们应该停止这种无用的分析，”唧唧提议，“分析问题到此为止。在我们还没有被饿死之前，我们应该赶紧出发去找新的奶酪。”</p>
<p>　　“噢，不！”哼哼反对说，“我们快要找到问题的根源了，要知道，我们曾经拥有过那么多、那么好的奶酪啊！”</p>
<p>　　当哼哼和唧唧还在争执着试图决定该怎么办的时候，嗅嗅和匆匆已经在很顺利的做他们的事情了。他们进入了迷宫的更深处，走过一条又一条走廊，在每一个他们遇到的奶酪站里仔细寻找着奶酪。</p>
<p>　　除了倾尽全力地寻找新的奶酪，他们并不考虑任何别的事情。</p>
<p>　　有好一段时间，他们找得很辛苦却一无所获。直到他们走进迷宫中一个他们从未到过的地方：奶酪N站。</p>
<p>　　他们高兴得尖叫起来，他们终于发现了他们一直在寻找的东西：大量新鲜的奶酪。</p>
<p>　　他们简直不敢相信自己的眼睛，这是他们见过的最大的奶酪仓库。</p>
<p>　　而与此同时，哼哼和唧唧仍然呆在奶酪C站，对他们目前的处境进行揣摩。他们正在忍受着失去了奶酪的痛苦，挫折感、饥饿感和由此而来的愤怒紧紧围绕着他们，折磨着他们，他们甚至为陷入眼前的困境而相互指责。</p>
<p>　　唧唧仍然时时想起他的老鼠朋友，猜想他们现在是否已经找到了奶酪。他相信他们也许过得很困难。在迷宫中穿行，总会面临许多难以预料的事情。但他也知道，什么事情也得有不容易的一个阶段。</p>
<p>　　有时，唧唧会想出嗅嗅和匆匆已经找到了新的奶酪并正在享用他们的情景。他忽然有一种冲动，想到迷宫中冒险去寻找新的奶酪。在迷宫中探险，找到新的奶酪并尽情享用，这一切该是多么的美好啊！想到这里，他觉得仿佛自己已经尝到了新鲜奶酪的美味。</p>
<p>　　正在寻找和享用新的奶酪，这样的情景在唧唧的头脑中越来越清晰。他觉得自己越来越想离开奶酪C站，出发去寻找新的奶酪。</p>
<p>　　突然，他大声宣布道：“我们走吧！”</p>
<p>　　“不！”哼哼很快作出了反应：“我喜欢这里。我只熟悉这里，这里很好很舒服。再说，离开这里到外 面去是很危险的。”</p>
<p>　　“不会的，”唧唧说：“以前我们也曾经到过这个迷宫中的许多地方，我们还可以再去其他地方找找看。”</p>
<p>　　“我觉得自己已经有些老了，不能再做这种跑来跑去到处冒险的事了。”哼哼说：“而且，我也不想像个傻瓜似的，时常迷路。你觉得呢？” 听哼哼这么一说，失败的恐惧感又袭上了唧唧的心头，他的那点发现新奶酪的希望有逐渐消退了。</p>
<p>　　就这样，这两个小矮人继续作着以前每天所作的事。他们仍然每天都去奶酪C站，发现还是找不到奶酪，然后怀着忧虑和挫败的心情回到家里。</p>
<p>　　他们试图否认眼前发生的一切，开始失眠，力气一天比一天小，变得越来越烦躁易怒。</p>
<p>　　他们的家，也不再是美好舒适的地方。他们睡不上一个安稳觉，而且每晚的时光都伴着找不到奶酪的噩梦度过。</p>
<p>　　但他们仍然每天回到奶酪C站，仍然每天在那里等待。</p>
<p>　　哼哼说：“你知道，如果我们再努力一些，我们也许会发现事情并没有发生太大的变化。奶酪也许就在 附近，他们也许只是被人藏到墙的后面去了。”</p>
<p>　　第二天，哼哼和唧唧带了工具回到奶酪C站。哼哼拿着凿子，唧唧则用锤子敲打。他们费了九牛二虎之力，终于在墙上打出了一个洞，朝里面窥视，却依旧没有发现奶酪的踪迹。</p>
<p>　　尽管他们感到非常失望，但他们仍然相信问题会得到解决，以后，他们起得更早，工作时间更长、更努力。但是，一段时间以后，他们得到的只是一个个更大的空洞。</p>
<p>　　唧唧开始认识到行动和结果之间的区别。</p>
<p>　　“也许，”哼哼说：“我们只需要坐在这里，看看到底会发生什么事情。迟早他们会把奶酪再送回来的。”</p>
<p>　　唧唧希望他说的是真的。这样，他每天回家休息，然后勉强陪着哼哼去奶酪C站察看情况。但是，奶酪始终没有再出现。</p>
<p>　　由于焦虑和饥饿，这两个小矮人已经变得有些虚弱。唧唧已经开始厌倦等待—-完全被动地等着状况自己发生好转。他开始明白，他们在奶酪C站等待的时间越长，情况只会变得越糟糕。</p>
<p>　　唧唧明白，他们正失去自己的优势。</p>
<p>　　终于，有一天，唧唧开始自己嘲笑起自己来了：“唧唧呀唧唧，看看你自己吧！你居然等到每天重复同样的错误，还总是奇怪、怀疑为什么情况还没有得到改善，还有什么比你这种做法更可笑的呢？这如果不是荒谬，就是滑稽。”</p>
<p>　　唧唧并不想再到迷宫中去奔波。他知道他可能会迷路，而且他也不知道究竟应该到哪儿去寻找新的奶酪。但当他明白正是他的恐惧感使他如此裹足不前、坐以待毙的时候，他嘲笑自己的愚笨。</p>
<p>　　他问哼哼：“我们的运动衣和慢跑鞋放到哪里去了？”他花了很长时间才翻出了那些运动装备。当初，他们在奶酪C站找到奶酪以后，就把鞋啊什么的都扔到一边去了，因为他们满以为再也不会需要这些玩意儿了。</p>
<p>　　当哼哼看到他的朋友穿上运动服时，他说：“你不是真的要到迷宫中去吧？你为什么不留下来，和我一起在这里等，等着他们把奶酪送回来？” “因为如果这么做，我们将永远不会得到那些奶酪，”唧唧大声说：“不会有人把奶酪送回来了，现在已经到了去寻找新的奶酪的时候了，不要再想那些早已不存在的奶酪了！”</p>
<p>　　哼哼争辩说：“但是如果外面也没有奶酪怎么办？或者，即使有奶酪，但你找不到，又怎么办？”</p>
<p>　　“我不知道。”唧唧不耐烦地说。同样的问题，他已经问过自己多少遍了。他又感到了那种使他停滞不前的恐惧感。</p>
<p>　　但是马上，他又想到如果真的找到了新的奶酪呢？那种享受新奶酪的喜悦再度鼓起了他的勇气。 他最后问自己：“你希望到哪里去找奶酪—-这里还是迷宫中？”</p>
<p>　　于是他脑中出现了一幅图画，他看见自己面带微笑的在迷宫中探险。</p>
<p>　　这样的景象让他有些惊异，他发现自己终于克服了再次进入迷宫的恐惧。他看见自己在迷宫中迷了路，但仍然满怀信心地在那里寻找新的奶酪，一切美好的事物都随之而来。他又重新找回了自己的勇气。</p>
<p>　　于是，他尽量发挥自己的想象力，在脑海中为自己描绘了一幅他最信赖的、最具现实感的图画—-他在寻找和品尝新的奶酪。</p>
<p>　　他仿佛看见自己坐在一大堆奶酪中央，正在尽情品尝各种奶酪，像蜂窝状的瑞士奶酪、鲜黄的英国切达干酪、美国奶酪和意大利干酪，还有美妙又柔软的法国卡米伯特奶酪，等等。 唧唧简直想的入了神，知道他听见哼哼在一边嘟囔着什么，他才意识到自己仍然还站在奶酪C站。</p>
<p>　　于是唧唧转过身来对哼哼说：“哼哼，有时候，事情发生了改变，就再也变不会原来的样子了。我们现在遇到的情况就是这样。这就是生活！生活在变化，日子在往前走，我们也应随之改变，而不是在原地踟蹰不前。”</p>
<p>　　唧唧看着他那因饥饿和沮丧而显得有些憔悴的朋友，试图给他分析一些道理。但是，哼哼的畏惧早已变成了气恼，他什么也听不进去。</p>
<p>　　唧唧并不想冒犯他的朋友，但是他还是忍不住要嘲笑他们自己，因为现在看起来他们俩真是又狼狈又愚蠢。</p>
<p>　　当唧唧准备要出发的时候，他觉得自己整个人都变的充满了活力，他挺起了胸膛，他的精神开始振作起来：“让我们出发吧。”</p>
<p>　　唧唧大笑着宣称：“这是一个迷宫的时代！”</p>
<p>　　哼哼笑不出来，他几乎没有任何反应。</p>
<p>　　唧唧拾起一块坚硬的小石头，在墙上写下一句恳切的话，留给哼哼去思考。他没有忘记自己的习惯，在这句话的周围画上奶酪的图案。唧唧希望着幅画能给哼哼带来一丝希望，会对哼哼有所启发，并促使哼哼起身去追寻新的奶酪。但是哼哼根本不想朝墙上看一眼。</p>
<p>　　墙上的话是：</p>
<p>　　如果你不改变，你就会被淘汰。</p>
<p>　　在墙上留完言后，唧唧伸出脑袋小心翼翼地朝迷宫中望了望，回想着到达奶酪C站以前所走过的路线。</p>
<p>　　他曾经想过，也许迷宫中再也没有奶酪了，或者，他可能永远也找不到奶酪。这种悲观的情绪曾经那样深地植于他的心底，以至于差一点就毁了他。</p>
<p>　　想到这里，唧唧会心地微笑起来。他知道，哼哼现在一定还站在原地懊恼：“究竟是谁动了我的奶酪？”而唧唧此刻想到的确是：“我为什么没有早点行动起来，跟着奶酪移动呢？” 当唧唧终于走出奶酪C站踏入黑暗的迷宫时，他忍不住回头看了看这个曾经伴随他和哼哼很长一段时间的地方。那一瞬间他几乎无法控制自己，又想走回那个熟悉的地方，又想躲进那个虽然已没有奶酪但很安全的地方。</p>
<p>　　唧唧又有些担心起来，拿不准自己是否真的想要进入到迷宫中去。片刻以后，他又拿起石块在面前的墙上写下一句话，盯着它看了许久：</p>
<p><strong>如果你无所畏惧，你会怎样做呢？</strong></p>
<p>　　他对着这句话苦思冥想。</p>
<p>　　他知道，有时候，有所畏惧是有好处的。当你害怕不做某些事情会使事情变的越来越糟糕时，恐惧心反而会激起你去采取行动。但是，如果因为过分害怕而不敢采取任何行动时，恐惧心就会变成前进道路上最大的障碍。</p>
<p>　　他朝迷宫的右侧瞧了瞧，心中生出了恐惧，因为他从未到过那里面。</p>
<p>　　然后，他深吸了一口气，朝迷宫的右侧缓步跑去，跑向那片未知的领地。</p>
<p>　　在探路的时候，唧唧有些担心起来，一开始他还在奶酪C站犹豫了那么久，因为长时间没有吃到奶酪了，他有些虚弱。现在，在迷宫中穿行要比以前更加吃力，花的时间更长。他打定主意，一旦再有机会，他一定要尽早走出舒适的环境去适应事务的变化。他觉得立刻采取措施会使事情变的容易一些。 想到这里，唧唧无力地微笑了一下，感叹道：“迟做总比不做好。”</p>
<p>　　接下来地几天里，唧唧在周围偶尔能够找到一点奶酪，但都吃不了多久。他曾经希望能够找到足够多的奶酪，带回去给哼哼，鼓励他离开原地，走进迷宫。</p>
<p>　　但是，唧唧还是感到有些信心不足，他不得不承认，身在迷宫中，他感到十分困惑。里面很多地方跟以前完全不一样了。</p>
<p>　　他这样想着朝前走去，他觉得自己已经走了好远，却又好像就要迷失在迂回曲折的走廊中了。这就好像是在走两步退一步，对他来说真是一种挑战。不过他还是要承认，回到迷宫中寻找奶酪，其实并不像他想像的那样可怕。 随着时间的流逝，他开始有些怀疑，找到新奶酪的希望是否能变成现实。有种幻觉，有时他怀疑是否自己嘴里的奶酪太多而嚼不过来，这时，想到自己根本没有东西可嚼，他不禁哑然失笑。</p>
<p>　　每当他开始感到泄气的时候，他就提醒自己正在做什么。尽管现在很难受，但这样总比呆在没有奶酪的地方更实际。他在掌握控制权，而不是听天由命、束手无策。</p>
<p>　　他还提醒自己，如果嗅嗅和匆匆能不断前行，那么自己也能做到！</p>
<p>　　后来，唧唧回想起过去的事情，他终于明白奶酪C站的奶酪并不是像他曾经相信的那样一夜之间突然消失的。奶酪的数量是逐渐变少，直至完全消失的。而且，剩下的那一点也已经陈旧变质，美味丧失殆尽了。</p>
<p>　　那些陈旧的奶酪上面或许已经生出了霉菌，只是他没有注意到罢了。他还得承认，只要他愿意，应该能够注意的到，可惜他当初没有留意这些变化。</p>
<p>　　唧唧还认识到，如果他一直能够察觉到这些变化而且能够预见到这些变化，那么，这些变化就不会让他感到吃惊。也许，嗅嗅和匆匆一直就是这样做的。</p>
<p>　　他打定主意，从现在起，他要时刻保持警觉。他要期待着发生变化，而且还要去追寻变化，。他应该相信自己的直觉，能告意识到何时发生变化，并且能够做好准备去适应这些变化。</p>
<p>　　他停下来休息了一会，并在迷宫的墙上写道：</p>
<p>　　<strong>经常闻一闻你的奶酪</strong></p>
<p>　　你就会知道，</p>
<p>　　它什么时候开始变质。</p>
<p>　　一段日子以后，好像已经很久没有找到奶酪了。这天，唧唧遇到了一个很大的奶酪站，看起来里面似乎装满了奶酪。当他走进去以后，却发现里面空空如也，他失望至极。</p>
<p>　　“这种空空的感觉，对我来说太平常了。”他叹息道，他觉得自己就快要放弃了。</p>
<p>　　唧唧的体力正在慢慢地丧失。他知道自己迷路了，此刻，他有些担心自己能不能活下去。他想转身回到奶酪C站去。回去后，至少哼哼还在那里，唧唧就不会孤单一人了。这是，他又问了自己一个同样的问题：“如果我无所畏惧，我又会怎样做呢？” 唧唧觉得他正在克服和超越自己的恐惧，但他又越来越经常地感到害怕，害怕得甚至无法对自己承认。他常常难以确定自己到底害怕什么，但是在目前这样虚弱的状况下，他知道，他只是害怕一个人独自前行。唧唧其实并不清楚这一点，他只是在跟着这种感觉走，因为他一直在被这些恐惧得念头压迫着。</p>
<p>　　唧唧想知道哼哼是否已经离开了C站开始出发去寻找新的奶酪，或者是否仍然被自己得恐惧所吓倒，仍旧裹足不前。这时，唧唧想起他在迷宫中度过的时光，那些他曾经觉得是最美好的时光，其实正是他一个人穿行在迷宫中找寻奶酪的时候。</p>
<p>　　他又在墙上写下了一句话，以便提醒自己。同时，这句话也是一个标记，留给他的朋友哼哼，希望哼哼会跟上来。</p>
<p><strong>朝新的方向前进　你就会发现新的奶酪</strong></p>
<p>　　唧唧朝着黑暗深邃的通道中望去，又有一阵恐惧袭来。前面有些什么？是不是什么都没有？或者更糟，里面潜藏着危险？他开始想像各种可能降临到他头上的可怕的事情。他越想越怕，快把自己吓死了。</p>
<p>　　忽然，他又觉得自己真是可笑。他意识到，他的畏惧只会使事情变的更糟糕。于是，他采取了当他无所畏惧的时候他会采取的行动。他朝一个新的方向跑去。</p>
<p>　　当他跑向这条黑暗的走廊时，他笑了起来。唧唧还没认识到这一点，但他觉得他的灵魂得到了丰富。他正在放开自己，对前景充满了信心，尽管他并不能确切地知道前面究竟有些什么。</p>
<p>　　出乎意料，他开始对自己感到越来越满意。“为什么我感觉这么好？”他不明白：“我并没有找到奶酪，而且也不知道要到那里去。”</p>
<p>　　不久，他明白了他为什么会感觉这么好。他停下脚步，在墙上写道：</p>
<p>　　<strong>当你超越了自己的恐惧时，你就会感到轻松自在。</strong></p>
<p>　　他认识到，他原来是被自己的恐惧感给控制住了。如今朝一个新的方向迈进，使他获得了自由。</p>
<p>　　这时，从迷宫中吹来习习的凉风，使人感到神清气爽。他深吸了一口气，不觉振作起来。一旦克服了自己的恐惧感，他觉得一切比原来自己想像的要好得多。</p>
<p>　　唧唧已经很久没有这种感觉了。他几乎快要忘记了这种感觉是多么的惬意。</p>
<p>　　为了使事情更顺利地进行，他又开始在头脑中描绘一种景象。想像中，他在一种很棒的现实环境，坐在各种他喜欢的奶酪中间—-有切达奶酪还有布里奶酪！他看见自己在吃许多他喜欢吃的奶酪。这样的景象使他获得一种享受，他想像着这些奶酪的滋味该是多么美啊！</p>
<p>　　这种享受新奶酪的情景，他看得越清楚，就越相信这会变成现实。现在，他有一种感觉，他就要找到奶酪了，</p>
<p>　　他又在墙上写道：</p>
<p><strong>在我发现奶酪之前，想像我正在享受奶酪，这会帮我找到新的奶酪。</strong></p>
<p>　　唧唧一直在想的是他将会得到什么，而不是考虑他会失去什么。</p>
<p>　　他不明白，为什么自己过去总是觉得变化会使事情变得更糟，而现在他认识到，变化将会使事情变得更好。</p>
<p>　　“为什么以前我不明白这一点？”他反问自己。</p>
<p>　　于是，他以更大的勇气和力量快速灵敏地穿行在迷宫中。不久，他就发现了一个奶酪站。当他在迷宫的入口处发现一些新奶酪地碎屑时，他变得兴奋起来。</p>
<p>　　这是一些他从未见过的奶酪，但看起来挺不错，他尝了尝，真是美味啊！他吃掉了大部分能找到地小块奶酪，把剩下地放进口袋，以后也许可以和哼哼分享。他的体力也开始得到恢复。</p>
<p>　　他怀着兴奋地心情走进去。但是，让他感到惊愕的是，里面竟然是空的。有人已经来过这里，只留下了一些小块奶酪。</p>
<p>　　他认识到，如果能早一点行动，他就很可能早已在这里发现大量的新奶酪了。</p>
<p>　　唧唧决定会去，看看哼哼是否愿意和他一起行动，</p>
<p>　　在返回的路上，他停下来，在墙上写道：</p>
<p><strong>越早放弃旧的奶酪，你就会越早发现新的奶酪。</strong></p>
<p>　　不久，唧唧就回到了奶酪C站，找到了哼哼，他给哼哼一些新的小块奶酪，但被拒绝了。</p>
<p>　　哼哼很感激朋友的心意，但是他说：“我不喜欢新奶酪，这不是我习惯吃的那一种。我只要我自己的奶酪回来。除非可以得到我想要的东西，否则我是不会改变主意的。”</p>
<p>　　唧唧失望地摇摇头，不情愿地一个人踏上了自己地旅程。当走到他到达过的迷宫最深处时，他怀念起他的朋友来，但他明白，他喜欢的还是他的探险过程。虽然以前他想自己希望的是得到充足的新奶酪，但现在他清楚使自己快乐的并不仅仅是奶酪而已。 他高兴的是，他不再受自己的恐惧感的驱使。他喜欢自己正在做的事情，</p>
<p>　　明白了这一点，唧唧不再像在奶酪C站时，在没有奶酪的日子里感到那样的虚弱了。他知道，他不会再让恐惧感阻碍自己。他选择了一个新的方向，他的身心得到了滋养，体力得到加强。</p>
<p>　　现在，他觉得，找倒自己想要的东西只是一个时间问题。事实上，他感到自己已经找到了他一直在寻找的东西。</p>
<p>当他认识到这一点色时候，他不禁微笑起来，并在墙上写道：</p>
<p>　　<strong>在迷宫中搜寻比停留在没有奶酪的地方更安全。</strong></p>
<p>　　唧唧还认识到，就像他曾经体会过的那样，你所害怕的东西根本没有你想像的那样糟糕，在你心里形成的恐惧比你的实际处境更坏。他曾经是如此的害怕找不到新的奶酪，以致于他根本不想开始去寻找。然而一旦开始寻找的旅程，他就发现迷宫的走廊中有足够的奶酪使他继续找下去。现在，他期待着找到更多的奶酪。只要朝前看，他就会因为有所期待而兴奋起来。</p>
<p>　　他过去的思想被恐惧和忧虑蒙蔽了。过去考虑的总是没有奶酪，或者没有可以维持足够长时间的奶酪。以前总是觉得会把事情做错，而不是考虑把事情做好。</p>
<p>　　在他离开奶酪C站以后的日子里，一切都改变了。 过去他习惯于认为，奶酪决不会被拿走，改变总是不对的。</p>
<p>　　现在，他知道，变化会不断地发生，这是很自然的事情，不管你是否希望如此。只有当你不希望变化，也不想追寻变化的时候，变化才会让你感到吃惊。</p>
<p>当唧唧认识到自己的信念发生了变化时，他停下来，在墙上写道：</p>
<p><strong>陈旧的信念，不会帮助你找到新的奶酪。</strong></p>
<p>　　唧唧还没有找到奶酪，但在迷宫中穿行的时候，唧唧在想自己从中学到了什么。</p>
<p>　　他意识到，他的新的信念鼓舞着他采取新的行动。他的行为再不同于以往，再也不是总想回到同一个没有奶酪的地方。</p>
<p>　　他知道，当你改变了自己的信念，你也就改变了自己的行为。</p>
<p>　　你可以相信，变化对你有害，你可以拒绝它；或者，你会相信寻找新奶酪对你有好处，你会拥抱这种变化。</p>
<p>　　这些取决于你选择相信什么。</p>
<p>　　他在墙上写道：</p>
<p><strong>当你发现，你会找到新的奶酪，并且能够享用它时，你就会改变你的路线。</strong></p>
<p>　　唧唧知道，如果他能够早一些离开奶酪C站，早一点应对这些变化，他现在的状况就会更好一些。他的身体会更强壮，精神也会更坚强，会更好地去迎接挑战;寻找新奶酪的挑战。事实上，如果他不是浪费时间，否认已经发生了的变化，如果他能够期待改变，也许他已经找到奶酪了。 他再一次运用自己的想象力，看见自己正在发现和品尝新奶酪。他决定到更多的地方去，去迷宫中那些他还没有到过的地方。在这些地方，他偶尔找到一些小块的奶酪。唧唧又开始恢复了体力和信心。</p>
<p>　　当他回顾自己是怎么走过来的时候，他很高兴他在很多经过的地方的墙上都留下了字迹。他相信如果哼哼决定离开奶酪C站的话，这就是留给哼哼的路标，能帮助哼哼穿过迷宫。</p>
<p>　　唧唧只是希望自己在朝着正确的方向前进。他还想到了这种可能性—-哼哼将会读到墙上的字迹，并且循着它找到出路。</p>
<p>　　于是他又把这段时间以来他一直在思索着的心得写在了墙上：</p>
<p>　　<strong>尽早注意细小的变化，这将有助于你适应即将来临的更大的变化。</strong></p>
<p>　　此时此刻，唧唧早已把过去抛在脑后，正在适应现在。</p>
<p>　　他继续以更充沛的体力和更快的速度穿越迷宫。不久，期待已久的事情终于发生了。</p>
<p>　　当他感觉一直在迷宫中前行，而且好像永远都会在迷宫中前行的时候，他的旅程—-至少是现阶段的旅程;即将愉快地结束了。</p>
<p>　　唧唧正沿着一条走廊前进，这是一条他从未到过的走廊，拐过一个弯，在他的面前出现了奶酪N站，这里面堆满了新鲜的奶酪！</p>
<p>　　当他走进奶酪N站的时候，他被眼前的景象惊呆了。到处都是堆积如山的奶酪，他从未见过如此巨大的丰盛的贮藏。他并不完全认识这些奶酪，有些品种是全新的。 眼前的景象太壮观了，他犹豫了一会儿，不能肯定这是否是真的，或许这只是他的幻觉。直到他看见了他的老朋友嗅嗅和匆匆，他才相信这一切是真的。</p>
<p>　　嗅嗅冲唧唧点了点头，表示欢迎，匆匆则朝他挥了挥爪子。他们胖胖的小肚子表明，他们在这里已经有一段时间了。</p>
<p>　　唧唧很快向他们打了招呼，然后赶紧把他喜欢的各种奶酪都咬了一口。他脱掉鞋子，把两只鞋子系在一起，然后挂在脖子上，以便需要的时候能够迅速找到它们。嗅嗅和匆匆会心地笑了，并赞许地点了点头。而唧唧已经一头扎进了奶酪堆中。一顿饱餐之后，唧唧高兴地举起一块新鲜的奶酪欢呼：“呼啦。变化万岁！” 唧唧享受新的奶酪是同时，也在反思自己学到了什么。</p>
<p>　　他认识到，当他害怕变化的时候，他一直受困于对那已不复存在的就奶酪的幻想而无法自拔。</p>
<p>　　那又是什么使他发生了改变呢？难道是害怕饿死的恐惧？想到这里，唧唧笑了，他心里明白，这种恐惧当然起过很大的作用。</p>
<p>　　唧唧忽然发现，他已经学会自嘲了，而当人们学会自嘲，能够嘲笑自己的愚蠢和所作的错事时，他们就在开始改变了。他甚至觉得，改变自己的最快捷的方式，就是嘲笑自己的愚笨;这样，你就能对过往云烟轻松释然，迅速行动起来，直面变化。</p>
<p>　　唧唧相信他从他的老鼠朋友嗅嗅和匆匆那里，学到了一些有用的东西;不畏惧改变，勇往直前。老鼠朋友们简单地对待生活，他们不会反复分析，也不会把事情搞得很复杂。当形势发生改变，奶酪被移走了的时候，他们会迅速随之改变，循着奶酪的移动方向而移动。唧唧告诉自己，要牢记这些体会。</p>
<p>　　唧唧相信拥有了这些体会，凭借着自己聪慧的头脑，再遇到任何变化时他一定能够做得比老鼠朋友们更好。</p>
<p>　　他的头脑里出现了清晰的图画，他的生活将会变得更美好，而且他还会在迷宫中发现一些更好的东西。 唧唧不断地反思自己过去犯下的错误，他要汲取这些经验教训，去构划自己的未来。他知道，自己完全可以通过总结和学习，掌握如何应对变化：</p>
<p>　　首先要更清醒地认识到，有时需要简单地看待问题，以及灵敏快速地行动。</p>
<p>　　你不必把事情过分复杂化，或者一味地让那其次必须要善于发现一开始发生的那些细微的变化，以便你为即将来临的更大的变化做好准备。</p>
<p>　　他知道，他需要做出更快的调整。因为，如果不能及时调整自己，就可能永远找不到属于自己的奶酪。 还有一点必须承认，那就是阻止你发生改变的最大的制约因素就是你自己。只有自己发生了改变，事情才会开始好转。</p>
<p>　　最重要的事，新的奶酪始终总是存在于某个地方，不管你是否已经意识到了他的存在。只有当你克服了自己的恐惧念头，并且勇于走出久已习惯的生活，去享受冒险带来的喜悦的时候，你才会得到新奶酪给你的报偿和奖赏。</p>
<p>　　唧唧还认识到，有些畏惧是需要加以认真对待的，它会帮助你避开真正的危险。但绝大部分的恐惧都是不明智的，它们只会在你需要改变的时候，使你回避这种改变。 唧唧曾经那样地惧怕改变，他真的希望生活能够永远按照原有的样子继续，但现在他意识到，生活并不会遵从某个人的愿望发展。改变随时有可能降临，但积极地面对改变却会让你发现更好的奶酪，真的是塞翁失马，焉知非福。</p>
<p>　　唧唧已经看到了变化更好的一面。</p>
<p>　　当他回想起这些自己所学到的东西时，他不由得想起了他的朋友哼哼。他不知道哼哼是否读到了哪些他在奶酪C站和迷宫各个角落墙上的留言，不知道哼哼是否已经走出了迷宫。</p>
<p>　　哼哼是否已经决定放开已经失去的过去并且开始行动？他是否已经重新回到迷宫中。并且发现了能使他的生活变得更好的东西？</p>
<p>　　或者，他因为不肯改变，还在那里迟疑不前？</p>
<p>　　唧唧在考虑回到奶酪C站去，看看是否能找到哼哼—-但首先得肯定自己能找到回来的路。如果找到哼哼，他会把自己学到的东西告诉他，帮助他摆脱困境。但唧唧又想起他已经试图改变过他的失败的经历。</p>
<p>　　哼哼必须自己发现适合自己的道路，摆脱安逸，超越恐惧。没有人可以代替他做到这一点，或者告诉他应该怎样去做。他必须迈出第一步，否则他永远不会看到改变自己所带来的好处。</p>
<p>　　唧唧知道自己已经给哼哼留下了足够的标记，只要他能够迈出第一步，读到墙上的字迹，他就会找到奶酪。 于是唧唧打消了回奶酪C站的念头，他站起来走到奶酪N站最大的一面墙前，把他一路上得到的心得体会的要点写了下来。他拿起一块很大的奶酪，这是他见过的奶酪中最大的一块。唧唧品尝着新鲜的奶酪，望着自己写下的体会，脸上绽出了微笑：</p>
<p>　　&lt;变化总是在发生&gt;</p>
<p>　　他们总是不断地拿走你的奶酪。</p>
<p>　　&lt;预见变化&gt;</p>
<p>　　随时做好奶酪被拿走的准备。</p>
<p>　　&lt;追踪变化&gt;</p>
<p>　　经常闻一闻你的奶酪，以便知道它们什么时候开始变质。</p>
<p>　　&lt;尽快适应变化&gt;</p>
<p>　　越早放弃旧的奶酪，你就会越早享用到新的奶酪。</p>
<p>　　&lt;改 变&gt;</p>
<p>　　随着奶酪的变化而变化。</p>
<p>　　&lt;享受变化&gt;！</p>
<p>　　尝试冒险，去享受新奶酪的美味！</p>
<p>　　&lt;做好迅速变化的准备，不断地去享受变化&gt;</p>
<p>　　记住：他们仍会不断地拿走你的奶酪。　</p>
<p>　　唧唧在想，自从他在奶酪C站和哼哼分道扬镳以来已经有多久了。他知道自己前进了一大步，打他也很清楚，如果他过分沉溺于N区的安逸生活之中，他就会很快滑落到原来的困境。所以，他每天都仔细检查奶酪N站的情况。他在做一切力所能及的事情，以尽量避免被意料之外的变化打个措手不及。</p>
<p>　　当他还有大量的奶酪贮备时，他就开始经常到外面的迷宫中去，他所新的领地，以便自己与周围发生的变化随时保持联系。现在他非常明白，了解各种实际的选择，要比呆在舒适的环境里把自己孤立起来安全的多。 “窸窸窣窣”，他听到什么，唧唧竖起耳朵听了听，他觉得是从迷宫里传来的走动的声音。这声音渐渐大起来，他知道有人正向着这边跑来。</p>
<p>　　会是哼哼到了吗？他会循着那个弯转过来吗？</p>
<p>　　唧唧念了几句祈祷语，他真的希望;像他以前曾多次希望的那样—-也许，他的朋友终于能够……<br>  结局……或者是新的开始？</p>
<hr>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论:"></a>讨论:</h3><p>　　同一天傍晚，故事讲完以后的讨论</p>
<p>　　迈克尔讲完他的故事后，环顾四周，发现他的老同学都在微笑着倾听。</p>
<p>　　有几个人站起身来向他表示感谢，说他们从故事中得到了很多启发。</p>
<p>　　内森问大家：“一会儿我们聚在一起讨论一下这个故事，你们觉得怎样？”</p>
<p>　　大多数人都表示他们的确很想谈一谈自己的感受。于是，他们决定先去喝点东西，再吃晚餐，然后一起讨论这个故事。</p>
<p>　　当天晚上，他们聚集在饭店的房间，相互开着玩笑说，看见他们自己在迷宫中寻找各自的“奶酪”。</p>
<p>　　安杰拉要大家安静下来，并询问道：“你们觉得自己是这故事中的谁？嗅嗅和匆匆，还是哼哼或唧唧？”</p>
<p>　　卡洛斯第一个回答说：“呃，整个下午，我都在考虑这个问题。我清楚地记得，有一段时间，在我开始我的运动器材生产之前，我曾遇到过一次突如其来的改变。”</p>
<p>　　“我不是嗅嗅—-我没能及早嗅出潜在的危机并看出已经发生的变化。我也不像匆匆—–因为我没有立即投入行动。”</p>
<p>　　“我想我更像是哼哼，当时我只愿意呆在自己熟悉的领域。事实上，我根本不想去应对改变，我甚至不想看到变化。” 迈克尔和卡洛斯在学校时是好朋友，现在还是像以前一样亲密，他不解地问道：“兄弟，你所说的那个突然的改变究竟是怎么回事？”</p>
<p>　　卡洛斯说：“那是工作上的一个意想不到的变化。”</p>
<p>　　迈克尔笑起来：“你被开除了？”</p>
<p>　　“噢，还不如说，我只是从来不曾想过要去寻找新的奶酪。我曾经想到很多理由，总觉得变化不应该发生在我身上，老实说，那段时间，我感到非常沮丧。”</p>
<p>　　刚开始的时候，有几位同学一直没有参加讨论，现在听了迈克尔的话也都开始议论。首先是已经应征入伍的弗兰克。</p>
<p>　　“哼哼使我想起了我的一位朋友，”他说：“所有迹象显示他所在的部门将被裁撤，但他不肯面对这个现实。公司为所有人做了重新安排。我们都试图劝说他，只要愿意改变，公司里还有很多其他的机会，但他始终觉得自己没有必要改变。当他所在的部门最终关闭时，他是惟一惊讶得不知所措的人。现在，他正在做出艰难的调整，以适应他应为不该发生的变化。”</p>
<p>　　杰西卡说：“我也一向认为这种事情不会发生在我身上，但我的奶酪已经不止一次地被拿走了，尤其是在我的个人生活中。但最后我总能找到我的奶酪。”</p>
<p>　　除了内森，大家都笑了。</p>
<p>　　“也许，这就是关键之处，”内森说：“变化发生在我们每一个人身上。”</p>
<p>　　他补充道：“我真希望我的家人以前就听到过这个故事。不幸的是，我们第一个人都不愿意面对发生在我们家族企业中的变化。现在为时已晚—–我们不得不关闭我们的许多家店铺了。”</p>
<p>　　内森的话让很多人吃了一惊，因为大家一向都很羡慕内森幸运，认为他可以躺在自己的家族企业中，年复一年地依靠它。</p>
<p>　　“发生了什么事？”杰西卡急于问个究竟。</p>
<p>　　“当超级商场进入小镇时，我们的小型连锁店突然间显得过时了。他们有大量丰富且价格低廉的商品，我们完全与之竞争。”</p>
<p>　　“现在我终于明白了，这一切后果归咎于我的家人都不是嗅嗅和匆匆，我们就象哼哼。我们呆在原来的地方固步自封，拒绝改变；我们故意忽略外面的世界，企图对发生的一切视而不见。现在我们陷入了麻烦，这一要只是因为我们不愿意嘲讽自己，不愿意改变所做的。我们真应该从唧唧身上学到些什么。”</p>
<p>　　劳拉已经是一位很成功的商人，到现在为止，她很少说话，一直在聆听。“这个下午，我也一直在思考这个故事，”这时她说：“我不知自己要怎样做才能更像唧唧，才能够看到自己的错误，坦然面对自己，改变自己，并将一切做得更好。”</p>
<p>　　沉默了一会儿，她继续说：“我想知道，我们这时有多少人害怕改变？”见没有人回答。于是她又提议：“请举手示意。”</p>
<p>　　只有一个人举了手。“很好，看起来，我们之中总算还有一个诚实的人!”她说，并继续道：“也许你们更愿意回答下一个问题。有多少认为别人害怕改变？”这一次几乎每个人都举了手。见此情景，大伙都大笑起来。</p>
<p>　　“刚才的现象说明了什么？”</p>
<p>　　“我们都拒绝承认自己害怕改变。”内森回答。</p>
<p>　　“确实是这样，”迈克尔表示赞同，“有时候，连我们自己也没有意识到我们在害怕，或者说我们在努力想掩盖自己的恐惧。我知道我就是如此，当我第一次听到这个故事的时候，我就非常喜欢这句话，‘当你无所畏惧时，你会怎样’。” 杰西卡接口道：“我从这个故事中得到的启示是，变化无时无处不要发生，无论我们是害怕还是喜欢改变，但如果我们能尽快调整自己适应变化，我们应该可以做得更好。”</p>
<p>　　“我还记得几年前我们公司发生的事情。当时我们正在销售一套百科全书，全套书有二十多本。有个人想要说服我们，他告诉我们应该把整套百科全书做成一张计算机光盘，只卖现在价格的零头。这样做，既可以及时更新，又可以使生产费用大为减少，而且将有更多的人买得起并可以使用它。但是当时我们拒绝了这个建议。”</p>
<p>　　“你们为什么要拒绝呢？”内森问道。</p>
<p>　　“因为当时我们确信，我们企业的主力，是我们挨家挨户地推销的庞大销售队伍，我们的高价产品使我们的销售人员可以获得高额佣金从而更加卖力气地工作。长期以来，我们一直都这样做并且做得很成功，我们都认为这种方式还会继续有效。”</p>
<p>　　劳拉说：“也许这就是故事里所要表明的，哼哼和唧唧由于成功而形成的傲慢。他们从来没有，他们需要改变那些曾经是有效的东西。”</p>
<p>　　“这方法就是你们的奶酪!”内森说：“并且你们认为这块旧奶酪是你们惟一的奶酪。”</p>
<p>　　“的确如此，我们甚至想依靠这种方法直到永远。”</p>
<p>　　“当我回过头去想发生的事情时，我发现，奶酪不仅仅会被移走。奶酪也有自己的生命，终究有被吃完的一天。”</p>
<p>　　“结果怎么样呢？”劳拉问。</p>
<p>　　“我们没有变。一个竞争者做了改变，所以我们的生意一落千丈，一直到现在我们都很艰难。如今，在这个产业领域里技术上已经发生了很大的变化，但我们公司里却没有一个人想去应对这种变化。这看起来很不妙，我想我快要失业了。” </p>
<p>　　“这真是一个迷宫的时代!”卡洛斯忽然叫道。大家都笑了起来，杰西卡也笑了。</p>
<p>　　卡洛斯转向杰西卡说道：“你已经可以坦然地嘲笑你自己了，这很好啊。”</p>
<p>　　弗兰克附和说：“这也是我从故事中得到的体会，我们常常过于认真地看待自己。我注意到在故事里，当唧唧终于能够坦然嘲笑自己错误的过去时，他得到了应对变化的方法。关键就在于要敢于否定自己，勇敢地嘲讽自己做的傻事，难怪他的名字要叫作唧唧。”</p>
<p>　　大家都模仿这个词，发出哼哼唧唧的声音。</p>
<p>　　安杰拉问大家：“你们认为哼哼是否会改变，是否能够找到新的奶酪？”</p>
<p>　　依莱恩说：“我想他会的。” “我认为不会，”柯瑞说：“有的人绝对不肯改变，并为此付出了代价。在我行医的时候，我见过像哼哼这样的人。他们觉得他们天生具备拥有自己的奶酪的资格和权力，当奶酪被拿起以后，他们觉得自己是受害都并为此而指责别人，抱怨能够抱怨的一切。他们比那些最终能够放开自己去行动的人要病得厉害得多。”</p>
<p>　　这时，内森轻轻地、好像自言自语般地说道：“我觉得，真正的问题是，‘我们需要放弃什么，以及应该朝哪里行动？’”</p>
<p>　　好一会儿，大家都不说话。</p>
<p>　　“我必须承认，”内森又说：“当我看到其他地方的商业经营运作方式正在改变时，我完全有时间有能力改变自己去就应对这种变化，然而我们当时只是一厢情愿地认为这种变化不会影响到我们。所以我认为，率先变化比对变化做出反应和调整要强得多。也许，我们应该做的就是移走我们自己的奶酪。” </p>
<p>　　“你的意思是……”弗兰克问。</p>
<p>　　内森回答说：“我不禁在想，如果当初我们卖掉我们商店的不动产，建立一个大型的现代化商场与那些超级商场竞争，结果又会是怎样？”</p>
<p>　　劳拉说：“也许这就是唧唧写在墙上的意思‘尝试冒险，与奶酪一起变动’。”</p>
<p>　　弗兰克说：“我现在认识到，如果我很早就随着我的‘奶酪’移动，我会好得多。但我觉得有些东西是应该保持不变的，例如，我们的基本价值观。”</p>
<p>　　“噢，迈克尔，这真是一个有意义的小故事。”理查德说，他是班上的怀疑论者，“但是，我们究竟应该是怎样把它实际运用到我们的生活中去呢？”</p>
<p>　　大家都不知道，但理查德自己的生活正在经历某些变化。最近，他和妻子离婚了，因此既要做好工作又要照顾好十几岁的孩子。</p>
<p>　　迈克尔回答说：“你知道吗？以前我的工作就是处理每天正在发生的问题。现在我发现实际上我应该做的是，朝前看，把注意力放在我们公司发展的在大方向上，而不是不断地应付眼前的小事。”</p>
<p>　　“我整个人都投入到处理这些枝节问题中去了—-一天二十四小时，感受不到任何乐趣。我陷入老鼠赛跑的圈子，无法跑出来。”</p>
<p>　　“所以，你总是为琐事纠缠无暇喘息，而其实你更应该抽身出来，主动支配时间。”劳拉说。</p>
<p>　　“确实如此。”迈克尔说：“后来，当我听到‘谁动了我的奶酪’的故事后，我认识到我的工作应该是描绘一幅‘新奶酪’的图景—-公司全体员工都希望追寻的‘新奶酪’，然后将这新奶酪清晰、真实地呈现在所有员工的面前。这样，我们才会享受到变化和成功的喜悦，否认是在工作中还是在生活中。”</p>
<p>　　内森问道：“你在工作中是怎样去做的？”</p>
<p>　　“喔，我问我们公司里的人，他们是故事中的谁，发现我们公司中这四种角色都有。我看到了嗅嗅、匆匆、哼哼和唧唧，每一种角色都需要区别对待。”</p>
<p>　　“我们的嗅嗅能够敏锐地嗅出市场的变化，以便我们能够及时调整公司的战略。公司鼓励他们去识别哪些变化会影响顾客对新产品和服务的需求。嗅嗅们喜欢这项工作，他们告诉我，他们喜欢在这样的环境中工作，在这里他们能够识别变化并及时做出调整。”</p>
<p>　　“我们的匆匆喜欢做事，在公司的新战略，在公司的新战略中，他们被鼓励去采取行动。他们只需要稍加引导，以免跑错了方向。公司获得了新奶酪，这应归功于他们的行动。他们喜欢在这样的公司里工作，在这里能够体现行动的结果和价值。”</p>
<p>　　“那么，哼哼们就像是船锚想使我们停下来，”迈克尔说：“他们或者是太在意享受眼前的安逸，或者是过分害怕改变。不过当我向他们展示了具体的景象，并说明变化将会带来的好处时，有些哼哼最终改变了。”</p>
<p>　　“我们的哼哼们说，他们想要在一个安全的环境下工作，所以，变化应在他们所能接受的范围内并增加安全感。然而当我让他们认识到僵化不变的可怕时，其中有些人发生了改变，而且干得不错。这种景象使许多的哼哼变成了唧唧。”</p>
<p>　　“对那些没有改变的哼哼，你们怎么办呢？”弗兰克问道。</p>
<p>　　“我们不得不让他们走人。”迈克尔黯然答道：“我们希望留下所有的员工，但我们清楚，我们必须要迅速而充分地改变，否则我们全体都会陷入麻烦之中。”</p>
<p>　　他又说：“我们的唧唧们起初还有些犹豫，值得欣慰的是，他们思想开放，乐于去学习新的东西，及时调整并付诸实施，从而使我们获得成功。”</p>
<p>　　“他们甚至开始期待变化而且积极地寻求变化。他们了解大家究竟想要什么，和我们一起描绘出一幅实际可行的新奶酪的美景图，让所有的人充满期待并积极行动起来。”</p>
<p>　　“他们说他们希望在这样的组织中工作，能够给人自信和变化的工作。在我们追随新奶酪的过程中，他们还给我们带来了许多迎接挑战的乐趣。”</p>
<p>　　理查德揶揄道：“没想到你从一个小故事中得到了这么多东西？”</p>
<p>　　迈克尔笑了：“因为我并没有仅仅停留在听故事的层面上，而是从中找到了我想要的东西，并且采取了行动。”</p>
<p>　　安杰拉点头表示同意：“这做法真的很有趣。因为在我看来，这故事中最有影响力的部分是，当唧唧勇敢地嘲笑自己的畏惧，开始在头脑中描绘一幅自己在享受新奶酪的情景，然后充满信心和喜悦地走进迷宫，追寻新的奶酪，并最终获得了成功。我想这也是我常常想要做的事情。”</p>
<p>　　弗兰克笑了一下：“所以，甚至哼哼有时也能看到变化的好处。”</p>
<p>　　卡洛斯补充说：“甚至还有得到提拨的好处。”</p>
<p>　　理查德一直皱着眉头若有所思。这时他说：“我的上司一直在告诉我，公司需要有所改变。我想她实际上是想告诉我应该做出某些改变，但我实在不想听到这些。我觉得自己真的不知道，她想让我们去找的‘新奶酪’是什么，或者，我能从那新奶酪中得到些什么。”</p>
<p>　　说到这里，一丝微笑掠过他的脸庞：“听了这个故事我必须承认，我开始喜欢这个想法，看见新的奶酪并想像自己正在享用它。这种想法能使每件事都变得更有希望。当你想到变化能使事情变得更好时，你就会有很大的兴趣去促成变化的发生。”</p>
<p>　　“也许我应该把这些观念和方法运用到我的个人生活中去，”他说：“我的孩子们觉得他们的生活不应该改变。我看他们也有点像哼哼—-当事情发生改变时，他们会愤怒。因为他们不知道改变后会怎么样。这也许是我没有给他们描绘出一幅‘新奶酪’的美景的缘故。也许因为连我自己都害怕变化，连我自己都没有看到那‘新奶酪’的美景吧？”</p>
<p>　　听了这番话，所有人都想到了自己的生活，大家安静下来。</p>
<p>　　“呃，”杰西卡清了清嗓子，打破了宁静，“大家好像都在谈论自己的工作，但是我听到这个故事以后，却想到了我的个人生活。我觉得我目前的情况，我的家庭关系，就像一个‘旧奶酪’，上面长满了霉菌。”</p>
<p>　　柯瑞笑出声来，表示赞同：“我也是，也许我现在最该采取行动的就是让一段不愉快的关系尽快过去。”</p>
<p>　　安杰拉反驳道：“我不同意你的观点，也许这个‘旧奶酪’只是一种旧的方式。我们需要放弃的只是引起这种状态的旧的行为方式，而不是这个‘奶酪’。这样我们才会朝更好的思维和行为方式转变。”</p>
<p>　　“对呀!”柯瑞受到启发，“好观点。新奶酪说是用新的积极的行为方式与一个人建立新关系。”</p>
<p>　　理查德说：“我在想，也许这个故事还有更多有建设性的启发等待我们挖掘。我同意安杰拉的观点—-需要放弃的是旧的行为方式而不是关系本身。一成不变的行为方式还是会导致同样的结果。” “就工作而言，我应该成为帮助公司进行改变的人之一，而不是害怕公司的改变而辞去工作。如果早这么想、早这么做的话，我也许就会有一个更好的职位了。”</p>
<p>　　贝基生活在另一个城市，这次特意赶来参加同学聚会。这时她说：“当我在听这个故事，以及听到大家的讨论时，我真的禁不住要讥笑自己。许久以来，我一直像哼哼那样，害怕改变，凡事迟疑犹豫，拒绝改变，为此我不知道丢掉了多少美味的奶酪。我不知道其他人怎样，我恐怕已经在不得不中，把这种哼哼式的思想传给了我的孩子们。”</p>
<p>　　“当我反复思考这个问题和身边的一些人和事后，我在想或许变化真的能把你一个崭新的、更好的地方，尽管当时你担心事情的变化将并非如此。” “我记得有五段时间，在我儿子上中学二年级的时候。因为我先生工作的需要，我们必须从伊利诺搬到佛蒙特去，儿子为此很难过，因为他不得不离开他的朋友们了。他是学校里的游泳明星，但在佛蒙特的高中里却没有游泳队。因此，他对我们即将面临的变化感到很生气。”</p>
<p>　　“然而后来的情况是，他疯狂地迷上了佛蒙特的山区，开始学习滑雪，并参加了大学的滑雪队和登山队。现在，他有了更多的新伙伴，他愉快地生活在科罗拉多。” “如果当初面对改变时，我们全家能端上一杯热巧克力，一起享受这个故事的乐趣，或许我们家庭中的许多无谓的压力和紧张气氛早就烟消云散了。”</p>
<p>　　杰西卡赶忙说，“没错，我回去后，要把这个故事和全家分享。我还要问我的孩子们，我像故事中的谁—-嗅嗅、匆匆，还是哼哼和唧唧—-他们又觉得自己像谁。我们还要讨论，我们家的‘旧奶酪’是什么，‘新奶酪’又应该是什么。”</p>
<p>　　“这的确是个好主意!”理杰德大声赞同，把大家吓了一跳，连他自己都奇怪怎么会这么大声。</p>
<p>　　弗兰克也受到快乐情绪的感染，喜悦之情溢于言青：“我觉得自己越来越像唧唧，我已经做好准备随着奶酪的移动而移动，并且能够从中得到快乐!我也要把这个故事讲给我这中的朋友们，他们正担心离开部队后生活的变化。这一定会引起一场有趣的讨论。”</p>
<p>　　迈克尔接着说：“对，这也是我们当初改进我们企业的方法。我们搞过几场讨论，讨论我们从故事中学到什么，以及如何把它们运用到我们的实际工作中去。”</p>
<p>　　“这很重要。因为我们有了轻松的、共同的语言，用来谈论怎样应对变化，包括公司的和个人生活的。这方法非常有效，它已经深深地渗入到我们公司的各个方面。”</p>
<p>　　内森问道：“‘深深地’是什么意思？” “喔，是这样的，我们发现，越是组织的内层，就越缺乏活力。可以理解，他们比外层人员更加害怕改变，害怕上面强加给他们的改变会发生在他们身上。所以，他们拒绝改变。”</p>
<p>　　“简言之，强加的改变是最易遭到反抗及阻力的改变。”</p>
<p>　　“当‘奶酪的故事’以书面的形式在我们机构中分发出去以后，它改变了大家看待变化的态度。对于自己过去的畏惧，每个人都笑起来，至少是微笑了。每一个人都开始主动地考虑‘改变’这个题目。”</p>
<p>　　“但我要是能够早点听到‘奶酪’的故事并把它用于公司讨论就好了!”迈克尔加了一句。</p>
<p>　　“为什么？”卡洛斯不理解地问。</p>
<p>　　“因为当我们开始向变化靠拢的时候，我们的企业已经一团糟了。生意一落千丈，我们不得不解雇一些 员工，正如我前面提到的，甚至包括一些好朋友。这对我们大家来说都是一件痛苦的事情。惟一值得欣慰的是，所有留下来的和大多数离去的人都说，奶酪的故事使他们改变了看问题的方式，使他们能够更好地对付各种局面。”</p>
<p>　　“那些离开公司，出去找新工作的人说，开始时确实很艰难，但是，每每回想起这个故事，就会得到极大的帮助。”</p>
<p>　　安杰拉问道：“对他们最大的帮助是什么？”</p>
<p>　　迈克尔回答：“他们告诉我，超越自己的恐惧的最大好处是，他们认识到外面到处有新奶酪等着被发 现，只要他们愿意去寻找。”</p>
<p>　　“他们说，头脑中存有一幅新奶酪的景像—-看见自己在新的工作中干得很好—-会使他们的感觉好一些。尤其是使他们在面试的时候表现得更为出色。有些人还因此得到了比原来更好的工作。”</p>
<p>　　劳拉问：“那些留在公司的人又怎么样了呢？”</p>
<p>　　“噢，”迈克尔说：“人们不再抱怨市场环境正在发生的种种变化。他们说‘既然我们的旧奶酪已经不见了，那么让我们去找新的奶酪吧。’这省去了公司许多的协调时间，也减少了公司内部的紧张感和压力。”</p>
<p>　　“不久前还完全拒绝变化的人，如今也透过这个小故事看到了变化的好处。他们越来越喜欢变化，并且积极创造有利于公司发展的变化。”</p>
<p>　　柯瑞说：“是什么使得他们改变了呢？”</p>
<p>　　“我认为这和公司里面存在的同事之间的相互影响力有关系，”迈克尔答道：“如果这种影响力改变了，人们就会跟着发生改变。”</p>
<p>　　“大家可以回想一下，在你呆过的机构里面，当上级宣布一项改变时，大多数人会有什么反应？大多数人会说这改变是一个好主意还是一个坏主意？”</p>
<p>　　“一个坏主意。”弗兰克答道。</p>
<p>　　“没错。”迈克尔表示同意，又接着问道：“为什么会这样呢？”</p>
<p>　　卡洛斯说：“我想因为大多数人都喜欢稳定和有安全感，他们觉得改变会带给自己麻烦甚至有可能对自己不得。当有一个人说这种改变是一个坏主意时，其他人通常会随声附和。”</p>
<p>　　“的确如此，但这些随声附和的人在心里也许并不真的这样认为。”迈克尔说：“只是他们为了看起来和最先提议反对的那个人一样聪明以及显得合群，就会随声附和。这就是我所说的同事之间的相互影响力。这种影响力通常会阻碍机构中发生的变化。”</p>
<p>　　贝基问道：“那么当人们听到奶酪的故事以后，情况又怎么样了？”</p>
<p>　　迈克尔耸了耸肩膀，轻松地说：“情况是同事之间的相互影响力改变了，因为大家都不希望自己被别人叫作哼哼!”</p>
<p>　　大家听了都哈哈大笑了起来。</p>
<p>　　“他们都想提前嗅出变化的味道，并且赶快投入行动，而不再是落在后头哼哼不停。”</p>
<p>　　内森说：“这是一个好点子。我想我们家的人也都不愿做哼哼，他们很可能也会因为这个故事而改变。上一次同学聚会时，你为什么没有告诉我们这个故事？要不然，它早起作用了。”</p>
<p>　　“它确实有用。”迈克尔说。</p>
<p>　　“而且非常有用!尤其是当你的机构中的每个人都知道它时—-不管是大公司，还是小企业，或者是你的家庭—-因为，只有当其中的多数人的心态发生改变以后，一个组织才会发生变化。”</p>
<p>　　最后，迈克尔又给大家介绍了一个经验：“当这个故事对我的公司起作用以后，我们便把这故事告诉给那些我们希望能和他们在生意上有所合作的人，因为我们知道任何一个公司都正面临变化和选择。我们提议说，也许我们就是他们正在找寻的‘新奶酪’，也就是说，我们可能就是能让他们的生意更成功的合作伙伴。这方法的确为我们带来了许多新的机会和生意。”</p>
<p>　　这番话使杰西卡受到启发，她想起明天上午要谈的几笔业务。她赶紧看了看时间，说：“喔，时间到了，该是我离开这个奶酪站，去寻找新的奶酪的时候了。”</p>
<p>　　大家都会心地笑了起来，然后站起身来互道晚安。尽管许多人觉得兴犹未尽，还想继续聊这个话题，但时间的确已经不早了。分手的时候，他们再一次感谢迈克尔。</p>
<p>　　迈克尔说：“我非常高兴你们觉得这个故事对你们有所帮助，我也衷心希望你们有机会尽快与别人分享这个故事。”</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
</search>
