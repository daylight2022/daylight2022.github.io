<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A* 算法</title>
    <url>/archives/8ec8a19a.html</url>
    <content><![CDATA[<p><img data-src="https://i.loli.net/2021/10/28/UvuOAae9QGZ2FmN.png"></p>
<p>A Star 算法是一种很常用的路径查找和图形遍历算法。利用当前与问题有关的信息作为启发式信息，有效提升查找效率，具有较好的性能和准确度。</p>
<span id="more"></span>

<p>A*算法通过下面这个函数来计算每个节点的优先级。</p>
<p>$f(n) = g(n) + h(n)$</p>
<ul>
<li>f(n) 是节点 n 的综合优先级，我们总会选取 f(n) 最小的值（优先级最高）的下一个节点，也因此 A* 算法会借助<strong>优先队列</strong>来实现；</li>
<li>g(n) 是节点 n 距离起点的代价；</li>
<li>h(n) 是节点 n 距离终点的估计代价，也是 A* 算法的启发函数</li>
</ul>
<p>A* 算法具有两个性质：</p>
<ul>
<li><p>如果对于任意的节点 $x$，$H(x) \leq H^*(x)$  恒成立，即我们「估计」出的从节点 $x$ 到终点 $t$ 的最短路径长度总是不超过「实际」的最短路径长度，那么称启发函数 $H(x)$ 是可接纳的（admissible heuristic）。在这种情况下，$A*$ 算法一定能找到最短路，但同一节点可能需要加入优先队列并搜索多次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 并不一定等于从起点到节点 $x$ 的「实际」最短路径的长度；</p>
</li>
<li><p>如果对于任意的两个节点 $x$ 和 $y$，并且 $x$ 到 $y$ 有一条长度为 $D(x, y)$ 的有向边，$H(x)−H(y)≤D(x,y)$ 恒成立，并且 $H(t)=0$，那么称启发函数 $H(x)$ 是一致的（consistent heuristic）。可以证明，一致的启发函数一定也是可接纳的。在这种情况下，同一节点只会被加入优先队列一次，并搜索不超过一次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 一定等于从起点到节点 $x$ 的「实际」最短路径的长度。</p>
</li>
</ul>
<p>算法描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frontier &#x3D; PriorityQueue()</span><br><span class="line">frontier.put(start, 0)</span><br><span class="line">came_from &#x3D; dict()</span><br><span class="line">cost_so_far &#x3D; dict()</span><br><span class="line">came_from[start] &#x3D; None</span><br><span class="line">cost_so_far[start] &#x3D; 0</span><br><span class="line"></span><br><span class="line">while not frontier.empty():</span><br><span class="line">   current &#x3D; frontier.get()</span><br><span class="line"></span><br><span class="line">   if current &#x3D;&#x3D; goal:</span><br><span class="line">      break</span><br><span class="line">   </span><br><span class="line">   for next in graph.neighbors(current):</span><br><span class="line">      new_cost &#x3D; cost_so_far[current] + graph.cost(current, next)</span><br><span class="line">      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:</span><br><span class="line">         cost_so_far[next] &#x3D; new_cost</span><br><span class="line">         priority &#x3D; new_cost + heuristic(goal, next)</span><br><span class="line">         frontier.put(next, priority)</span><br><span class="line">         came_from[next] &#x3D; current</span><br></pre></td></tr></table></figure>

<p>作为启发式函数的 h(n)，以八数码问题为例，可以使用曼哈顿距离作为启发搜索条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def heuristic(a, b):</span><br><span class="line">   # Manhattan distance on a square grid</span><br><span class="line">   return abs(a.x - b.x) + abs(a.y - b.y)</span><br></pre></td></tr></table></figure>

<hr>
<p>下面以 LeetCode 第 773 题为例</p>
<p>在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.<br>一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.<br>最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。<br>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 </p>
<p>示例：</p>
<blockquote>
<p>输入：board = [[1,2,3],[4,0,5]]<br>输出：1<br>解释：交换 0 和 5 ，1 步完成</p>
<p>输入：board = [[1,2,3],[5,4,0]]<br>输出：-1<br>解释：没有办法完成谜板</p>
<p>输入：board = [[4,1,2],[5,0,3]]<br>输出：5<br>解释：<br>最少完成谜板的最少移动次数是 5 ，<br>一种移动路径:<br>尚未移动: [[4,1,2],[5,0,3]]<br>移动 1 次: [[4,1,2],[0,5,3]]<br>移动 2 次: [[0,1,2],[4,5,3]]<br>移动 3 次: [[1,0,2],[4,5,3]]<br>移动 4 次: [[1,2,0],[4,5,3]]<br>移动 5 次: [[1,2,3],[4,5,0]]<br>输入：board = [[3,2,4],[1,5,0]]<br>输出：14</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>board 是一个如上所述的 2 x 3 的数组.<br>board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>启发函数 $H(status)= \sum_{i=1}^5(status中数字 i 的位置与目标状态中数字 i 的位置之间的曼哈顿距离)$</p>
<p>我们同时可以预处理出任意两个位置的曼哈顿距离，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AStar</span>:</span></span><br><span class="line">    DIST = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算启发函数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getH</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">if</span> status[i] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                ret += AStar.DIST[i][<span class="built_in">int</span>(status[i]) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, status: <span class="built_in">str</span>, g: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.status = status</span><br><span class="line">        self.g = g</span><br><span class="line">        self.h = AStar.getH(status)</span><br><span class="line">        self.f = self.g + self.h</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other: <span class="string">&quot;AStar&quot;</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.f &lt; other.f</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slidingPuzzle</span>(<span class="params">self, board: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># board 压缩成一维数组，记录砖瓦的 neighbor index</span></span><br><span class="line">        neighbor = [[<span class="number">1</span>, <span class="number">3</span>],[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>],[<span class="number">1</span>, <span class="number">5</span>],[<span class="number">0</span>, <span class="number">4</span>],[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],[<span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line">        <span class="comment"># 获取 status 操作一次后的所有状态</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; Generator[str, <span class="keyword">None</span>, <span class="keyword">None</span>]:</span></span><br><span class="line">            s = <span class="built_in">list</span>(status)</span><br><span class="line">            x = s.index(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> neighbor[x]:</span><br><span class="line">                s[x], s[y] = s[y], s[x]</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br><span class="line">                s[x], s[y] = s[y], s[x]</span><br><span class="line"></span><br><span class="line">        target = <span class="string">&#x27;123450&#x27;</span></span><br><span class="line">        start = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> i <span class="keyword">in</span> board <span class="keyword">for</span> x <span class="keyword">in</span> i])</span><br><span class="line">        <span class="keyword">if</span> start == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [AStar(start, <span class="number">0</span>)]</span><br><span class="line">        visited = <span class="built_in">set</span>(start)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">for</span> next_status <span class="keyword">in</span> get(node.status):</span><br><span class="line">                <span class="keyword">if</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">if</span> next_status == target:</span><br><span class="line">                        <span class="keyword">return</span> node.g + <span class="number">1</span></span><br><span class="line">                    heapq.heappush(q, AStar(next_status, node.g + <span class="number">1</span>))</span><br><span class="line">                    visited.add(next_status)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Ctrl + D</title>
    <url>/archives/49905.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/06/06/IPuV6z1y24rSGws.png"  />

<center>聚合各领域链接，资源、博客、工具、素材等</center>

<span id="more"></span>

<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul>
<li><a href="https://material.io/">Material Design</a></li>
<li><a href="https://www.uplabs.com/material">Material Design, Daily - MaterialUp - MaterialUp</a></li>
<li><a href="https://www.uplabs.com/">Uplabs</a></li>
<li><a href="https://github.com/feelschaotic/AndroidKnowledgeSystem">AndroidKnowledgeSystem</a></li>
<li><a href="https://github.com/LisaDziuba/Awesome-Design-Tools">Awesome-Design-Tools</a></li>
<li><a href="https://github.com/wasabeef/awesome-android-ui">Awesome-Android-UI</a></li>
<li><a href="http://www.jcodecraeer.com/">泡在网上的日子</a></li>
<li><a href="http://www.see-source.com/">看源社区</a></li>
<li><a href="https://www.qcgzxw.cn/">小文’s blog</a></li>
<li><a href="https://github.com/FishInWater-1999/android_interviews">android interviews </a></li>
<li><a href="https://www.25xt.com/appdesign/12385.html">网易云音乐视觉设计规范文档</a></li>
</ul>
<h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><ul>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN">计算机免费书籍</a></li>
<li><a href="https://codepen.io/">CodePen</a></li>
<li><a href="https://codelabs.developers.google.com/">Codelabs</a></li>
<li><a href="https://codingpy.com/books/thinkpython2/index.html">Think Python 2e</a></li>
<li><a href="https://github.com/kdn251/interviews">interviews</a></li>
<li><a href="https://github.com/gto76/python-cheatsheet">python 语法速查</a></li>
<li><a href="https://blog.csdn.net/andrewniu/article/details/80566277">汇编语言指令</a></li>
<li><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">Best-websites-a-programmer-should-visit</a></li>
</ul>
<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><ul>
<li><a href="https://cangshui.net/">沧水的博客</a></li>
<li><a href="http://www.spiderpy.cn/blog/">烂笔头-博客</a></li>
<li><a href="https://github.com/b3log">B3log</a></li>
<li><a href="http://typecho.org/">typech0</a></li>
<li><a href="https://www.qcgzxw.cn/">小文‘s blog</a></li>
<li><a href="http://lovenight.github.io/">岁月如歌</a></li>
<li><a href="https://www.dogfight360.com/blog/">羽翼城个人博客</a></li>
</ul>
<h2 id="短视频素材"><a href="#短视频素材" class="headerlink" title="短视频素材"></a>短视频素材</h2><p><strong>视频素材</strong></p>
<ul>
<li><a href="https://www.videvo.net/">videvo</a></li>
<li><a href="https://www.free-video-footage.com/">free-video</a></li>
<li><a href="https://www.jijidown.com/">唧唧-b站视频下载</a></li>
<li><a href="https://www.pexels.com/videos">pexels</a></li>
<li><a href="https://www.videezy.com/">videezy</a></li>
</ul>
<p><strong>图片素材</strong></p>
<ul>
<li><a href="https://www.pexels.com/videos">pexels</a></li>
<li><a href="https://www.lanrentuku.com/">懒人图库</a></li>
<li><a href="https://www.unsplash.com/">Unsplash</a></li>
<li><a href="https://www.hippopx.com/">Hippopx</a></li>
<li><a href="https://www.colorhub.me/">ColorHub</a></li>
<li><a href="https://www.foodiesfeed.com/">Foodiefeed</a></li>
</ul>
<p><strong>音频素材</strong></p>
<ul>
<li><a href="https://www.audiolibrary.com.co/">Audio Library</a></li>
<li><a href="sourl.cn/hthUQX">Adobe Audition</a></li>
<li><a href="https://freemusicarchive.org/search">Free Music Archive</a></li>
<li><a href="https://www.aigei.com/">爱给网</a></li>
<li><a href="https://www.ear0.com/">耳聆网</a></li>
<li><a href="https://1soundfx.com/">1Soundfx</a></li>
</ul>
<p><strong>文案脚本素材</strong></p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://www.juben98.com/">剧本网</a></li>
<li><a href="https://link.zhihu.com/?target=http://www.juben108.com/">原创剧本网</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.1bianju.com/">华语编剧网</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.juben68.com/">剧本联盟</a></li>
</ul>
<p><strong>选题素材来源</strong></p>
<ul>
<li>百度搜索风云榜</li>
<li>百度指数</li>
<li>微博热搜</li>
<li>新媒体管家—热点中心</li>
<li>TooBigData</li>
<li>微信指数</li>
</ul>
<h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ul>
<li><a href="https://blog.csdn.net/wenxuhonghe">博客-爬虫</a></li>
<li><a href="https://github.com/Kr1s77/Python-crawler-tutorial-starts-from-zero">python-crawler-tutorial</a></li>
<li><a href="https://github.com/Kr1s77/awesome-python-login-model">awesome-python-login</a></li>
</ul>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul>
<li><a href="https://github.com/youzan/vant-weapp">Vant Weapp</a></li>
<li><a href="https://github.com/Tencent/weui/">WeUI</a></li>
<li><a href="https://github.com/Tencent/wepy">Wepy</a></li>
<li><a href="https://github.com/alsey/wxbarcode">条码、二维码</a></li>
<li><a href="https://github.com/jasondu/wxa-plugin-canvas/">二维码海报</a></li>
<li><a href="https://github.com/gooking/apifm-wxapi">api接口</a></li>
</ul>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul>
<li><a href="http://www.nicetool.net/">在线工具大全</a></li>
<li><a href="http://magnet.chongbuluo.com/">资源搜索</a></li>
<li><a href="https://www.appinn.com/">小众软件</a></li>
<li><a href="https://yunpanzhushou.com/">云盘助手</a></li>
<li><a href="http://www.mvcat.com/">电影推荐-MVCAT</a></li>
<li><a href="https://kepler.gl/">地图可视化编辑器</a></li>
<li><a href="https://shields.io/">Shields.io/</a></li>
<li><a href="https://wangyasai.github.io/Stars-Emmision/">Star Emmision</a></li>
<li><a href="https://magi.com/">Magi</a></li>
<li><a href="https://www.wenshushu.cn/">文叔叔</a></li>
<li><a href="https://6pan.cn/">6pan</a></li>
<li><a href="https://codeif.xinke.org.cn/">CodeIF-代码命名</a></li>
<li><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji</a></li>
<li><a href="https://www.nocmd.com/">NoCmd</a></li>
<li><a href="https://github.com/NGC-HenryLee/NGC.SS.JJ/">jj</a></li>
<li><a href="https://cowtransfer.com/">奶牛快传</a></li>
<li><a href="https://www.logosc.cn/">LOGO神器</a>(F12找logo对应svg代码，右键copy element)</li>
<li><a href="https://github.com/iptv-org/iptv">iptv</a></li>
<li><a href="https://uigradients.com/">渐变色</a></li>
<li><a href="https://github.com/bannedbook/fanqiang">fanqiang</a></li>
<li><a href="https://www.linshiyouxiang.net/">临时邮箱</a></li>
<li><a href="https://encycolorpedia.cn/">十六进制代码颜色表</a></li>
<li><a href="https://xbeibeix.com/api/bilibili/">B站视频下载</a></li>
<li><a href="https://www.maxthon.cn/mx5/uumail/">百变邮箱</a></li>
<li><a href="https://steamworkshopdownloader.io/">创意工坊下载</a></li>
<li><a href="https://afcano.com/">英文起名</a></li>
<li><a href="http://t.cn/AiT9X7mV">代码截图 Chrome 应用</a></li>
<li><a href="https://carbon.now.sh/">代码截图</a></li>
<li><a href="https://sketchviz.com/new">手绘图</a></li>
</ul>
<h2 id="开眼"><a href="#开眼" class="headerlink" title="开眼"></a>开眼</h2><ul>
<li><a href="http://ddrk.me/">低端影视</a></li>
<li><a href="https://tophub.today/">今日热榜</a></li>
<li><a href="https://www.cheat8.com/">奇特吧</a></li>
<li><a href="https://getitfree.cn/">正版中国</a></li>
<li><a href="http://yx.bsh.me/">异星</a></li>
<li><a href="https://www.ghpym.com/category/all/android/xposed">果核剥壳</a></li>
<li><a href="https://5kindle.com/">子午书简</a></li>
<li><a href="https://www.overwolf.com/">Overwolf</a></li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li><a href="https://zhutix.com/">致美化</a></li>
<li><a href="https://www.25xt.com/">25学堂-ui素材</a></li>
<li><a href="https://huaban.com/">花瓣网</a></li>
<li><a href="https://github.com/Tencent/QMUI_Android">QMUI_Android</a></li>
<li><a href="https://www.canva.cn/templates/">Canva</a></li>
</ul>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><ul>
<li><p><a href="https://github.com/xtaci/algorithms">C++</a></p>
</li>
<li><p><a href="https://github.com/trekhleb/javascript-algorithms">Javascript</a></p>
</li>
<li><p><a href="https://github.com/TheAlgorithms/Python">Python</a></p>
</li>
</ul>
<h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul>
<li><a href="https://www.awesomes.cn/">Web前端开发资源库</a></li>
<li><a href="https://css-tricks.com/centering-css-complete-guide/">CSS居中</a></li>
<li><a href="https://www.30secondsofcode.org/css/p/1">30 Seconds of CSS</a></li>
<li><a href="https://www.patreon.com/onlinetutorials/posts">Online Tutorials(Paid)</a></li>
</ul>
<p><strong>Vue</strong></p>
<ul>
<li><a href="https://www.jeffjade.com/2017/03/11/120-how-to-write-vue-better/#fromHistory">如何写一手漂亮的Vue</a></li>
<li><a href="https://ppt.baomitu.com/d/52096df3#/1">Vue2.x 开发Web应用 – ppt</a></li>
</ul>
<h2 id="Art"><a href="#Art" class="headerlink" title="Art"></a>Art</h2><ul>
<li><p><a href="https://logo.shapefactory.co/">Logo by ShapeFactor</a></p>
</li>
<li><p><a href="https://www.artic.edu/collection">Discover Art &amp; Artists</a></p>
</li>
<li><p><a href="https://unsplash.com/">Unsplash</a></p>
</li>
<li><p><a href="https://www.deviantart.com/">DeviantArt</a></p>
</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git 教程</a></li>
<li><a href="https://learngitbranching.js.org/">Git 练习平台</a></li>
</ul>
<h2 id="Articles"><a href="#Articles" class="headerlink" title="Articles"></a>Articles</h2><ul>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926">MVP</a></li>
<li><a href="https://www.jianshu.com/p/e7d5c7bda783">EventBus</a></li>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083">RxJava</a></li>
<li><a href="https://mp.weixin.qq.com/s/UAEgdC2EtqSpEqvog0aoZQ">RxJava系列</a></li>
<li><a href="https://www.jianshu.com/p/6d1d063e0148">Context</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包</a></li>
<li><a href="https://muyangmin.github.io/glide-docs-cn/">Glide</a></li>
</ul>
<h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><ul>
<li><a href="http://www.secha.net/">找色差</a></li>
<li><a href="https://www.wuziqi.org.cn/">五子棋</a></li>
<li><a href="https://www.heibaiqi.com.cn/">黑白棋</a></li>
<li><a href="http://www.2043.cn/">2048</a></li>
<li><a href="https://www.yibilian.cn/">一笔连</a></li>
<li><a href="https://www.hannuota.cn/">汉诺塔</a></li>
</ul>
<h2 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h2><ul>
<li><a href="https://github.com/JessYanCoding/AndroidAutoSize">屏幕适配</a></li>
<li><a href="https://github.com/Justson/AgentWeb">WebView</a></li>
<li><a href="https://github.com/dwqs/blog/issues/51">vue中优雅使用第三方库</a></li>
</ul>
]]></content>
      <categories>
        <category>Favorite</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>AC自动机</title>
    <url>/archives/5c28c80e.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/24/LkDRBtW8EFIz17y.jpg" style="zoom:50%;" />

<p>如何用多模式串匹配实现敏感词过滤功能？</p>
<span id="more"></span>

<p>实际上，这些功能最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。如果有，就用“***”把它替代掉。</p>
<p>前面讲过好几种字符串匹配算法了,但是，对于访问量巨大的网站来说，比如淘宝，用户每天的评论数有几亿、甚至几十亿。这时候，我们对敏感词过滤系统的性能要求就要很高。那如何才能实现一个高性能的敏感词过滤系统呢？这就要用到今天的多模式串匹配算法。</p>
<h3 id="基于单模式串和-Trie-树实现的敏感词过滤"><a href="#基于单模式串和-Trie-树实现的敏感词过滤" class="headerlink" title="基于单模式串和 Trie 树实现的敏感词过滤"></a>基于单模式串和 Trie 树实现的敏感词过滤</h3><p>字符串匹配算法，有 BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树。前面四种算法都是单模式串匹配算法，只有 Trie 树是多模式串匹配算法。</p>
<p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p>
<p>尽管，单模式串匹配算法也能完成多模式串的匹配工作。但是，这样做的话，每个匹配过程都需要扫描一遍用户输入的内容。整个过程下来就要扫描很多遍用户输入的内容。如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那我们就需要扫描几千遍这样的输入内容。很显然，这种处理思路比较低效。</p>
<p>多模式匹配算法在这个问题的处理上就很高效了。它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p>
<p>我们可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，那我们只需要动态更新一下 Trie 树就可以了。</p>
<p>当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p>
<p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？这就要用到 AC 自动机算法了。</p>
<h3 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。其实，Trie 树跟 AC 自动机之间的关系，就像单串匹配中朴素的串匹配算法，跟 KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，<strong>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">char</span> data; </span><br><span class="line">  <span class="keyword">public</span> AcNode[] children = <span class="keyword">new</span> AcNode[<span class="number">26</span>]; <span class="comment">// 字符集只包含a~z这26个字符</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>; <span class="comment">// 结尾字符为true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> length = -<span class="number">1</span>; <span class="comment">// 当isEndingChar=true时，记录模式串长度</span></span><br><span class="line">  <span class="keyword">public</span> AcNode fail; <span class="comment">// 失败指针</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AcNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AC 自动机的构建，包含两个操作：</p>
<ul>
<li>将多个模式串构建成 Trie 树；</li>
<li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li>
</ul>
<p>重点看下，<strong>构建好 Trie 树之后，如何在它之上构建失败指针?</strong></p>
<p>这里有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p>
<img data-src="https://i.loli.net/2021/08/24/8icgp6rBCk2Rdsj.jpg" style="zoom:50%;" />

<p>假设我们沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p>
<p>这里的最长可匹配后缀子串，解释一下。字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p>
<p>我们从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。我们将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点。</p>
<img data-src="https://i.loli.net/2021/08/24/sAqD4aPIWNQBCiF.jpg" style="zoom:50%;" />

<p>如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。我们可以逐层依次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历树的过程。</p>
<p>首先 root 的失败指针为 NULL，也就是指向自己。<strong>当我们已经求得某个节点 p 的失败指针之后，如何寻找它的子节点的失败指针呢？</strong></p>
<p>我们假设节点 p 的失败指针指向节点 q，我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p>
<img data-src="https://i.loli.net/2021/08/24/gezXtKb72xWDqFN.jpg" style="zoom:50%;" />

<p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针，这里有没有很像 KMP 算法里求 next 的过程？），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p>
<img data-src="https://i.loli.net/2021/08/24/uWMzIFU3gePGfki.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFailurePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  root.fail = <span class="keyword">null</span>;</span><br><span class="line">  queue.add(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    AcNode p = queue.remove();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">      AcNode pc = p.children[i];</span><br><span class="line">      <span class="keyword">if</span> (pc == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (p == root) &#123;</span><br><span class="line">        pc.fail = root;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AcNode q = p.fail;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">          AcNode qc = q.children[pc.data - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">          <span class="keyword">if</span> (qc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pc.fail = qc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          q = q.fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">          pc.fail = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.add(pc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后构建完成之后的 AC 自动机就是下面这个样子：</p>
<img data-src="https://i.loli.net/2021/08/24/7Or954NY2ojnCLf.jpg" style="zoom:50%;" />

<p>构建完后，<strong>如何在 AC 自动机上匹配主串？</strong></p>
<p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p>
<ul>
<li>如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，你可以结合代码看。处理完之后，我们将 i 加一，继续这两个过程；</li>
<li>如果 p 指向的节点没有等于 b[i]的子节点，那失败指针就派上用场了，我们让 p=p-&gt;fail，然后继续这 2 个过程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123; <span class="comment">// text是主串</span></span><br><span class="line">  <span class="keyword">int</span> n = text.length;</span><br><span class="line">  AcNode p = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> idx = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p.children[idx] == <span class="keyword">null</span> &amp;&amp; p != root) &#123;</span><br><span class="line">      p = p.fail; <span class="comment">// 失败指针发挥作用的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p.children[idx];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) p = root; <span class="comment">// 如果没有匹配的，从root开始重新匹配</span></span><br><span class="line">    AcNode tmp = p;</span><br><span class="line">    <span class="keyword">while</span> (tmp != root) &#123; <span class="comment">// 打印出可以匹配的模式串</span></span><br><span class="line">      <span class="keyword">if</span> (tmp.isEndingChar == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i-tmp.length+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配起始下标&quot;</span> + pos + <span class="string">&quot;; 长度&quot;</span> + tmp.length);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = tmp.fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AC 自动机实现的敏感词过滤系统，是否比单模式串匹配方法更高效呢？</strong></p>
<p>，Trie 树构建的时间复杂度是 O(m*len)，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。那构建失败指针的时间复杂度是多少呢？我这里给出一个不是很紧确的上界。</p>
<p>假设 Trie 树中总的节点个数是 k，每个节点构建失败指针的时候，（可以看下代码）最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。整个失败指针的构建过程就是 O(k*len)。</p>
<p>不过，AC 自动机的构建过程都是预先处理好的，构建好之后，并不会频繁地更新，所以不会影响到敏感词过滤的运行效率。</p>
<p><strong>用 AC 自动机做匹配的时间复杂度是多少？</strong></p>
<p>跟刚刚构建失败指针的分析类似，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 O(n)，所以 AC 自动机做敏感词过滤，性能非常高。</p>
<p>你可以会说，从时间复杂度上看，AC 自动机匹配的效率跟 Trie 树一样啊。实际上，因为失效指针可能大部分情况下都指向 root 节点，所以绝大部分情况下，在 AC 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度。只有在极端情况下，如图所示，AC 自动机的性能才会退化的跟 Trie 树一样。</p>
<img data-src="https://i.loli.net/2021/08/24/dCR25hBlzAqXUea.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel 使用技巧</title>
    <url>/archives/740b22a4.html</url>
    <content><![CDATA[<h3 id="源数据表"><a href="#源数据表" class="headerlink" title="源数据表"></a>源数据表</h3><ul>
<li>一维数据</li>
<li>一个标题行</li>
<li>字段分类清晰</li>
<li>数据属性完整</li>
<li>数据连续</li>
<li>无合并单元格</li>
<li>无合计行</li>
<li>无分隔行 / 列</li>
<li>数据区域中无空白单元格</li>
<li>单元格内容禁用短语或句子</li>
</ul>
<span id="more"></span>

<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="移动行列位置"><a href="#移动行列位置" class="headerlink" title="移动行列位置"></a>移动行列位置</h4><ul>
<li>选中行或列后，按 Shift 拖动到指定行列位置</li>
</ul>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>Ctrl + Enter  批量修改单元格</li>
<li>Ctrl + ;  当前日期</li>
<li>Ctrl + Shift + ;  当前时间 16:10</li>
<li>Alt + =  自动求和</li>
<li>Ctrl + A   输入函数名称后，调出函数面板</li>
<li>Shift + F3  插入函数</li>
<li>F2  使单元格进入编辑状态</li>
<li>F4  使单元格引用在相对、绝对、混合引用中循环切换</li>
<li>F9  是Excel进行一次计算，对象可以是引用数据区域，函数或公式</li>
<li>Ctrl + `  公式单元格从显示结果切换到显示公式</li>
</ul>
<h4 id="批量取消合并单元格"><a href="#批量取消合并单元格" class="headerlink" title="批量取消合并单元格"></a>批量取消合并单元格</h4><ul>
<li>选中数据点击取消合并单元格</li>
<li>F5定位空值数据</li>
<li>输入公式 “=B2”（当前单元格上一格坐标）</li>
<li>Ctrl + Enter 批量录入 </li>
</ul>
<h4 id="“切”和“拼”"><a href="#“切”和“拼”" class="headerlink" title="“切”和“拼”"></a>“切”和“拼”</h4><ul>
<li>切：数据 &gt; 分列</li>
<li>拼：=B2&amp;C2</li>
</ul>
<h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><ul>
<li>=A2=TODAY()</li>
</ul>
<blockquote>
<p>确保当天录入数据，结合保护工作表可防止修改（exc. 修改计算机日期可以达目的）</p>
</blockquote>
<ul>
<li>=LEN(A1)&lt;&gt;0</li>
</ul>
<blockquote>
<p>但A1单元格有数据时才允许录入，确保数据按序录入</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="VLOOKUP"><a href="#VLOOKUP" class="headerlink" title="VLOOKUP"></a>VLOOKUP</h4><p> VLOOKUP (要查找的项、要查找位置、包含要返回的值的单元格区域中的列号、返回近似或精确匹配 - 指示为 1/TRUE 或 0/FALSE)  </p>
<ul>
<li>普通查找</li>
</ul>
<blockquote>
<p>=VLOOKUP(E2,$B$1:$C$15,2,0) </p>
</blockquote>
<ul>
<li>屏蔽错误值查找</li>
</ul>
<blockquote>
<p>=IFERROR(VLOOKUP(E2,$A$1:$C$15,3,0),”查找不到”) </p>
</blockquote>
<ul>
<li>逆向查找</li>
</ul>
<blockquote>
<p>=VLOOKUP(E2,IF({1,0},$B$2:$B$15,$A$2:$A$15),2,0)<br>IF{1,0}，就是把1对应的范围和0对应的范围组合成新的区域。 </p>
</blockquote>
<ul>
<li>按顺序返回多列值内容</li>
</ul>
<blockquote>
<p>=VLOOKUP($E2,$A$1:$C$15,COLUMN(B1),0) </p>
</blockquote>
<ul>
<li>多条件查询</li>
</ul>
<blockquote>
<p>=VLOOKUP(E2&amp;F2,IF({1,0},$A$2:$A$15&amp;$B$2:$B$15,$C$2:$C$15),2,0)<br>此处的IF{1,0}的用法是把A2:A15及B2:B5的区域合并成一个区域使用 </p>
</blockquote>
<ul>
<li>一对多查询</li>
</ul>
<blockquote>
<p>查询一个部门对应所有人员数<br>首先添加辅助列， =B2&amp;COUNTIF($B$2:B2,B2) ，确保用 VLOOKUP 函数查找值是唯一的=IFERROR(VLOOKUP($G$2&amp;ROW(A1),$A$1:$C$27,3,0),””) </p>
</blockquote>
<ul>
<li>VLOOKUP + Match</li>
</ul>
<blockquote>
<p>MATCH(查找的值，查找的区域，0为精确匹配)，实现的结果是返回查找值在查找区域的第几行第几列<br>=VLOOKUP(A20,$A$2:$M$16,MATCH(B20,$A$2:$M$2,0),0) </p>
</blockquote>
<ul>
<li>VLOOKUP + 通配符查找</li>
</ul>
<blockquote>
<p>=VLOOKUP(“<em>“&amp;C2&amp;”</em>“,$A$1:$A$6,1,0) </p>
</blockquote>
<h4 id="MATCH"><a href="#MATCH" class="headerlink" title="MATCH"></a>MATCH</h4><p> MATCH（lookup_value,lookuparray,match-type） </p>
<blockquote>
<p>match-type： 1或省略，查找小于或等于指定内容最大值，数据必须升序排列；0，查找等于指定内容的第一个值；-1或省略，查找大于或等于指定内容最大值，数据必须降序排列</p>
</blockquote>
<h4 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h4><p>row(reference) </p>
<blockquote>
<p>返回 reference 行数， 若无参数，则返回当前行数</p>
</blockquote>
<h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p>MOD(number, divisor) </p>
<blockquote>
<p>求余数</p>
</blockquote>
<h4 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h4><p>INDEX(array, row_num, [column_num])</p>
<blockquote>
<p>返回由行号和列号索引选中的表或数组中元素的值 </p>
</blockquote>
<h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><p> RANK(number,ref,[order]) </p>
<blockquote>
<p> 返回一列数字的数字排位 </p>
</blockquote>
]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用及问题总结</title>
    <url>/archives/58793.html</url>
    <content><![CDATA[<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>blog 文件夹目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml   &#x2F;&#x2F; 网站配置信息</span><br><span class="line">├── package.json  &#x2F;&#x2F; 应用程序信息</span><br><span class="line">├── scaffolds     &#x2F;&#x2F; 模板文件夹</span><br><span class="line">├── source        &#x2F;&#x2F; 资源文件夹</span><br><span class="line">|   ├── _drafts   &#x2F;&#x2F; 草稿</span><br><span class="line">|   └── _posts    &#x2F;&#x2F; 发布的文件</span><br><span class="line">└── themes        &#x2F;&#x2F; 主题</span><br></pre></td></tr></table></figure>


<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>新建文章 <code>hexo new [layout] &lt;title&gt;</code></p>
<blockquote>
<p>没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来</p>
</blockquote>
<p>启动服务 <code>hexo s(server) [--debug]</code></p>
<p>生成静态文件 <code>hexo g(generate)</code></p>
<p>生成部署 <code>hexo g -d </code></p>
<p>发布草稿 <code>hexo publish [layout] &lt;filename&gt;</code></p>
<p>清除缓存（db.json）和静态文件（public）<code>hexo clean</code></p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在头部添加以下信息：</p>
<blockquote>
<p>password: 123<br>abstract: 密码：123<br>message: Enter the password to view the article</p>
</blockquote>
<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><ul>
<li><p>Accessing non-existent property xxxx of module exports inside circular dependency</p>
<p>使用命令 <code>npx cross-env NODE_OPTIONS=&quot;--trace-warnings&quot; hexo s</code>跟踪错误，发现是nib 这个包里的 stylus 的问题，网上说的降低 node 版本是一种方法，但我们不能如此将就。</p>
<p>nib 中的 dependencies 为 <code>&quot;stylus&quot;: &quot;0.54.5&quot;</code>，nib最后一次更新已经是2016年了，指望不了别人，就靠自己吧</p>
<p>始终相信，同样的问题，别人一定提出过，查官方 issues，看到有人已经<a href="https://github.com/stylus/stylus/pull/2538">修复</a>，并且推到了 <a href="https://github.com/stylus/stylus/pull/2538/commits/16e2a6c6f96f80b0d700411879f1c13991a0a1a5">dev</a> 上，几句代码我们就直接改吧</p>
</li>
</ul>
<p>​      打开 node_modules\nib\node_modules\stylus\lib\nodes\index.js 在前面添加以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.lineno = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.column = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.filename = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/archives/6096f3d5.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/archives/10a61f34.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/24/YuXkxBWnls2jbrO.jpg" style="zoom: 50%;" />

<p>如何实现搜索引擎的搜索关键词提示功能？</p>
<span id="more"></span>

<h3 id="什么是“Trie-树”？"><a href="#什么是“Trie-树”？" class="headerlink" title="什么是“Trie 树”？"></a>什么是“Trie 树”？</h3><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p>
<p>假设有 6 个字符串：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 6 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p>
<p>我们可以先对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。<strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p>
<img data-src="https://i.loli.net/2021/08/24/mk4nPXRaIU8bJ5h.jpg" style="zoom:50%;" />

<p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>
<p>Trie 树构造的分解过程：</p>
<img data-src="https://i.loli.net/2021/08/24/7jgq8GPRzkS4HVT.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/24/FMPESoCABkUhD6X.jpg" style="zoom:50%;" />

<p>当我们在 Trie 树中查找一个字符串的时候，比如查找字符串“her”，那我们将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。</p>
<img data-src="https://i.loli.net/2021/08/24/ZzJgXcoRf5xNiWk.jpg" style="zoom:50%;" />

<p>如果我们要查找的是字符串“he”呢？我们还用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串“he”匹配的路径。但是，路径的最后一个节点“e”并不是红色的。也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p>
<img data-src="https://i.loli.net/2021/08/24/5HpTzZVrctJ6jfG.jpg" style="zoom:50%;" />

<h3 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作，<strong>一个是将字符串集合构造成 Trie 树</strong>。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。<strong>另一个是在 Trie 树中查询一个字符串</strong>。</p>
<p>Trie 树是一个多叉树，<strong>如何存储一个 Trie 树？</strong></p>
<p>可以借助散列表的思想，我们通过一个下标与字符一一映射的数组，来存储子节点的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在 Trie 树中查找字符串的时候，我们就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;/&#x27;</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往Trie树中插入一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TrieNode newNode = <span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">        p.children[index] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Trie树中查找一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = pattern[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不存在pattern</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 找到pattern</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在 Trie 树中，查找某个字符串的时间复杂度是多少？</strong></p>
<p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p>
<h3 id="Trie-树真的很耗内存吗？"><a href="#Trie-树真的很耗内存吗？" class="headerlink" title="Trie 树真的很耗内存吗？"></a>Trie 树真的很耗内存吗？</h3><p>如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</p>
<p>当然也可稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。比如有序数组、跳表、散列表、红黑树等。</p>
<p>实际上，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，缩点优化，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。</p>
<img data-src="https://i.loli.net/2021/08/24/sTfhwtImGOESykz.jpg" style="zoom:50%;" />

<h3 id="Trie-树与散列表、红黑树的比较"><a href="#Trie-树与散列表、红黑树的比较" class="headerlink" title="Trie 树与散列表、红黑树的比较"></a>Trie 树与散列表、红黑树的比较</h3><p>在刚刚讲的这个场景，在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有极其严苛的要求。</p>
<ol>
<li><p>字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p>
</li>
<li><p>要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p>
</li>
<li><p>如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p>
</li>
<li><p>我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p>
</li>
</ol>
<p>综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。</p>
<p>实际上，Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串。</p>
<h3 id="如何利用-Trie-树，实现搜索关键词的提示功能？"><a href="#如何利用-Trie-树，实现搜索关键词的提示功能？" class="headerlink" title="如何利用 Trie 树，实现搜索关键词的提示功能？"></a>如何利用 Trie 树，实现搜索关键词的提示功能？</h3><p>我们假设关键词库由用户的热门搜索关键词组成。我们将这个词库构建成一个 Trie 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 Trie 树中匹配。为了讲解方便，我们假设词库里只有 hello、her、hi、how、so、see 这 6 个关键词。当用户输入了字母 h 的时候，我们就把以 h 为前缀的 hello、her、hi、how 展示在搜索提示框内。当用户继续键入字母 e 的时候，我们就把以 he 为前缀的 hello、her 展示在搜索提示框内。这就是搜索关键词提示的最基本的算法原理。</p>
<img data-src="https://i.loli.net/2021/08/24/ZQxcBk5lOaUqfEu.jpg" style="zoom:50%;" />

<p>实际上，搜索引擎的搜索关键词提示功能远非这么简单。</p>
<ul>
<li>我刚讲的思路是针对英文的搜索关键词提示，对于更加复杂的中文来说，词库中的数据又该如何构建成 Trie 树呢？</li>
<li>如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？</li>
<li>像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？</li>
</ul>
<p>实际上，Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础</title>
    <url>/archives/84ac9751.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/1ZjWmtS6UAJiwdR.jpg" style="zoom:50%;" />

<p>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</p>
<span id="more"></span>

<h3 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h3><p>“树”里面每个元素我们叫做“节点”，用来连接相邻节点之间的关系，我们叫做“父子关系”。下图中，A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p>
<img data-src="https://i.loli.net/2021/08/17/twphd5oCvk8yUrf.jpg" style="zoom:50%;" />

<p>除此之外，关于“树”，还有三个比较相似的概念：<strong>高度</strong>（Height）、<strong>深度</strong>（Depth）、<strong>层</strong>（Level）。它们的定义是这样的：</p>
<img data-src="https://i.loli.net/2021/08/17/GRuwFW2Irmg18PZ.jpg" style="zoom:50%;" />

<p>这三个概念的定义比较容易混淆，描述起来也比较空洞。我举个例子说明一下，你一看应该就能明白。</p>
<img data-src="https://i.loli.net/2021/08/15/B5oAS48XL1f7lwj.jpg" style="zoom:50%;" />

<h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点。</p>
<img data-src="https://i.loli.net/2021/08/17/ZmAI6zVs9rhJKtY.jpg" style="zoom:50%;" />

<p>上图中三个都是二叉树，其中，编号 2 的二叉树也叫做满二叉树，特征是除叶子结点外每个结点都有两个子节点。</p>
<p>编号 3 的二叉树叫做完全二叉树，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。</p>
<p>为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？</p>
<p>这是由二叉树的实现来定义的，先来了解下如何表示（存储）一棵二叉树？</p>
<p>先来看比较简单、直观的链式存储法。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<img data-src="https://i.loli.net/2021/08/17/e7qhUGwbBAurHy6.jpg" style="zoom:50%;" />

<p>我们再来看，基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p>
<img data-src="https://i.loli.net/2021/08/17/PFXASywYujfskgx.jpg" style="zoom:50%;" />

<p>上图是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。</p>
<img data-src="https://i.loli.net/2021/08/17/D9ndF2U1Gtm3pwH.jpg" style="zoom:50%;" />

<p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。</p>
<ul>
<li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li>
<li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li>
<li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/Dbtuwo1W6dzVPNe.jpg" style="zoom:50%;" />

<p>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure>

<p>每个结点最多会被访问两次，时间复杂度为O(n)。</p>
<hr>
<img data-src="https://i.loli.net/2021/08/17/matwhKI5B8WyPkp.jpg" style="zoom:50%;" />

<h3 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h3><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<img data-src="https://i.loli.net/2021/08/17/dBWGVTJRNfZ9LkF.jpg" style="zoom:50%;" />

<ol>
<li><strong>二叉查找树的查找操作</strong></li>
</ol>
<p>先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<img data-src="https://i.loli.net/2021/08/17/lRQ9wpMSBDOu3hb.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>二叉查找树的插入操作</strong></li>
</ol>
<p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<img data-src="https://i.loli.net/2021/08/17/XrRk1AvWdhZwMKo.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>二叉查找树的删除操作</strong></li>
</ol>
<p>针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p>
<ul>
<li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</li>
<li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</li>
<li>如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/IvxqRQrony9WNjC.jpg" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。</p>
<p>还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p>
<h3 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h3><p>在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。</p>
<p>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？</p>
<p>第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
<p>第二种方法比较不好理解，不过更加优雅。每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
<img data-src="https://i.loli.net/2021/08/17/mIt9126wc4szkGl.jpg" style="zoom:50%;" />

<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<img data-src="https://i.loli.net/2021/08/17/f8tLTjS64iFsb7R.jpg" style="zoom:50%;" />

<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
<img data-src="https://i.loli.net/2021/08/17/Mz1PEAvi9ydDSeF.jpg" style="zoom:50%;" />

<h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<img data-src="https://i.loli.net/2021/08/15/cCs2r4I61GBNz3U.jpg" style="zoom:50%;" />

<p>现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。</p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p>
<p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p>
<p>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &gt;&#x3D; 1+2+4+8+...+2^(L-2)+1</span><br><span class="line">n &lt;&#x3D; 1+2+4+8+...+2^(L-2)+2^(L-1)</span><br></pre></td></tr></table></figure>

<p>借助等比数列的求和公式，我们可以计算出，L 的范围是[log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，<strong>那我们为什么还要用二叉查找树呢？</strong></p>
<ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
<li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
<li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ul>
<p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p>
<p><strong>如何通过编程，求出一棵给定二叉树的确切高度呢？</strong></p>
<ul>
<li><p>确定二叉树高度有两种思路：第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。</p>
</li>
<li><p>递归法，根节点高度=max(左子树高度，右子树高度)+1</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/archives/7474c898.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/09/01/FGtVSwuW4oCkJ6X.jpg" style="zoom:50%;" />

<p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。</p>
<span id="more"></span>

<h3 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h3><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>
<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong>实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>
<ul>
<li>分解：将原问题分解成一系列子问题；</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>
<li>合并：将子问题的结果合并成原问题。</li>
</ul>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li>原问题与分解成的小问题具有相同的模式；</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</li>
<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li>
</ul>
<h3 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h3><p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p>
<img data-src="https://i.loli.net/2021/09/01/KeSPqbwpETat1FD.jpg" style="zoom:50%;" />

<p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p>
<p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 O(n^2)。那有没有更加高效的处理方法呢？</p>
<p>我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p>
<p>使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？</p>
<p>这里就要借助归并排序算法了。归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p>
<img data-src="https://i.loli.net/2021/09/01/MnFv139ZwjAOYIt.jpg" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num += (q-i+<span class="number">1</span>); <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123; <span class="comment">// 从tmp拷贝回a</span></span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于分治算法，还有几道比较经典的问题。</p>
<ul>
<li><p>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</p>
</li>
<li><p>有两个 n<em>n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A</em>B？</p>
</li>
</ul>
<h3 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h3><p>比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。在此就可以利用分治的思想。</p>
<p>给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p>
<p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>为什么说 MapReduce 的本质就是分治思想？</p>
<p>刚刚举的订单的例子，数据有 10GB 大小，可能给你的感受还不强烈。那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p>
<p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p>
<p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p>
<p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>初识动态规划</title>
    <url>/archives/2da9f3b9.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/09/06/W1iAxbGIe42PtRs.jpg" style="zoom:50%;" />

<p>淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。如何从 n 个商品中抉择出方案使得商品价格总和最大程度接近满减条件（200元）?</p>
<span id="more"></span>

<p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。</p>
<h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><p>相比上节回溯算法，使用动态规划来解决这个背包问题能有效降低时间复杂度</p>
<p>我们将整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放入背包，我们会把每一层重复的状态合并，然后基于上一层的状态集合来推导下一层的状态集合。通过合并每一层重复状态可以保证每层状态个数不会超过 w（背包承载重量） 个，避免每层状态个数的指数增长。</p>
<p>我们使用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p>
<p>第 0 个物品重量是 2，决策完后，用 states[0][0]=true 和 states[0][2]=true 来表示其放入和不放入两种状态。第 1 个物品重量也是 2，基于之前的背包状态，这个物品决策完后，就有三种状态： states[1][0]=true，states[1][2]=true，states[1][2]=true。</p>
<p>整个状态数组计算完后，只需在最后一层找一个值为 true 的最接近 w 的值，就是背包中物品总重量的最大值。</p>
<img data-src="https://static001.geekbang.org/resource/image/aa/b5/aaf51df520ea6b8056f4e62aed81a5b5.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">weight:物品重量，n:物品个数，w:背包可承载重量</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w+<span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">  <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;<span class="comment">// 不把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) states[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p>
<p>代码复杂度好分析，就是 O(n*w)，n 表示物品个数，w 表示背包可以承载总重量。</p>
<p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。所以，有时候，我们会说，动态规划是一种空间换时间的解决思路。那有什么办法可以降低空间消耗吗？</p>
<p>实际上，我们只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack2</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[w+<span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">  states[<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">  <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="comment">// 按照 j 从小到大处理的话，会出现 for 循环重复计算的问题。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w-items[i]; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[j]==<span class="keyword">true</span>) states[j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (states[i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h3><p>现在引入物品价值这一变量，对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p>
<p>先看回溯算法代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int maxV &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 结果放到maxV中</span><br><span class="line">private int[] items &#x3D; &#123;2，2，4，6，3&#125;;  &#x2F;&#x2F; 物品的重量</span><br><span class="line">private int[] value &#x3D; &#123;3，4，8，9，6&#125;; &#x2F;&#x2F; 物品的价值</span><br><span class="line">private int n &#x3D; 5; &#x2F;&#x2F; 物品个数</span><br><span class="line">private int w &#x3D; 9; &#x2F;&#x2F; 背包承受的最大重量</span><br><span class="line">public void f(int i, int cw, int cv) &#123; &#x2F;&#x2F; 调用f(0, 0, 0)</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了，i&#x3D;&#x3D;n表示物品都考察完了</span><br><span class="line">    if (cv &gt; maxV) maxV &#x3D; cv;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw, cv); &#x2F;&#x2F; 选择不装第i个物品</span><br><span class="line">  if (cw + weight[i] &lt;&#x3D; w) &#123;</span><br><span class="line">    f(i+1,cw+weight[i], cv+value[i]); &#x2F;&#x2F; 选择装第i个物品</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p>
<img data-src="https://i.loli.net/2021/09/06/lQfxFzAW7pb8Oyr.jpg" style="zoom:50%;" />

<p>可以发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p>
<p>接下来看动态规划如何解决。</p>
<p>还是把整个求解过程分为 n 个阶段，用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack3</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">      states[i][j] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">//动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123; <span class="comment">// 不选择第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123; <span class="comment">// 选择第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = states[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">        <span class="keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">          states[i][j+weight[i]] = v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找出最大值</span></span><br><span class="line">  <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] &gt; maxvalue) maxvalue = states[n-<span class="number">1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)。跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>开篇问题和0-1背包问题很像，“重量”换成了“价格”而已。购物车有 n 个商品，用一个二维数组 states[n][x]，来记录每次决策之后所有可达的状态。</p>
<p>0-1 背包问题中，我们找的是小于等于 w 的最大值，x 就是背包的最大承载重量 w+1。对于这个问题来说，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际的问题而言，如果要购买的物品的总价格超过 200 太多，比如 1000，那这个羊毛“薅”得就没有太大意义了。所以，我们可以限定 x 值为 1001。</p>
<p>不过，这个问题不仅要求大于等于 200 的总价格中的最小的，我们还要找出这个最小总价格对应都要购买哪些商品。实际上，我们可以利用 states 数组，倒推出这个被选择的商品序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// items商品价格，n商品个数, w表示满减条件，比如200</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">double11advance</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][<span class="number">3</span>*w+<span class="number">1</span>];<span class="comment">//超过3倍就没有薅羊毛的价值了</span></span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= <span class="number">3</span>*w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w; ++j) &#123;<span class="comment">// 不购买第i个商品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w-items[i]; ++j) &#123;<span class="comment">//购买第i个商品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) states[i][j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">for</span> (j = w; j &lt; <span class="number">3</span>*w+<span class="number">1</span>; ++j) &#123; </span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] == <span class="keyword">true</span>) <span class="keyword">break</span>; <span class="comment">// 输出结果大于等于w的最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">3</span>*w+<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 没有可行解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">// i表示二维数组中的行，j表示列</span></span><br><span class="line">    <span class="keyword">if</span>(j-items[i] &gt;= <span class="number">0</span> &amp;&amp; states[i-<span class="number">1</span>][j-items[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.print(items[i] + <span class="string">&quot; &quot;</span>); <span class="comment">// 购买这个商品</span></span><br><span class="line">      j = j - items[i];</span><br><span class="line">    &#125; <span class="comment">// else 没有购买这个商品，j不变。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j != <span class="number">0</span>) System.out.print(items[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释下代码中如何打印选择购买的商品的：</p>
<p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j]或者 states[i-1][j-value[i]]是否是 true。</p>
<p>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划实战</title>
    <url>/archives/2f0539d8.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/09/07/mLQUsPOgKWCtrbn.jpg" style="zoom:50%;" />

<p>当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。那这个功能是如何实现的呢？</p>
<span id="more"></span>

<h3 id="如何量化两个字符串的相似度？"><a href="#如何量化两个字符串的相似度？" class="headerlink" title="如何量化两个字符串的相似度？"></a>如何量化两个字符串的相似度？</h3><p>先来看，如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是<strong>编辑距离</strong>（Edit Distance）。指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p>
<p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（Levenshtein distance）和<strong>最长公共子串长度</strong>（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p>
<p>莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。</p>
<p>下图例子中，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p>
<img data-src="https://i.loli.net/2021/09/07/R6jMzknfrpBd5JV.jpg" style="zoom:50%;" />

<h3 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h3><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合多阶段决策最优解模型。</p>
<p>先看下用回溯算法如何解决。</p>
<p>回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：</p>
<ul>
<li>可以删除 a[i]，然后递归考察 a[i+1] 和 b[j]；</li>
<li>可以删除 b[j]，然后递归考察 a[i] 和 b[j+1]；</li>
<li>可以在 a[i] 前面添加一个跟 b[j] 相同的字符，然后递归考察 a[i] 和 b[j+1];</li>
<li>可以在 b[j] 前面添加一个跟 a[i] 相同的字符，然后递归考察 a[i+1] 和 b[j]；</li>
<li>可以将 a[i] 替换成 b[j]，或者将 b[j] 替换成 a[i]，然后递归考察 a[i+1] 和 b[j+1]。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] a = <span class="string">&quot;mitcmu&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] b = <span class="string">&quot;mtacnu&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="comment">// 调用方式 lwstBT(0, 0, 0);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lwstBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> edist)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == n || j == m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) edist += (n-i);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m) edist += (m - j);</span><br><span class="line">    <span class="keyword">if</span> (edist &lt; minDist) minDist = edist;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a[i] == b[j]) &#123; <span class="comment">// 两个字符匹配</span></span><br><span class="line">    lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 两个字符不匹配</span></span><br><span class="line">    lwstBT(i + <span class="number">1</span>, j, edist + <span class="number">1</span>); <span class="comment">// 删除a[i]或者b[j]前添加一个字符</span></span><br><span class="line">    lwstBT(i, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 删除b[j]或者a[i]前添加一个字符</span></span><br><span class="line">    lwstBT(i + <span class="number">1</span>, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 将a[i]和b[j]替换为相同字符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p>
<img data-src="https://static001.geekbang.org/resource/image/86/89/864f25506eb3db427377bde7bb4c9589.jpg" style="zoom:50%;" />

<p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。</p>
<p>在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p>
<p>这个例子的状态转移方式相对矩阵最短路径问题要复杂一点：</p>
<img data-src="https://i.loli.net/2021/09/07/H9xvPDmWbSzs4ER.jpg" style="zoom:50%;" />

<p>将状态转移方程写出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-<span class="number">1</span>,j)+<span class="number">1</span>, min_edist(i,j-<span class="number">1</span>)+<span class="number">1</span>, min_edist(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">如果：a[i]==b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-<span class="number">1</span>,j)+<span class="number">1</span>, min_edist(i,j-<span class="number">1</span>)+<span class="number">1</span>，min_edist(i-<span class="number">1</span>,j-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">其中，min表示求三数中的最小值。     </span><br></pre></td></tr></table></figure>

<p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值。</p>
<img data-src="https://i.loli.net/2021/09/07/xLBdvnz43ZDJa6s.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lwstDP</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] minDist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123; <span class="comment">// 初始化第0行:a[0..0]与b[0..j]的编辑距离</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) minDist[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) minDist[<span class="number">0</span>][j] = minDist[<span class="number">0</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minDist[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化第0列:a[0..i]与b[0..0]的编辑距离</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) minDist[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) minDist[i][<span class="number">0</span>] = minDist[i-<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minDist[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 按行填表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) minDist[i][j] = min(</span><br><span class="line">          minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">else</span> minDist[i][j] = min(</span><br><span class="line">          minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minDist[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> minv = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; minv) minv = x;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; minv) minv = y;</span><br><span class="line">  <span class="keyword">if</span> (z &lt; minv) minv = z;</span><br><span class="line">  <span class="keyword">return</span> minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何编程计算最长公共子串长度？"><a href="#如何编程计算最长公共子串长度？" class="headerlink" title="如何编程计算最长公共子串长度？"></a>如何编程计算最长公共子串长度？</h3><p>每个状态包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。</p>
<p>先来看回溯的处理思路。我们从 a[0]和 b[0]开始，依次考察两个字符串中的字符是否匹配。</p>
<ul>
<li>如果 a[i]与 b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li>
<li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</li>
<li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li>
<li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line">如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>, max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))；</span><br><span class="line"></span><br><span class="line">如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-<span class="number">1</span>,j-<span class="number">1</span>), max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))；</span><br><span class="line"></span><br><span class="line">其中max表示求三数中的最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] maxlcs = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;<span class="comment">//初始化第0行：a[0..0]与b[0..j]的maxlcs</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) maxlcs[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) maxlcs[<span class="number">0</span>][j] = maxlcs[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> maxlcs[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;<span class="comment">//初始化第0列：a[0..i]与b[0..0]的maxlcs</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) maxlcs[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) maxlcs[i][<span class="number">0</span>] = maxlcs[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> maxlcs[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) maxlcs[i][j] = max(</span><br><span class="line">          maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> maxlcs[i][j] = max(</span><br><span class="line">          maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxlcs[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxv = Integer.MIN_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; maxv) maxv = x;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; maxv) maxv = y;</span><br><span class="line">  <span class="keyword">if</span> (z &gt; maxv) maxv = z;</span><br><span class="line">  <span class="keyword">return</span> maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p>
<p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。</p>
<p>针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。</p>
<ul>
<li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</li>
<li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</li>
<li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</li>
</ul>
<p>针对纠错性能方面，我们也有相应的优化方式。我讲两种分治的优化思路。</p>
<ul>
<li>如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</li>
<li>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划理论</title>
    <url>/archives/f5510e8e.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/09/06/vP3QhA5EgiRsc92.jpg" style="zoom:50%;" />

<p>什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？</p>
<span id="more"></span>

<h3 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h3><p>什么是<strong>“一个模型”</strong>？它指的是动态规划适合解决的问题的模型。我把这个模型定义为<strong>“多阶段决策最优解模型”</strong>。</p>
<p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
<p>什么是<strong>“三个特征”</strong>？它们分别是<strong>最优子结构、无后效性和重复子问题</strong>。</p>
<ol>
<li><strong>最优子结构</strong></li>
</ol>
<p>指问题的最优解包含子问题的最优解。也就是说我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p>
<ol start="2">
<li><strong>无后效性</strong></li>
</ol>
<p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p>
<ol start="3">
<li>重复子问题</li>
</ol>
<p>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p>
<h3 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h3><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p>
<img data-src="https://i.loli.net/2021/09/06/7SkDG8MzWBLE3yo.jpg" style="zoom:50%;" />

<p>我们先看看，这个问题是否符合“一个模型”？</p>
<p>从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p>
<p>我们把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p>
<img data-src="https://i.loli.net/2021/09/06/sHrlK8AgqpG3LbJ.jpg" style="zoom: 33%;" />

<p>我们再来看，这个问题是否符合“三个特征”？</p>
<p>我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。</p>
<img data-src="https://i.loli.net/2021/09/06/Rgj7xYBlyU6V4pF.jpg" style="zoom:50%;" />

<p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p>
<p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="number">1</span>), min_dist(i-<span class="number">1</span>, j))</span><br></pre></td></tr></table></figure>

<h3 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h3><ol>
<li><strong>状态转移表法</strong></li>
</ol>
<p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p>
<p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。</p>
<p><strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong></p>
<p>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p>
<p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。</p>
<p>现在，我们来看一下，如何套用这个状态转移表法，来解决之前那个矩阵最短路径的问题？</p>
<p>从起点到终点，我们有很多种不同的走法。我们可以穷举所有走法，然后对比找出一个最短走法。不过如何才能无重复又不遗漏地穷举出所有走法呢？我们可以用回溯算法这个比较有规律的穷举算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"><span class="comment">// 调用方式：minDistBacktracing(0, 0, 0, w, n);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span></span><br><span class="line">  <span class="keyword">if</span> (i == n &amp;&amp; j == n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; minDist) minDist = dist;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; n) &#123; <span class="comment">// 往下走，更新i=i+1, j=j</span></span><br><span class="line">    minDistBT(i + <span class="number">1</span>, j, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &lt; n) &#123; <span class="comment">// 往右走，更新i=i, j=j+1</span></span><br><span class="line">    minDistBT(i, j+<span class="number">1</span>, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了回溯代码之后，接下来，我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了</p>
<img data-src="https://i.loli.net/2021/09/06/vH4RMShyizjWGKD.jpg" style="zoom:50%;" />

<p>既然存在重复子问题，我们就可以尝试看下，是否可以用动态规划来解决呢？</p>
<p>我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充</p>
<img data-src="https://i.loli.net/2021/09/06/8YpWJRoqOnrcNgh.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/09/06/jtu7ImVde3GslTF.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123; <span class="comment">// 初始化states的第一行数据</span></span><br><span class="line">    sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">    states[<span class="number">0</span>][j] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states的第一列数据</span></span><br><span class="line">    sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">    states[i][<span class="number">0</span>] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      states[i][j] = </span><br><span class="line">            matrix[i][j] + Math.min(states[i][j-<span class="number">1</span>], states[i-<span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> states[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>状态转移方程法</strong></li>
</ol>
<p><strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong></p>
<p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。</p>
<p>拿刚才例子举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min_dist(i, j) &#x3D; w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span><br></pre></td></tr></table></figure>

<p>状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p>
<p>下面我用递归加“备忘录”的方式，将状态转移方程翻译成来代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = </span><br><span class="line">         &#123;&#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">9</span>&#125;, &#123;<span class="number">2</span>，<span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，&#123;<span class="number">5</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">7</span>&#125;，&#123;<span class="number">6</span>，<span class="number">8</span>，<span class="number">4</span>，<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="comment">// 调用minDist(n-1, n-1);</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (mem[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">  <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    minLeft = minDist(i, j-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    minUp = minDist(i-<span class="number">1</span>, j);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);</span><br><span class="line">  mem[i][j] = currMinDist;</span><br><span class="line">  <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h3><p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p>
<p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p>
<p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p>
<p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p>
<p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/archives/376d0826.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/09/02/FrjA7iKm9pH5vGX.jpg" style="zoom: 50%;" />

<p>深度优先搜索算法利用的是回溯算法思想。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p>
<span id="more"></span>

<h3 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h3><p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p>
<p>还是看几个经典的例子，增强理解：</p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>
<img data-src="https://i.loli.net/2021/09/02/ejCzlPhv4HitT9R.jpg" style="zoom:50%;" />

<p>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p>
<p>回溯算法非常适合用递归算法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];<span class="comment">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第i行leftup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第i行rightup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">&quot;Q &quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p>
<p>用回溯的方法，我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>
<p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>为了方便讲解，我假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>
<p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。当遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;?&#x27;</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的表示</title>
    <url>/archives/2f590e8e.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/18/cJ3h8xXgzmMdfSo.jpg" style="zoom:50%;" />

<p>微博、微信、LinkedIn 这些社交软件我想你肯定都玩过吧。在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。那你知道，，如何存储微博、微信等这些社交网络的好友关系吗？</p>
<span id="more"></span>

<h3 id="如何理解“图”（Graph）？"><a href="#如何理解“图”（Graph）？" class="headerlink" title="如何理解“图”（Graph）？"></a>如何理解“图”（Graph）？</h3><p>图中的元素我们叫做<strong>顶点</strong>（vertex），顶点之间建立的连接关系叫做<strong>边</strong>（edge），跟顶点相连接的边的条数叫做顶点的<strong>度</strong>（degree）。拿微信举例子，我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边，每个用户有多少好友对应到图中就是顶点的度。</p>
<img data-src="https://i.loli.net/2021/08/18/bCxUjkyIY2wH1eT.jpg" style="zoom:50%;" />

<p>我们还把边有方向的图叫做“有向图”，把边没有方向的图叫做“无向图”。有向图中又把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。微博的社交关系就需要用到有向图，它允许单向关注，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。</p>
<img data-src="https://i.loli.net/2021/08/18/l1mUSZFCvcTkhDq.jpg" style="zoom:50%;" />

<p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p>
<p>再来看QQ，它里面的社交关系要更复杂一点，其中的QQ亲密度功能不仅记录了用户间的好友关系，还记录了两个用户间的亲密度，这里就需要用到另一种图，<strong>带权图</strong>（weighted graph），每条边都有一个权重（weight），依次表示QQ好友间的亲密度。</p>
<img data-src="https://i.loli.net/2021/08/18/sRNGC6YnBmDh8lw.jpg" style="zoom:50%;" />

<h3 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h3><p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）。</p>
<p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。</p>
<img data-src="https://i.loli.net/2021/08/18/t7pSoh9XeB56yiv.jpg" style="zoom:50%;" />

<p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p>
<p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。无向图的二维数组中，如果我们将其用对角线划分为上下两部分，可知一半空间都浪费了。</p>
<p>还有，如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p>
<p>邻接矩阵的存储方法也有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall</a>算法，就是利用矩阵循环相乘若干次得到结果。</p>
<h3 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h3><p>针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，<strong>邻接表</strong>（Adjacency List）。</p>
<p>乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p>
<img data-src="https://i.loli.net/2021/08/18/rQ3DlCLZMR42Gsg.jpg" style="zoom:50%;" />

<p>还记得我们之前讲过的时间、空间复杂度互换的设计思想吗？邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p>
<p>比如图中的例子，如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p>
<p>当然，如果链过长，也可以将链表换成其他更高效的数据结构，比如平衡二叉查找树（红黑树）、跳表等</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/archives/22e30075.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/14/ZHdMhOrVlLy8Cba.jpg" style="zoom:50%;" />

<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</p>
<span id="more"></span>

<p>如果想要设计一个哈希算法，需要满足以下几点要求：</p>
<ul>
<li><p>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</p>
</li>
<li><p>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</p>
</li>
<li><p>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</p>
</li>
<li><p>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</p>
</li>
</ul>
<h3 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h3><p>说到哈希算法的应用，最先想到的应该就是安全加密。最常用于加密的哈希算法是 <strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 <strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。除了这两个之外，还有很多其他加密算法，比如 <strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p>
<p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p>
<p>不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。</p>
<p>这基于组合数学中一个非常基础的理论，鸽巢原理（也叫抽屉原理）。这个原理本身很简单，它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p>
<p>比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p>
<p>没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。</p>
<h3 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h3><p>可以先举一个例子。如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那我们该如何搜索呢？</p>
<p>我们知道，任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时。有没有比较快的方法呢？</p>
<p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p>
<p>如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p>
<p>如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p>
<h3 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h3><p>BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p>
<p>具体的 BT 协议很复杂，校验方法也有很多，来谈谈其中的一种思路。</p>
<p>我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p>
<h3 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h3><p>散列函数也是哈希算法的一种应用。</p>
<p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p>
<p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
<hr>
<img data-src="https://i.loli.net/2021/08/14/qfg315so42LFanQ.jpg" style="zoom:50%;" />

<h3 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h3><p>我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p>
<p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p>
<ul>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li>
</ul>
<p>如果借助哈希算法，这些问题都可以非常完美地解决。<strong>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号</strong>。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p>
<h3 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h3><ol>
<li><strong>如何统计“搜索关键词”出现的次数？</strong></li>
</ol>
<p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？</p>
<p>我们来分析一下。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p>
<p>针对这两个难点，<strong>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度</strong>。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
<p>实际上，这里的处理过程也是 MapReduce 的基本设计思想。</p>
<ol start="2">
<li><strong>如何快速判断图片是否在图库中？</strong></li>
</ol>
<p>假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。</p>
<p>我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p>
<p>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
<p>现在，我们来估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。</p>
<p>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。</p>
<p>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。</p>
<p>实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。应用七：分布式存储</p>
<h3 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h3><p>现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。</p>
<p>该如何决定将哪个数据放到哪个机器上呢？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p>
<p>但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。</p>
<p>原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。</p>
<p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生[雪崩效应](<a href="https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94">雪崩效应 - 维基百科，自由的百科全书 (wikipedia.org)</a>)，压垮数据库。</p>
<p>所以，我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<a href="https://www.zsythink.net/archives/1182">一致性哈希算法</a>就要登场了。</p>
<p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆和堆排序</title>
    <url>/archives/2fad594d.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/qHFQo1w4nR7bfZP.jpg" style="zoom:50%;" />

<p>“堆”（Heap），是一种特殊的树，其应用场景广泛，最经典的莫过于堆排序了，它是一种原地的、时间复杂度为 $O(nlogn)$ 的排序算法。</p>
<p>快速排序，平均情况下的时间复杂度也为 $O(nlogn)$，而且堆排序比快速排序的时间复杂度还要稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？</p>
<span id="more"></span>

<h3 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h3><ul>
<li><p>堆是一个完全二叉树；</p>
</li>
<li><p>堆中每一个节点的值都必须大于等于&lt;“大顶堆”&gt;（或小于等于&lt;“小顶堆”&gt;）其子树中每个节点的值。</p>
</li>
</ul>
<h3 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h3><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。下面是一个用数组存储堆的例子。</p>
<img data-src="https://i.loli.net/2021/08/17/GVpPJMldQrnKh2O.jpg" style="zoom:50%;" />

<p>从图中我们可以看到，数组中下标为 $i$ 的节点的左子节点，就是下标为 $i∗2$ 的节点，右子节点就是下标为 $i∗2+1$ 的节点，父节点就是下标为 $\frac i2$ 的节点。</p>
<p>知道了如何存储一个堆，那我们再来看看，堆上的操作有哪些呢？下面罗列了几个非常核心的操作，分别是往堆中插入一个元素和删除堆顶元素。（如果没有特殊说明，下面都是拿大顶堆来讲解）。</p>
<ol>
<li><strong>往堆中插入一个元素</strong></li>
</ol>
<p>插入一个元素后，就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做<strong>堆化（heapify）</strong>。</p>
<p>堆化实际上有两种，从下往上和从上往下。这里我先讲<strong>从下往上</strong>的堆化方法。</p>
<img data-src="https://i.loli.net/2021/08/17/a98pArTQdcs5VhU.jpg" style="zoom:50%;" />

<p>我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p>
<img data-src="https://i.loli.net/2021/08/17/L1eGUftBPFo75TY.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span>; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="keyword">int</span> i = count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>删除堆顶元素</strong></li>
</ol>
<p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p>
<p>不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。</p>
<img data-src="https://i.loli.net/2021/08/17/1gOwol4Zkqu5FpQ.jpg" style="zoom:50%;" />

<p>我们可以把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下</strong>的堆化方法。</p>
<p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p>
<img data-src="https://i.loli.net/2021/08/17/cWuQKwbgV6IeANJ.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个包含 $n$ 个节点的完全二叉树，树的高度不会超过 $log_2n$。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 $O(logn)$。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 $O(logn)$。</p>
<h3 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h3><p>堆排序的过程大致分解成两个大的步骤，建堆和排序</p>
<ol>
<li> <strong>建堆</strong></li>
</ol>
<p>首先将数组原地建成一个堆。</p>
<p>第一种是利用前面往堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</p>
<p>第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</p>
<p>下面给出一个第二种实现思路的建堆分解步骤图，因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从最后一个非叶子节点开始，依次堆化就行了。</p>
<img data-src="https://i.loli.net/2021/08/17/XIefBErOHumhAlG.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/17/K1UcDmZoiYEBMNQ.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们对下标从 $\frac n2$开始到 $1$ 的数据进行堆化，下标是 $\frac n2+1$ 到 $n$ 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 $\frac n2+1$到 $n$ 的节点都是叶子节点。</p>
<p>每个节点堆化的时间复杂度是 O(logn)，那 2n+1 个节点堆化的总时间复杂度是不是就是 O(nlogn) 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是 O(n)。</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。</p>
<img data-src="https://i.loli.net/2021/08/17/Af983kbiWyKuTgv.jpg" style="zoom:50%;" />

<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<img data-src="https://i.loli.net/2021/08/17/iMdwhqcXyWLentA.jpg" style="zoom:50%;" />

<p>这个公式的求解稍微有点技巧，不过我们高中应该都学过：把公式左右都乘以 2，就得到另一个公式 S2。我们将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。</p>
<img data-src="https://i.loli.net/2021/08/17/xJVF8otqHfybPzm.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/17/GAdKjWn2MiNa8FQ.jpg" style="zoom:50%;" />

<p>因为 h=log2n，代入公式 S，就能得到 S=O(n)，所以，建堆的时间复杂度就是 O(n)。</p>
<ol start="2">
<li><strong>排序</strong></li>
</ol>
<p>建堆结束后，按照大顶堆的特性，第一个元素就是堆顶，也是最大的元素，将其与最后一个元素交换。下一步将剩下的 $n-1$ 个元素重新构建成堆，堆化完成后，再取堆顶的元素，放到 $n-1$ 的位置，不断重复此过程，直到排序完成。</p>
<img data-src="https://i.loli.net/2021/08/17/GVO3nxRcWLp9qF5.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlogn)$，所以，堆排序整体的时间复杂度是 $O(nlogn)$。</p>
<p>堆排序不是稳定的排序算法，因为在排序过程中，存在将堆的最后一个节点与堆顶节点互换的操作，有可能改变值相同数据的原始顺序。</p>
<h3 id="在实际开发中，为什么快速排序要比堆排序性能好？"><a href="#在实际开发中，为什么快速排序要比堆排序性能好？" class="headerlink" title="在实际开发中，为什么快速排序要比堆排序性能好？"></a>在实际开发中，为什么快速排序要比堆排序性能好？</h3><ul>
<li><strong>堆排序数据访问的方式没有快速排序友好</strong></li>
</ul>
<p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的，对cpu缓存不友好</p>
<ul>
<li><strong>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</strong></li>
</ul>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的应用</title>
    <url>/archives/629ab5f5.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/f8rB9iq4zHYaTQt.jpg" style="zoom:50%;" />

<p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？</p>
<span id="more"></span>

<h3 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h3><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<ol>
<li> <strong>合并有序小文件</strong></li>
</ol>
<p>我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p>
<p>假设，这个最小的字符串来自于 13.txt 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p>
<p>这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</p>
<p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p>
<p>我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 $O(logn)$，n 表示堆中的数据个数，这里就是 100，这样就比原来数组存储的方式高效多了。</p>
<ol start="2">
<li><strong>高效能定时器</strong></li>
</ol>
<p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p>
<img data-src="https://i.loli.net/2021/08/17/486vhqnBfGMzUjL.jpg" style="zoom:50%;" />

<p>这样每过 1 秒就扫描一遍任务列表的做法比较低效：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p>
<p>针对这些问题，我们可以采用优先级队列来解决。按照任务的执行时间，将这些任务存储到优先级队列中，队里首部（小顶堆堆顶）存储的是最先执行的任务。</p>
<p>它可以拿首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。定时器便可以设定在时间 T 之后，再执行任务，从当前时间到（T-1）秒这段时间不需要做任何事情。</p>
<p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</p>
<h3 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h3><p>首先把这种求 Top K 的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p>
<p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p>
<p>遍历数组需要 $O(n)$ 的时间复杂度，一次堆化操作需要 $O(logK)$ 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 $O(nlogK)$。</p>
<p>针对动态数据求得 Top K 就是实时 Top K。我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。</p>
<h3 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h3><p>中位数，顾名思义，就是处在中间位置的数。如果数的个数是奇数，取第 $\frac n2+1$ 个；如果个数是偶数，就取第 $\frac n2$ 个或第 $\frac n2 + 1$ 个中一个。</p>
<p>对于一组<strong>静态数据</strong>，可以想先排序，直接取中位数。如果面对<strong>动态数据</strong>集合，中位数在不断变动，如果也采用先排序的方式，那效率就不高了。</p>
<p>我们借助堆就能高效解决这个问题。需要维护两个堆，一个大顶堆，一个小顶堆，大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆数据都大于大顶堆中数据。如此，大顶堆堆顶元素便是需要的中位数：</p>
<img data-src="https://i.loli.net/2021/08/17/VIqdAzwDiZWbLtm.jpg" style="zoom:50%;" />

<p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p>
<p>当两个堆中的数据个数不符合约定时便需要调整：</p>
<img data-src="https://i.loli.net/2021/08/17/3PQBvqkG74oXemT.jpg" style="zoom:50%;" />

<p>实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。</p>
<p>比如求 99% 响应时间。大顶堆中保存 99% 个数据，小顶堆中保存 1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p><strong>有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？</strong></p>
<p>限定内存为 1GB。</p>
<p>考虑到关键词中有很多重复的，首先统计每个关键词的频率，可以通过散列表、平衡二叉查找树等记录关键词及其出现次数。</p>
<p>假设选用散列表顺序扫描这10亿个关键词，统计存储后，在用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表即可。</p>
<p>这里有个漏洞，10亿关键词还是很多的，假设不重复的有1 亿条，每条关键词平均长度为 50 字节，那存储这些关键词需要5GB的内存空间，而且散列表为了避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间更多。</p>
<p>这时可以用到哈希算法，通过哈希算法现将10亿条关键词分片到10个文件中。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/archives/aaaaf04a.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/5ukKbHUPmwVdvgt.jpg" style="zoom: 50%;" />

<p><strong>如何分析、统计算法的执行效率和资源消耗？</strong></p>
<p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p>
<span id="more"></span>

<h3 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h3><p>平时跑代码通过统计、监控来得到算法执行的时间和占用的内存大小的统计方法有很大的局限性（也称为<strong>事后统计法</strong>）</p>
<p><strong>1. 测试结果非常依赖测试环境</strong></p>
<p>测试环境中硬件的不同会对测试结果有很大的影响</p>
<p><strong>2. 测试结果受数据规模的影响很大</strong></p>
<p>对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性</p>
<p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>，也就是本文所要讲述的时间、空间复杂度分析方法。</p>
<h3 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h3><img data-src="https://i.loli.net/2021/07/27/q6WUtBvMd9ZD4O5.png" style="zoom:50%;" />

<p>T(n) 表示代码执行的时间，n 表示数据规模的大小，f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p><strong>大 O 时间复杂度</strong>实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p><strong>1.只关注循环执行次数最多的一段代码</strong></p>
<p>核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度</p>
<p><strong>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
<p><strong>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p>
<p>T(n) = T1(n) * T2(n) = O(n*n) = O(n2)</p>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><img data-src="https://i.loli.net/2021/07/27/jRgEOxP7C6Lst5k.png" style="zoom: 50%;" />

<p>对于罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度在此不展开讲。我们主要来看几种常见的<strong>多项式时间复杂度</strong>。</p>
<p><strong>1. O(1)</strong></p>
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码</p>
<p><strong>2. O(logn)、O(nlogn)</strong></p>
<p>通过一个例子说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123; </span><br><span class="line">	i = i * <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p>
<img data-src="https://i.loli.net/2021/07/27/qab9dmInWu67GDQ.jpg" style="zoom:50%;" />

<p>$x=log_2n$，所以，这段代码的时间复杂度就是 $O(log_2n)$。</p>
<p>而对数之间是可以互相转换的，$log_3n$就等于$ log_32 * log_2n$，所以 $O(log_3n) = O(C * log2n)$，其中$ C=log_32$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $O(Cf(n)) = O(f(n))$。所以，$O(log_2n)$ 就等于 $O(log_3n)$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为$ O(logn)$。</p>
<p><strong>3. (m+n)、O(m*n)</strong></p>
<p>代码的复杂度由两个数据的规模来决定</p>
<p>加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))</p>
<h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p><strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong></p>
<p>和时间复杂度分析一样。常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时用不到。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低</p>
<img data-src="https://i.loli.net/2021/07/27/tiReMnHlyrqVUDY.png" style="zoom: 50%;" />



<hr>
<img data-src="https://i.loli.net/2021/08/17/UKy5b2THVPStiaG.jpg" style="zoom:50%;" />

<p><strong>浅析最好、最坏、平均、均摊时间复杂度</strong></p>
<p>同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的由此区分出四个复杂度方面的分析，<strong>最好情况时间复杂度</strong>（best case time complexity）、<strong>最坏情况时间复杂度</strong>（worst case time complexity）、<strong>平均情况时间复杂度</strong>（average case time complexity）、<strong>均摊时间复杂度</strong>（amortized time complexity）</p>
<p>先看一个例子，在一个无序的数组（array）中，查找变量 x 出现的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123; </span><br><span class="line">	int i &#x3D; 0; </span><br><span class="line">	int pos &#x3D; -1; </span><br><span class="line">	for (; i &lt; n; ++i) &#123; </span><br><span class="line">		if (array[i] &#x3D;&#x3D; x) &#123; </span><br><span class="line">			pos &#x3D; i; break; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h3><p>在最理想的情况下，执行这段代码的时间复杂度，即 O(1)</p>
<h3 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h3><p>在最糟糕的情况下，执行这段代码的时间复杂度，即 O(n)</p>
<h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>在上面这个例子中，查找变量 x 在数组中位置，有 n+1 种情况：<strong>在数组的 0~n-1 位置中</strong>和<strong>不在数组#中</strong>，同时，还要考虑每种情况发生的概率，最终计算过程为：</p>
<img data-src="https://i.loli.net/2021/08/17/tqSKWINGvD2PTUa.jpg" style="zoom: 50%;" />

<p>这个值在概率论中称为<strong>加权平均值</strong>，也叫做期望值，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者期望时间复杂度。用大 O 表示法来表示，去掉系数和常量，加权平均时间复杂度仍然是 O(n)。</p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>首先，均摊时间复杂度就是一种特殊的平均时间复杂度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; array表示一个长度为n的数组</span><br><span class="line">&#x2F;&#x2F; 代码中的array.length就等于n</span><br><span class="line">int[] array &#x3D; new int[n];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count &#x3D;&#x3D; array.length) &#123;</span><br><span class="line">      int sum &#x3D; 0;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum &#x3D; sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] &#x3D; sum;</span><br><span class="line">      count &#x3D; 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] &#x3D; val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例中平均时间复杂度为：</p>
<img data-src="https://i.loli.net/2021/08/17/L8DvC2AhO3PwMTj.jpg" style="zoom:50%;" />

<p>这里引入<strong>摊还分析法</strong>，每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路，得到的就是均摊时间复杂度。</p>
<p>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配基础下</title>
    <url>/archives/5ed0a93c.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/24/RAabjOpiExNPqdU.jpg" style="zoom:50%;" />

<p>如何借助BM算法轻松理解KMP算法？</p>
<span id="more"></span>

<h3 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h3><p>KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的，算法的全称是 Knuth Morris Pratt 算法，简称为 KMP 算法。</p>
<p>KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p>
<p>我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p>
<img data-src="https://i.loli.net/2021/08/24/Zk4Ujxpd7MYaSQN.jpg" style="zoom:50%;" />

<p>现将好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。</p>
<p>类似 BM 算法，KMP 算法也定义了一个 <strong>next 数组</strong>，也称为<strong>失效函数</strong>（failing function），数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标，即模式子串前后缀子串匹配的最大长度。</p>
<img data-src="https://static001.geekbang.org/resource/image/16/a8/1661d37cb190cb83d713749ff9feaea8.jpg" style="zoom:50%;" />

<p>有了 next 数组后就能实现 KMP 算法的框架代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h3><p>我们按照下标从小到大，依次计算 next 数组的值。当我们要计算 next[i]的时候，前面的 next[0]，next[1]，……，next[i-1]应该已经计算出来了。</p>
<p>如果 next[i-1]=k-1，也就是说，子串 b[0, k-1]是 b[0, i-1]的最长可匹配前缀子串。如果子串 b[0, k-1]的下一个字符 b[k]，与 b[0, i-1]的下一个字符 b[i]匹配，那子串 b[0, k]就是 b[0, i]的最长可匹配前缀子串。那如果不相等呢？</p>
<img data-src="https://i.loli.net/2021/08/24/4jJnk9TOv2ZP6tg.jpg" style="zoom:50%;" />

<p>我们假设 b[0, i]的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1]肯定是 b[0, i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 b[0, i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么我们就可以考察 b[0, i-1]的次长可匹配后缀子串 b[x, i-1]对应的可匹配前缀子串 b[0, i-1-x]的下一个字符 b[i-x]是否等于 b[i]。如果等于，那 b[x, i]就是 b[0, i]的最长可匹配后缀子串。</p>
<img data-src="https://i.loli.net/2021/08/24/rUJmQK8yIXzLijF.jpg" style="zoom:50%;" />

<p>可是，如何求得 b[0, i-1]的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1]的次长可匹配后缀子串，这个问题就变成，查找 b[0, y]的最长匹配后缀子串的问题了。</p>
<img data-src="https://i.loli.net/2021/08/24/7MbqCdna59RiWK3.jpg" style="zoom:50%;" />

<p>按照这个思路，我们可以考察完所有的 b[0, i-1]的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i]就是 b[0, i]的最长可匹配后缀子串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; b表示模式串，m表示模式串的长度</span><br><span class="line">private static int[] getNexts(char[] b, int m) &#123;</span><br><span class="line">  int[] next &#x3D; new int[m];</span><br><span class="line">  next[0] &#x3D; -1;</span><br><span class="line">  int k &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; m; ++i) &#123;</span><br><span class="line">    while (k !&#x3D; -1 &amp;&amp; b[k + 1] !&#x3D; b[i]) &#123;</span><br><span class="line">      k &#x3D; next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if (b[k + 1] &#x3D;&#x3D; b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] &#x3D; k;</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h3><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。</p>
<p>KMP 算法包含两部分，第一部分是构建 next 数组，第二部分才是借助 next 数组匹配。</p>
<p>计算 next 数组的代码中，第一层 for 循环中 i 从 1 到 m-1，也就是说，内部的代码被执行了 m-1 次。for 循环内部代码中 while 循环里 k=next[k]。k 累积没有增加超过 m，即while 循环里面 k=next[k]总的执行次数也不可能超过 m，所以 next 数组计算的时间复杂度是 O(m)。</p>
<p> i 从 0 循环增长到 n-1，j 的增长量不可能超过 i，所以肯定小于 n。而 while 循环中的那条语句 j=next[j-1]+1，不会让 j 增长的，那有没有可能让 j 不变呢？也没有可能。因为 next[j-1]的值肯定小于 j-1，所以 while 循环中的这条语句实际上也是在让 j 的值减少。而 j 总共增长的量都不会超过 n，那减少的量也不可能超过 n，所以 while 循环中的这条语句总的执行次数也不会超过 n，所以这部分的时间复杂度是 O(n)。</p>
<p>KMP 算法总得时间复杂度就是 O(m+n)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配基础上</title>
    <url>/archives/29d799aa.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/20/5LtXPdp1zUMowqj.jpg" style="zoom:50%;" />

<p>RK 算法是如何借助哈希算法来实现高效字符串匹配的呢？</p>
<span id="more"></span>

<h3 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h3><p>BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p>
<p>假设我们在字符串 A（<strong>主串</strong>，长度为 n） 中查找字符串 B（<strong>模式串</strong>， 长度为 m），BF 算法思想简单概况就是在主串中，检查起始位置分别是 0、1、2….n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</p>
<img data-src="https://i.loli.net/2021/08/20/EUpOGSrki9yj2NL.jpg" style="zoom:50%;" />

<p>最坏情况，每次要比对 m 个字符，要比对 n-m+1 此，时间复杂度为 O(n*m)。但尽管 BF 算法时间复杂度高，在实际开发中，却是比较常用的：</p>
<ul>
<li>实际软件开发中，模式串和主串长度都不会太长，也不需要每次都把 m 个字符都比对以下，也就是说绝大部分情况下算法执行效率都比这个高。</li>
<li>朴素字符串匹配算法思想简单，代码实现也简单，意味着不容易出错。在工程中，在满足性能要求的前提下，简单是首选，也是我们常说的<a href="https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99">KISS（Keep it Simple and Stupid）设计原则</a>。</li>
</ul>
<h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>全称是 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。其实也就是 BF 算法的升级版。</p>
<p>其思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了，因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>
<img data-src="https://i.loli.net/2021/08/20/NbMf7k6JGDgEzHp.jpg" style="zoom:50%;" />

<p>不过，这种做法只是提高了模式串和子串的比较效率，没有提高算法整体效率。</p>
<p>这里用到一个巧妙设计的哈希算法：假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p>
<p>比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。</p>
<img data-src="https://i.loli.net/2021/08/20/LjmXUZFRlufh2gE.jpg" style="zoom:50%;" />

<p>这种哈希算法有一个特点，在主串中，相邻两个子串 s[i-1] 和 s[i] 的哈希值的计算公式有一定关系。</p>
<img data-src="https://i.loli.net/2021/08/20/Mo2KEpHBq8I39jC.jpg" style="zoom:50%;" />

<p>这里还可以优化，可以事先计算好 26^0 、26^1 、26^2 …… 26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p>
<img data-src="https://i.loli.net/2021/08/20/ULJMzZWxHpyDtwi.jpg" style="zoom:50%;" />

<p>整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。</p>
<p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK 算法整体的时间复杂度就是 O(n)。</p>
<p>上面设计的哈希算法是没有散列冲突的，但如果模式串很长，得到的哈希值也会很大，可能会超过计算机中整型数据可以表示范围。如此，我们可以牺牲下，允许哈希冲突。</p>
<p>们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。不过这样带来的冲突概率也很高，还可以优化，比如将每一个字母从小到大对应一个素数，而不是 1，2，3……这样的自然数。</p>
<p>当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。其实容易解决，当发现子串哈希值和模式串哈希值相等时，再对比一下子串和模式串本身就好。</p>
<p>如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 批量重命名文件</title>
    <url>/archives/e6a92538.html</url>
    <content><![CDATA[<p>使用 python 遍历文件目录，批量重命名文件，已支持功能包括</p>
<ul>
<li>添加前后缀，支持默认序列（输入 seq ）和自定义</li>
<li>选择文件类型</li>
<li>选择是否遍历子目录</li>
<li>选择是否保留原文件名（python读取文件名顺序与文件管理器不同）</li>
<li>如果已存在序列，可使用正则替换序列格式</li>
</ul>
<p><img data-src="https://i.loli.net/2021/06/07/s6bzIfUTL7S5N4r.png"></p>
<span id="more"></span>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prompt_info</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Prefix/Suffix: When &quot;seq&quot; is input, the auto-increasing sequence is output;</span></span><br><span class="line"><span class="string">        Use spaces to distinguish the file type you entered;</span></span><br><span class="line"><span class="string">        Replace existing sequence by regular</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_boolean</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;y&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> s == <span class="string">&#x27;n&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># return get_boolean(input(&#x27;Please enter y(yes) or n(no): &#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_re</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenameFiles</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for RenameFiles&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RenameFiles, self).__init__()</span><br><span class="line"></span><br><span class="line">        prompt_info()</span><br><span class="line"></span><br><span class="line">        self.desPath = <span class="string">&#x27;C:\\Users\\MSI-PC\\Desktop\\desktop-pet\\images\\meizi&#x27;</span></span><br><span class="line">        self.oriPath = <span class="string">&#x27;C:\\Users\\MSI-PC\\Desktop\\desktop-pet\\images\\meizi&#x27;</span></span><br><span class="line">        <span class="comment"># 文件前缀</span></span><br><span class="line">        self.prefix = <span class="built_in">input</span>(<span class="string">&#x27;Please enter the file name prefix: &#x27;</span>)</span><br><span class="line">        <span class="comment"># 文件后缀</span></span><br><span class="line">        self.suffix = <span class="built_in">input</span>(<span class="string">&#x27;Please enter the file name suffix: &#x27;</span>)</span><br><span class="line">        <span class="comment"># 是否保留原文件名</span></span><br><span class="line">        self.is_keep = get_boolean(<span class="built_in">input</span>(<span class="string">&#x27;whether to keep the original file name(y/n: &#x27;</span>))</span><br><span class="line">        <span class="comment"># 使用正则替换已存在序列</span></span><br><span class="line">        self.pattern = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter the re pattern: &#x27;</span>))</span><br><span class="line">        <span class="comment"># 文件类型</span></span><br><span class="line">        self.file_type = <span class="built_in">list</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter the file type(separated by spaces): &#x27;</span>).split())</span><br><span class="line">        <span class="keyword">if</span> self.file_type <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.file_type == []:  <span class="comment"># 默认全部类型</span></span><br><span class="line">            self.file_type = [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">        print(<span class="string">&#x27;pattern: &#x27;</span>, self.pattern, <span class="string">&#x27;file_type: &#x27;</span>, self.file_type)</span><br><span class="line">        <span class="comment"># 是否遍历子目录</span></span><br><span class="line">        self.sub_dir = get_boolean(<span class="built_in">input</span>(<span class="string">&#x27;Whether to traverse subdirectories(y/n): &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Modify file names in batches</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, names <span class="keyword">in</span> os.walk(self.oriPath):</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">                file_name = os.path.splitext(name)[<span class="number">0</span>]</span><br><span class="line">                ext = os.path.splitext(name)[<span class="number">1</span>]</span><br><span class="line">                ori_path = os.path.join(root, name)</span><br><span class="line">                <span class="keyword">if</span> self.file_type <span class="keyword">and</span> (<span class="string">&#x27;*&#x27;</span> <span class="keyword">in</span> self.file_type <span class="keyword">or</span> ext[<span class="number">1</span>:] <span class="keyword">in</span> self.file_type):</span><br><span class="line">                    <span class="comment"># 目标命名</span></span><br><span class="line">                    des_name = (self.prefix <span class="keyword">if</span> self.prefix != <span class="string">&#x27;seq&#x27;</span> <span class="keyword">else</span> <span class="built_in">str</span>(count + <span class="number">1</span>) + <span class="string">&#x27;_&#x27;</span>) + (</span><br><span class="line">                        re.sub(self.pattern, <span class="keyword">lambda</span> x: re.findall(<span class="string">r&#x27;\d+&#x27;</span>, x.group(<span class="number">0</span>))[<span class="number">0</span>],</span><br><span class="line">                               file_name) <span class="keyword">if</span> self.is_keep <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + (</span><br><span class="line">                                   self.suffix <span class="keyword">if</span> self.suffix != <span class="string">&#x27;seq&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(count + <span class="number">1</span>)) + ext</span><br><span class="line"></span><br><span class="line">                    move_path = os.path.join(self.desPath, des_name)</span><br><span class="line">                    <span class="keyword">if</span> name != os.path.basename(__file__):  <span class="comment"># 防止重命名本文件</span></span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            os.rename(ori_path, move_path)</span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                            print(name + <span class="string">&#x27; 已重命名为 &#x27;</span> + des_name)</span><br><span class="line">                        <span class="keyword">except</span> FileExistsError:</span><br><span class="line">                            print(name + <span class="string">&#x27;更名失败! 已有同名文件存在：&#x27;</span> + move_path)</span><br><span class="line">                        <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">                            print(<span class="string">&#x27;目标文件夹不存在，请检查后重试&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.sub_dir:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">&#x27;共有 &#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27; 个文件更名成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main = RenameFiles()</span><br><span class="line">    main.rename()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/archives/fb40efc5.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/10/31/IshnK7BdfaJVo4l.jpg" alt="img" style="zoom:50%;" />

<p>编译器是如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？</p>
<span id="more"></span>

<p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图，每个源文件对应一个顶点，依赖关系就是边。</p>
<p>而且，这个图不仅是有向图，还要是一个有向无环图，拓扑排序本身就是一个有向无环图的算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// s先于t，边s-&gt;t</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是数据结构，实现拓扑排序的算法有两种，分别是 <strong>Kahn 算法</strong>和 <strong>DFS 深度优先搜索</strong></p>
<p><strong>1. Kahn 算法</strong></p>
<p>主要用了贪心思想</p>
<p>遍历到某个顶点时，入度 -1，入度为 0 时即输出到拓扑排序的结果序列中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[v]; <span class="comment">// 统计每个顶点的入度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">      inDegree[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = queue.remove();</span><br><span class="line">    System.out.print(<span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = adj[i].get(j);</span><br><span class="line">      inDegree[k]--;</span><br><span class="line">      <span class="keyword">if</span> (inDegree[k] == <span class="number">0</span>) queue.add(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. DFS 深度优先搜素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span></span><br><span class="line">  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 申请空间</span></span><br><span class="line">    inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 通过邻接表生成逆邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">      inverseAdj[w].add(i); <span class="comment">// w-&gt;i</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 深度优先遍历图</span></span><br><span class="line">    <span class="keyword">if</span> (visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">      visited[i] = <span class="keyword">true</span>;</span><br><span class="line">      dfs(i, inverseAdj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = inverseAdj[vertex].get(i);</span><br><span class="line">    <span class="keyword">if</span> (visited[w] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    visited[w] = <span class="keyword">true</span>;</span><br><span class="line">    dfs(w, inverseAdj, visited);</span><br><span class="line">  &#125; <span class="comment">// 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span></span><br><span class="line">  System.out.print(<span class="string">&quot;-&gt;&quot;</span> + vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序应用"><a href="#拓扑排序应用" class="headerlink" title="拓扑排序应用"></a>拓扑排序应用</h3><p>凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环。</p>
<p>关于图中环的检测，在解决查找最终推荐人的问题时，就说到可能存在脏数据，导致循环推荐，如，A 推荐 B，B 推荐 C，C 推荐 A。我们可以把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配基础中</title>
    <url>/archives/8cdd2cc1.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/20/81gEtfNlqMjF7IU.jpg" style="zoom:50%;" />

<p>如何实现文本编辑器中的查找功能？</p>
<span id="more"></span>

<h3 id="BM-算法核心思想"><a href="#BM-算法核心思想" class="headerlink" title="BM 算法核心思想"></a>BM 算法核心思想</h3><p>BM 算法全称 Boyer-Moore</p>
<p>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。</p>
<img data-src="https://i.loli.net/2021/08/20/fqmogn3VZ9J2MGs.jpg" style="zoom:50%;" />

<p>在这个例子里，主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串没有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。</p>
<img data-src="https://i.loli.net/2021/08/20/OIlstdJP7Kyxmrk.jpg" style="zoom:50%;" />

<p>由现象找规律，你可以思考一下，当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？</p>
<p>我们今天要讲的 BM 算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p>
<h3 id="BM-算法原理分析"><a href="#BM-算法原理分析" class="headerlink" title="BM 算法原理分析"></a>BM 算法原理分析</h3><p>算法包含两部分，分别是<strong>坏字符规则</strong>（bad character rule）和<strong>好后缀规则</strong>（good suffix shift）。</p>
<ol>
<li><strong>坏字符规则</strong></li>
</ol>
<p>它是按照模式串下标从大到小的顺序，倒着匹配的。</p>
<img data-src="https://i.loli.net/2021/08/20/5fFWXi7HlxDVbZK.jpg" style="zoom: 50%;" />

<p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，我们把这个没有匹配的字符叫作坏字符（主串中的字符）。</p>
<img data-src="https://i.loli.net/2021/08/20/aupTr1yz9wxqUei.jpg" style="zoom:50%;" />

<p>我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p>
<img data-src="https://i.loli.net/2021/08/20/X1tCeEWmBb2SLP5.jpg" style="zoom:50%;" />

<p>这时我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p>
<img data-src="https://i.loli.net/2021/08/20/SzxWQtislj4rPGA.jpg" style="zoom:50%;" />

<p>能不能找出规律？</p>
<p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 $s_i$。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 $x_i$ 记作 -1。那模式串往后移动的位数就等于 $s_i-x_i$。</p>
<img data-src="https://i.loli.net/2021/08/20/u1xSBaPwRze3gyr.jpg" style="zoom:50%;" />

<p>要特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p>
<p>利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。</p>
<p>不过，单纯使用坏字符规则还是不够的。因为根据 $s_i-x_i$ 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。</p>
<ol start="2">
<li><strong>好后缀规则</strong></li>
</ol>
<img data-src="https://i.loli.net/2021/08/20/EQf43vmXxcRhptY.jpg" style="zoom:50%;" />

<p>上图中模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。这个时候该如何滑动模式串呢？当然，我们还可以利用坏字符规则来计算模式串的滑动位数，不过，我们也可以使用好后缀处理规则。</p>
<p>我们把已经匹配的 bc 叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u*}，那我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p>
<img data-src="https://i.loli.net/2021/08/20/7ckiIh92pyRDmEu.jpg" style="zoom:50%;" />

<p>如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。</p>
<img data-src="https://i.loli.net/2021/08/20/QS6RctKfWlTqXBe.jpg" style="zoom:50%;" />

<p>不过，当模式串中不存在等于{u}的子串时，我们直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？我们来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。</p>
<img data-src="https://static001.geekbang.org/resource/image/9b/70/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg" style="zoom:50%;" />

<p>如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p>
<img data-src="https://i.loli.net/2021/08/20/jKCvG3UtLMWyRQ9.jpg" style="zoom:50%;" />

<p>所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p>
<p>所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。</p>
<img data-src="https://i.loli.net/2021/08/20/wACRkprVNY1L7bX.jpg" style="zoom:50%;" />

<p>那当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？</p>
<p>我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</p>
<h3 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h3><p>如果我们拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，我们可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p>
<p>关于这个散列表，我们只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，我们用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p>
<img data-src="https://i.loli.net/2021/08/20/7IFYKQuBmy2Dv1s.jpg" style="zoom:50%;" />

<p>将上面的过程翻译成代码，就是下面这个样子。其中，变量 b 是模式串，m 是模式串的长度，bc 表示刚刚讲的散列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] = -<span class="number">1</span>; <span class="comment">// 初始化bc</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算b[i]的ASCII值</span></span><br><span class="line">    bc[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>掌握了坏字符规则之后，我们先把 BM 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 $s_i-x_i$ 计算得到的移动位数可能会出现负数的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">    i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://i.loli.net/2021/08/20/CBvGE2JNypt9eWV.jpg" style="zoom:50%;" />

<p>至此，我们已经实现了包含坏字符规则的框架代码，只剩下往框架代码中填充好后缀规则了。现在，我们就来看看，如何实现好后缀规则。它的实现要比坏字符规则复杂一些。</p>
<ul>
<li>在模式串中，查找跟好后缀匹配的另一个子串；</li>
<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li>
</ul>
<p>因为好后缀也是模式串本身的后缀子串，所以，我们可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。</p>
<p>如何表示模式串中不同的后缀子串呢？因为后缀子串的最后一个字符的位置是固定的，下标为 m-1，我们只需要记录长度就可以了。通过长度，我们可以确定一个唯一的后缀子串。</p>
<img data-src="https://i.loli.net/2021/08/20/FeSiamwoTYvMnJ5.jpg" style="zoom:50%;" />

<p>现在，我们要引入最关键的变量 suffix 数组。suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值。这句话不好理解，我举一个例子。</p>
<img data-src="https://i.loli.net/2021/08/20/1iUjzWegF4h2IKM.jpg" style="zoom:50%;" />

<p>如果模式串中有多个（大于 1 个）子串跟后缀子串{u}匹配，为了避免模式串往后滑动得过头了，我们肯定要存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。</p>
<p>实际上，仅仅是选最靠后的子串片段来存储是不够的。</p>
<p>我们不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。</p>
<p>如果我们只记录刚刚定义的 suffix，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 suffix 数组之外，我们还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。</p>
<p><img data-src="https://i.loli.net/2021/08/20/V1lUEuBjT69AZhx.jpg"></p>
<p><strong>如何来计算并填充这两个数组的值？</strong></p>
<p>我们拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p>
<img data-src="https://i.loli.net/2021/08/20/SeUzMdRpi81QvoE.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">    suffix[i] = -<span class="number">1</span>;</span><br><span class="line">    prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123; <span class="comment">// b[0, i]</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123; <span class="comment">// 与b[0, m-1]求公共后缀子串</span></span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>; <span class="comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>; <span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这两个数组之后，我们现在来看，<strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p>
<p>假设好后缀的长度是 k。我们先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段。我们可以用下面这条规则来处理。</p>
<p><img data-src="https://i.loli.net/2021/08/20/iZFTDabxf8cGMYn.jpg"></p>
<p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p>
<p><img data-src="https://i.loli.net/2021/08/20/vsKhLj1kip3mMX5.jpg"></p>
<p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，我们就将整个模式串后移 m 位。</p>
<p><img data-src="https://i.loli.net/2021/08/20/EK1gYmLIcpR82dZ.jpg"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">  <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BM-算法的性能分析及优化"><a href="#BM-算法的性能分析及优化" class="headerlink" title="BM 算法的性能分析及优化"></a>BM 算法的性能分析及优化</h3><p>我们先来分析 BM 算法的内存消耗。整个算法用到了额外的 3 个数组，其中 bc 数组的大小跟字符集大小有关，suffix 数组和 prefix 数组的大小跟模式串长度 m 有关。</p>
<p>如果我们处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果我们运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免 bc 数组过多的内存消耗。不过，单纯使用好后缀规则的 BM 算法效率就会下降一些了。</p>
<p>对于执行效率来说，我们可以先从时间复杂度的角度来分析。</p>
<p>实际上，我前面讲的 BM 算法是个初级版本。为了让你能更容易理解，有些复杂的优化我没有讲。基于我目前讲的这个版本，在极端情况下，预处理计算 suffix 数组、prefix 数组的性能会比较差。</p>
<p>比如模式串是 aaaaaaa 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 O(m^2)。当然，大部分情况下，时间复杂度不会这么差。关于如何优化这种极端情况下的时间复杂度退化，如果感兴趣，你可以自己研究一下。</p>
<p>实际上，BM 算法的时间复杂度分析起来是非常复杂，这篇论文“<a href="http://dl.acm.org/citation.cfm?id=1382431.1382552">A new proof of the linearity of the Boyer-Moore string searching algorithm</a>”证明了在最坏情况下，BM 算法的比较次数上限是 5n。这篇论文“<a href="http://dl.acm.org/citation.cfm?id=127830">Tight bounds on the complexity of the Boyer-Moore string matching algorithm</a>”证明了在最坏情况下，BM 算法的比较次数上限是 3n。你可以自己阅读看看</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>算法分析注重于思维训练，从上面的 BM 算法中就可以总结出：</p>
<ul>
<li>要有优化意识，BF、RK算法已经能够满足需求了，为什么还要发明 BM算法？是为了减少时间复杂度，但也带来了代码变复杂难以维护的弊端</li>
<li>需要减少查找或遍历的时间复杂度，应该想到什么？散列表</li>
<li>如果表达式计算开销过大，有需要频繁使用怎么办？预处理并缓存</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/archives/a444b428.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/iJeg93A6Kup8Vzq.jpg" style="zoom:50%;" />

<p>插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</p>
<span id="more"></span>

<h3 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h3><p><strong>排序算法的执行效率</strong></p>
<ul>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数 、低阶</li>
<li>比较次数和交换（或移动）次数</li>
</ul>
<p><strong>排序算法的内存消耗</strong></p>
<p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p>
<p><strong>排序算法的稳定性</strong></p>
<p><strong>稳定性</strong>这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变 – 稳点排序算法 &amp; 不稳定排序算法</p>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>下面用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样。</p>
<img data-src="https://i.loli.net/2021/08/17/cgnRoLkXQsBrp4a.jpg" style="zoom:50%;" />

<p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p>
<img data-src="https://i.loli.net/2021/08/17/O2KRjEaZXmAlhYI.jpg" style="zoom:50%;" />

<p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p>
<img data-src="https://i.loli.net/2021/08/17/NPkJSEplcDQ7jbo.jpg" style="zoom:50%;" />

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在思考上面说的排序算法的三个方面。</p>
<ol>
<li>冒泡排序是原地排序算法吗？</li>
</ol>
<p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法</p>
<ol start="2">
<li>冒泡排序是稳定的排序算法吗？</li>
</ol>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p>
<ol start="3">
<li>冒泡排序的时间复杂度是多少？</li>
</ol>
<p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。</p>
<p>再来分析下平均情况下的时间复杂度。对于包含n个数据的数组，有n!种排列方式，不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里换一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p>
<p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure>

<img data-src="https://i.loli.net/2021/08/17/VwFJOH4bhkLPpUu.jpg" style="zoom:50%;" />

<p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 $n*(n-1)/2$，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p>
<p>逆序度的定义正好跟有序度相反。关于这三个概念，我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了</p>
<p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 $n*(n-1)/2=15$。</p>
<img data-src="https://i.loli.net/2021/08/04/rSBdM6AUv7FTuxD.jpg" style="zoom:50%;" />

<p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<em><em>逆序度，也就是$n</em>(n-1)/2$初始有序度</em>*。此例中就是 15–3=12，要进行 12 次交换操作。</p>
<p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行$n*(n-1)/2$​次交换。最好情况下，初始状态的有序度是 $n*(n-1)/2$​，就不需要进行交换。我们可以取个中间值 $n*(n-1)/4$，来表示初始有序度既不是很高也不是很低的平均情况。</p>
<p>换句话说，平均情况下，需要 $n*(n-1)/4$​ 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2)$​，所以平均情况下的时间复杂度就是 $O(n^2)$​。</p>
<p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用</p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p>
<img data-src="https://i.loli.net/2021/08/17/xtl2sXg3VwWCmNu.jpg" style="zoom:50%;" />

<p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p>
<img data-src="https://i.loli.net/2021/08/17/gZkxSJaH9fAtRjs.jpg" style="zoom:50%;" />

<p>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p>
<p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p>
<p>为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是$n*(n-1)/2=15$，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。</p>
<img data-src="https://i.loli.net/2021/08/17/pf5bgNZAy7VC1sJ.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序空间复杂度为$O(1)$​，是原地排序算法，也是稳定排序算法。最好时间复杂度是$O(n)$​，最坏是$O(n^2)$​，我们在数组中插入一个数据的平均时间复杂度是$O(n)$，所以插入排序循环n次插入操作的平均时间复杂度就是$O(n^2)$。​</p>
<h3 id="选择排序（Sort）"><a href="#选择排序（Sort）" class="headerlink" title="选择排序（Sort）"></a>选择排序（Sort）</h3><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<img data-src="https://i.loli.net/2021/08/17/Ac1jt2esPpBQYoZ.jpg" style="zoom:50%;" />

<p>选择排序空间复杂度为 $O(1)$，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n2)$。但是，选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p>
<h3 id="为什么插入排序要比冒泡排序更受欢迎呢？"><a href="#为什么插入排序要比冒泡排序更受欢迎呢？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎呢？"></a>为什么插入排序要比冒泡排序更受欢迎呢？</h3><p>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。对于数据规模大的问题，插入排序更有效率。而且插入排序的算法有很大的优化空间，参考[希尔排序](<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序 - 维基百科，自由的百科全书 (wikipedia.org)</a>)。</p>
<img data-src="https://i.loli.net/2021/08/17/tyJarYoQHW8Zfis.jpg" style="zoom:50%;" />

<p>再讲两种时间复杂度为 $O(nlogn)$ 的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序。</p>
<p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<strong>如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</strong></p>
<h3 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h3><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<img data-src="https://i.loli.net/2021/08/17/Tc2pXM8F4oaZV7z.jpg" style="zoom:50%;" />

<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p>
<p>分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p>
<p>归并排序的递推公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r 不用再继续分解</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序算法, A是数组，n表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归终止条件</span><br><span class="line">  if p &gt;&#x3D; r  then return</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取p到r之间的中间位置q</span><br><span class="line">  q &#x3D; (p+r) &#x2F; 2</span><br><span class="line">  &#x2F;&#x2F; 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  &#x2F;&#x2F; 将A[p...q]和A[q+1...r]合并为A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge()函数示意图：</p>
<img data-src="https://i.loli.net/2021/08/17/fr8VXwpbyTHcRB5.jpg" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i :&#x3D; p，j :&#x3D; q+1，k :&#x3D; 0 &#x2F;&#x2F; 初始化变量i, j, k</span><br><span class="line">  var tmp :&#x3D; new array[0...r-p] &#x2F;&#x2F; 申请一个大小跟A[p...r]一样的临时数组</span><br><span class="line">  while i&lt;&#x3D;q AND j&lt;&#x3D;r do &#123;</span><br><span class="line">    if A[i] &lt;&#x3D; A[j] &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[i++] &#x2F;&#x2F; i++等于i:&#x3D;i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start :&#x3D; i，end :&#x3D; q</span><br><span class="line">  if j&lt;&#x3D;r then start :&#x3D; j, end:&#x3D;r</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp</span><br><span class="line">  while start &lt;&#x3D; end do &#123;</span><br><span class="line">    tmp[k++] &#x3D; A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将tmp中的数组拷贝回A[p...r]</span><br><span class="line">  for i:&#x3D;0 to r-p do &#123;</span><br><span class="line">    A[p+i] &#x3D; tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序是稳定排序算法</p>
<p>来分析一下归并排序的时间复杂度，假设对 n 个元素进行归并排序需要的时间是 $T(n)$，那分解成两个子数组排序的时间都是 $T(n/2)$。merge() 函数合并两个有序子数组的时间复杂度是 $O(n)$，归并排序的时间复杂度的计算公式就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C;   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n   &#x2F;&#x2F; n&gt;1</span><br><span class="line">     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n</span><br><span class="line">     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n</span><br><span class="line">     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     &#x3D; 2^k * T(n&#x2F;2^k) + k * n</span><br><span class="line">     ......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这样一步一步分解推导，我们可以得到 $T(n) = 2^k*T(n/2^k)+kn$​​。当 $T(n/2^k)=T(1)$ 时，也就是 $n/2^k=1$，我们得到 $k=log_2n$ 。我们将 k 值代入上面的公式，得到 $T(n)=Cn+nlog_2n$ 。如果我们用大 O 标记法来表示的话，$T(n)$ 就等于 $O(nlogn)$​​​​​。</p>
<p>从原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 $O(nlogn)$。</p>
<p>归并排序不是原地排序算法（致命“弱点”）,递归代码的空间复杂度并不能像时间复杂度那样累加，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 $O(n)$。</p>
<h3 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h3><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。再使用递归处理思想，用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1。</p>
<img data-src="https://i.loli.net/2021/08/17/SMWPsEmnFlhdKHt.jpg" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;&#x3D; r then return</span><br><span class="line">  </span><br><span class="line">  q &#x3D; partition(A, p, r) &#x2F;&#x2F; 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和归并排序的merge函数类似，这里也有一个partition分区函数，如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p….r]。</p>
<img data-src="https://i.loli.net/2021/08/17/hpOQUKrdAwDNSBH.jpg" style="zoom:50%;" />

<p>我们希望快排是原地排序算法，有一个巧妙地实现思路：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot :&#x3D; A[r]</span><br><span class="line">  i :&#x3D; p</span><br><span class="line">  for j :&#x3D; p to r-1 do &#123;</span><br><span class="line">    if A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i :&#x3D; i+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  return i</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图示：</p>
<img data-src="https://i.loli.net/2021/08/17/jZzt1Q6qYr2mI9X.jpg" style="zoom:50%;" />

<p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p>
<p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢?</p>
<img data-src="https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg" style="zoom:50%;" />

<p>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 $O(nlogn) $的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题</p>
<p><strong>快速排序的性能分析</strong></p>
<p>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 $O(nlogn)$​；如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 $n$ 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 $n/2$ 个元素，这种情况下，快排的时间复杂度就从 $O(nlogn) $退化成了 $O(n^2)$​​</p>
<p>刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p>
<p>假设每次分区操作都将区间分成大小为 9:1 的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。T(n) = T(n/10) + T(9*n/10) + n； n&gt;1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; T(n&#x2F;10) + T(9*n&#x2F;10) + n； n&gt;1</span><br></pre></td></tr></table></figure>

<p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树。这里直接给你结论：T(n) 在大部分情况下的时间复杂度都可以做到 $O(nlogn)$，只有在极端情况下，才会退化到 $O(n^2)$。而且，我们也有很多方法将这个概率降到很低。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序优化</title>
    <url>/archives/7418344d.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/05/5DAt1oVdSKu4Bqr.jpg" style="zoom:50%;" />

<p>如何实现一个通用的、高性能的排序函数？</p>
<span id="more"></span>

<h3 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h3><p>先回顾下前面讲过的几种算法</p>
<img data-src="https://i.loli.net/2021/08/17/6l3qPzWkIYei7bp.jpg" style="zoom:50%;" />

<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p>
<p>堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。一般不适用归并排序的原因是它不是原地排序算法，空间复杂度是$O(n)$。​</p>
<h3 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h3><p>快排在最坏情况下时间复杂度是$O(n^2)$​，主要原因还是因为我们分区点选得不够合理。最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。下面介绍两个常用简单的分区算法。</p>
<ol>
<li><strong>三数取中法</strong></li>
</ol>
<p>区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”</p>
<ol start="2">
<li><strong>随机法</strong></li>
</ol>
<p>每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>
<p>递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p>
<h3 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h3><p>这里拿 Glibc 中的 qsort() 函数举例说明一下</p>
<p>qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。</p>
<p>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。那 qsort() 是如何选择快速排序算法的分区点的呢？如果去看源码，你就会发现，qsort() 选择分区点的方法就是“三数取中法”。</p>
<p>还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的.</p>
<p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</p>
<p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p>
<p>在 qsort() 插入排序的算法实现中，也利用了哨兵这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（下）</title>
    <url>/archives/feeabc3.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/vuCV4SjXpI1UJaf.jpg" style="zoom:50%;" />

<p>为什么散列表和链表经常会一起使用？</p>
<span id="more"></span>

<p>在链表那一节，有讲到如何用链表来实现 LRU 缓存淘汰算法，但是链表实现的 LRU 缓存淘汰算法的时间复杂度是 O(n)，当时也提到了，通过散列表可以将这个时间复杂度降低到 O(1)。</p>
<p>在跳表那一节，提到 Redis 的有序集合是使用跳表来实现的，跳表可以看作一种改进版的链表。当时也提到，Redis 有序集合不仅使用了跳表，还用到了散列表。</p>
<p>除此之外，如果你熟悉 Java 编程语言，你会发现 LinkedHashMap 这样一个常用的容器，也用到了散列表和链表两种数据结构。</p>
<h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p>具体结构是下面这个样子：</p>
<img data-src="https://i.loli.net/2021/08/17/TEmRAHlkZQCtKVs.jpg" style="zoom:50%;" />

<p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？</p>
<p>因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的<strong>双向链表</strong>，另一个链是散列表中的<strong>拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中</strong>。</p>
<p>首先，我们来看如何<strong>查找一个数据</strong>。我们前面讲过，散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。</p>
<p>其次，我们来看如何<strong>删除一个数据</strong>。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</p>
<p>最后，我们来看如何<strong>添加一个数据</strong>。添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p>
<h3 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h3><p>在有序集合中，每个成员对象有两个重要的属性，key（键值）和 score（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。</p>
<p>举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。</p>
<p>如果我们细化一下 Redis 有序集合的操作，那就是下面这样：</p>
<ul>
<li><p>添加一个成员对象；</p>
</li>
<li><p>按照键值来删除一个成员对象；</p>
</li>
<li><p>按照键值来查找一个成员对象；</p>
</li>
<li><p>按照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象；</p>
</li>
<li><p>按照分值从小到大排序成员变量；</p>
</li>
</ul>
<p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。</p>
<h3 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h3><p>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</p>
<ul>
<li><p>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；</p>
</li>
<li><p>查找积分在某个区间的猎头 ID 列表；</p>
</li>
<li><p>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</p>
</li>
</ul>
<p>采用跳表+散列表两种数据结构进行实现。 以key为猎头ID， vlaue为积分信息存储到散列表中，并根据积分将节点存储到跳表中，跳表中的数据都是有序的。 更新猎头的积分信息？ 先维护散列表猎头信息，再将跳表中的猎头信息删除，删除完成以后进行重新添加。 如何根据积分范围查找猎头呢？ 跳表中的数据是有序的，先在跳表中找到最小值，开始依次查找，直到查找到的数据大于积分范围为止。将中间的猎头数据进行返回即可。 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表 从跳表中依次遍历。但是时间复杂度为O(n); 时间复杂度分析： 1. 增加：O(logn); 2.删除：O(1); 3.查找：O(1); 4.积分范围查找：O(logn);</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（上）</title>
    <url>/archives/b752cca6.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/z1tIcxdis9orCSO.jpg" style="zoom:50%;" />

<p>Word 这种文本编辑器你平时应该经常用吧，那你有没有留意过它的拼写检查功能呢？一旦我们在 Word 里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”。Word 的这个单词拼写检查功能，虽然很小但却非常实用。你有没有想过，这个功能是如何实现的呢？</p>
<span id="more"></span>

<h3 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h3><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”</p>
<p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p>举个例子，假设有88名选手参加运动会，每个选手胸前都会贴上自己的参赛号码，现在要通过编程实现通过编号快速找到选手信息。简单考虑，可以将信息放到数组里，编号为k的选手放到数组中下标为k的位置，这里就用到了散列的思想。</p>
<p>又假如校长要求，参赛编号不能这么简单，需要加上年级、班级等信息，编号变成051167的形式，前两位表示年级，中间两位表示班级，最后两位还是原来的编号。思路和前面一致，尽管我们不能直接将编号作为下标，但可以截取编号后两位作为下标，查询时用同样方法取后两位读取数组数据。</p>
<p>这就是典型的散列思想。其中，参赛选手的编号我们叫做<strong>键</strong>（key）或者<strong>关键字</strong>。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作<strong>散列函数</strong>（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作<strong>散列值</strong>（或“Hash 值”“哈希值”）。</p>
<img data-src="https://i.loli.net/2021/08/17/kDVYWCrbiuJfnLq.jpg" style="zoom:50%;" />

<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>三点散列函数设计的基本要求：</p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li>
</ol>
<p>第三点理解起来可能会有问题，我着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<p>所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><ol>
<li><strong>开放寻址法</strong></li>
</ol>
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，<strong>线性探测</strong>（Linear Probing）。</p>
<p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p>我说的可能比较抽象，我举一个例子具体给你说明一下。这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。</p>
<img data-src="https://i.loli.net/2021/08/17/EoPwd7RNAIT8jea.jpg" style="zoom:50%;" />

<p>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
<p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？</p>
<p>还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p>
<p>我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<img data-src="https://i.loli.net/2021/08/17/hHAL2brjgdWk78f.jpg" style="zoom:50%;" />

<p>线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。</p>
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p>
<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。</p>
<p>装载因子的计算公式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">散列表的装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度</span><br></pre></td></tr></table></figure>

<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<ol start="2">
<li><strong>链表法</strong></li>
</ol>
<p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<img data-src="https://i.loli.net/2021/08/17/aXpmxTIMPN8tczQ.jpg" style="zoom:50%;" />

<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p>
<p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
<h3 id="Word-文档中单词拼写检查功能是如何实现的？"><a href="#Word-文档中单词拼写检查功能是如何实现的？" class="headerlink" title="Word 文档中单词拼写检查功能是如何实现的？"></a>Word 文档中单词拼写检查功能是如何实现的？</h3><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p>
<p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol>
<li><strong>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</strong></li>
</ol>
<p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p>
<p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<ol start="2">
<li><strong>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</strong></li>
</ol>
<p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法学习路线</title>
    <url>/archives/c754dd43.html</url>
    <content><![CDATA[<h3 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h3><img data-src="https://i.loli.net/2021/07/27/W2Ds79noOQjvH43.png" alt="数据结构与算法学习路线"  />



<h3 id="学习书单"><a href="#学习书单" class="headerlink" title="学习书单"></a>学习书单</h3><img data-src="https://i.loli.net/2021/07/27/ZIaeVGOrXckR3uY.png" alt="数据结构与算法学习书单"  />



<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><img data-src="https://i.loli.net/2021/07/27/INry6zw7fdFkHPo.png" alt="数据结构与算法知识点" style="zoom:67%;" />



<hr>
<p>没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</p>
<img data-src="https://i.loli.net/2021/07/27/jGrCabD9t4FOlms.jpg" style="zoom:50%;" />

<p>不要浮躁，不要丧失思考能力，不要丧失学习能力</p>
<img data-src="https://i.loli.net/2021/07/27/3fh5uHRktqopaez.jpg" style="zoom:50%;" />

<p>只有做好打硬仗的心理准备，遇到困难才能心态平和</p>
<img data-src="https://static001.geekbang.org/resource/image/d3/42/d3c715012b855aaca2b186b5cf862642.jpg" style="zoom:50%;" />

<p>“放弃”的念头像是一个心魔，它会一直围绕着你</p>
<img data-src="https://static001.geekbang.org/resource/image/61/f4/6118ba4f07e5c1f8f1a7a0a18ba6f7f4.jpg" style="zoom:50%;" />

<p>入门是一个非常漫长和煎熬的过程，谁都逃不过</p>
<img data-src="https://i.loli.net/2021/07/27/uv6eYGlFdi87PWS.jpg" style="zoom:50%;" />

<p>情商比智商更重要。对于很多学科的学习，智商并不是瓶颈，最终能够决定你能达到的高度的，还是情商，而情商中最重要的，我觉得就是逆商（逆境商数，Adversity Quotient），也就是，当你遇到困难时，你会如何去面对，这将会决定你的人生最终能够走多远。</p>
<img data-src="https://i.loli.net/2021/07/27/ZFXGd6r1wyD249N.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表（中）</title>
    <url>/archives/8ab75b21.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/vhNzF4WfudjAVgc.jpg" style="zoom:50%;" />

<p>如何打造一个工业级水平的散列表？</p>
<span id="more"></span>

<p>通过上节的学习，我们知道，散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p>
<p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p>
<p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p>
<h3 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h3><p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，我举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。</p>
<p>第一个例子就是我们上一节的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫做“数据分析法”。</p>
<p>第二个例子就是上一节的开篇思考题，如何实现 Word 拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 nice，我们转化出来的散列值就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash(<span class="string">&quot;nice&quot;</span>)=((<span class="string">&quot;n&quot;</span> - <span class="string">&quot;a&quot;</span>) * <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">&quot;i&quot;</span> - <span class="string">&quot;a&quot;</span>)*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">&quot;c&quot;</span> - <span class="string">&quot;a&quot;</span>)*<span class="number">26</span>+ (<span class="string">&quot;e&quot;</span>-<span class="string">&quot;a&quot;</span>)) / <span class="number">78978</span></span><br></pre></td></tr></table></figure>

<p>实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些你只要了解就行了，不需要全都掌握。</p>
<h3 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h3><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p>
<p>对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p>
<p>这个时候，我们该如何处理呢？还记得我们前面多次讲的“动态扩容”吗？你可以回想一下，我们是如何做数组、栈、队列的动态扩容的。针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p>
<p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。</p>
<img data-src="https://i.loli.net/2021/08/17/NfytnJAzZDplHwu.jpg" style="zoom:50%;" />

<p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
<p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p>
<p>我们前面讲到，当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p>
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<h3 id="如何避免低效的扩容？"><a href="#如何避免低效的扩容？" class="headerlink" title="如何避免低效的扩容？"></a>如何避免低效的扩容？</h3><p>举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？</p>
<p>如果我们的业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。</p>
<p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p>
<p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<img data-src="https://i.loli.net/2021/08/17/Dz46ejmGlZYVt3L.jpg" style="zoom:50%;" />

<p>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p>
<h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><ol>
<li><strong>开放寻址法</strong></li>
</ol>
<p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。我们后面就有一节会讲什么是数据结构序列化、如何序列化，以及为什么要序列化。</p>
<p>上一节我们讲到，用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p>
<p><strong>总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p>
<ol start="2">
<li><strong>链表法</strong></li>
</ol>
<p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</p>
<p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p>
<p>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p>
<p>当然，如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p>
<p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p>
<img data-src="https://i.loli.net/2021/08/17/CpwTSxUV7g6o9uh.jpg" style="zoom:50%;" />

<p><strong>总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p>
<h3 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h3><p>现在，我就拿一个具体的例子，Java 中的 HashMap 这样一个工业级的散列表，来具体看下，这些技术是怎么应用的。</p>
<ol>
<li><strong>初始大小</strong></li>
</ol>
<p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p>
<ol start="2">
<li><strong>装载因子和动态扩容</strong></li>
</ol>
<p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>
<ol start="3">
<li><strong>散列冲突解决办法</strong></li>
</ol>
<p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p>
<p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p>
<ol start="4">
<li><strong>散列函数</strong></li>
</ol>
<p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。我把它摘抄出来，你可以看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capicity -<span class="number">1</span>); <span class="comment">//capicity表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何设计一个工业级的散列函数？"><a href="#如何设计一个工业级的散列函数？" class="headerlink" title="如何设计一个工业级的散列函数？"></a>如何设计一个工业级的散列函数？</h3><p>首先，我会思考，<strong>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</strong></p>
<p>结合已经学习过的散列知识，我觉得应该有这样几点要求：</p>
<ul>
<li><p>支持快速地查询、插入、删除操作；</p>
</li>
<li><p>内存占用合理，不能浪费过多的内存空间；</p>
</li>
<li><p>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</p>
</li>
</ul>
<p><strong>如何实现这样一个散列表呢？</strong>根据前面讲到的知识，我会从这三个方面来考虑设计思路：</p>
<ul>
<li><p>设计一个合适的散列函数；</p>
</li>
<li><p>定义装载因子阈值，并且设计动态扩容策略；</p>
</li>
<li><p>选择合适的散列冲突解决方法。</p>
</li>
</ul>
<p>关于散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，我们前面都讲过了，具体如何选择，还要结合具体的业务场景、具体的业务数据来具体分析。不过只要我们朝这三个方向努力，就离设计出工业级的散列表不远了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/archives/340249a9.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/07/28/OoNQVyXiz58dxjb.jpg" style="zoom: 50%;" />

<p>数组，不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构</p>
<span id="more"></span>

<p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<img data-src="https://i.loli.net/2021/08/17/t4qp6ylwrWk7bY3.jpg" style="zoom:50%;" />

<p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<img data-src="https://i.loli.net/2021/08/17/hHwBdIPnLC2z8K7.jpg" style="zoom:50%;" />

<p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<h3 id="数组是如何实现根据下标随机访问数组元素的？"><a href="#数组是如何实现根据下标随机访问数组元素的？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的？"></a>数组是如何实现根据下标随机访问数组元素的？</h3><p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p>
<img data-src="https://i.loli.net/2021/08/17/nAQj6iLWDYCTOrv.jpg" style="zoom:50%;" />

<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>其中 data_type_size 表示数组中每个元素的大小.。</p>
<p>数组适合查找操作，支持随机访问，<strong>根据下标随机访问</strong>的时间复杂度为 O(1)</p>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>先看<strong>插入操作</strong>，假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？</p>
<p>最好时间复杂度是 O(1)，最坏时间复杂度是 O(n)，平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p>
<p>而如果数组中存储的数据没有规律，只是当做存储集合，为避免大规模数据迁移，还有个办法就是直接将第 k 位的数据移到数组最后，新元素放到 k 位置。</p>
<p>再看<strong>删除操作</strong>，复杂度分析过程类似，结果是一样的。</p>
<p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p>
<p>我们再看个例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p>
<img data-src="https://i.loli.net/2021/08/17/fXTq6t7gPMHuAcF.jpg" style="zoom:50%;" />

<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<p>其实这也就是 JVM 标记清除垃圾回收算法的核心思想。数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p>
<p><strong>JVM标记清除垃圾回收算法</strong></p>
<blockquote>
<p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC（Garbage Collection， 垃圾回收）ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。<br>不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片</p>
</blockquote>
<h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h3><p>现在聊聊数据访问越界的问题，先分析以下这段 C 语言代码运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int arr[3] &#x3D; &#123;0&#125;;</span><br><span class="line">    for(; i&lt;&#x3D;3; i++)&#123;</span><br><span class="line">        arr[i] &#x3D; 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果并非是三行“hello world”，而是会无限打印（不同编辑器表现可能会不一样）</p>
<p>编译器按照内存地址<strong>递减</strong>的方式给变量分配内存</p>
<h3 id="为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？"><a href="#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？" class="headerlink" title="为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</h3><p>根据寻址公式，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure>

<p>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
<p>不过最主要的原因可能是历史原因。C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/archives/1f4ac2fb.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/c7CFMPLGHKIS12r.jpg" style="zoom:50%;" />

<p>后进者先出，先进者后出，这就是典型的“栈”结构。</p>
<span id="more"></span>

<h3 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h3><img data-src="https://i.loli.net/2021/08/17/psIU7Lv3A8jXtgm.jpg" style="zoom:50%;" />

<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p>
<p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p>
<p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。</p>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Stack based upon linked list</span></span><br><span class="line"><span class="string">    基于链表实现的栈(Python) - linked_stack.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data: <span class="built_in">int</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line">        self._next = <span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A stack based upon singly-linked list.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._top: Node = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span></span><br><span class="line">        new_top = Node(value)</span><br><span class="line">        new_top._next = self._top</span><br><span class="line">        self._top = new_top</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; Optional[int]:</span></span><br><span class="line">        <span class="keyword">if</span> self._top:</span><br><span class="line">            value = self._top._data</span><br><span class="line">            self._top = self._top._next</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        current = self._top</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            nums.append(current._data)</span><br><span class="line">            current = current._next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span>]&quot;</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    stack = LinkedStack()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        stack.push(i)</span><br><span class="line">    print(stack)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        stack.pop()</span><br><span class="line">    print(stack)</span><br></pre></td></tr></table></figure>



<p>时间复杂度和空间复杂度均为 O(1)。</p>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p><strong>函数调用栈</strong>：操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<p><strong>表达式求值</strong>：为方便解释，将算术表达式简化为只包含加减乘除四则运算。</p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p>下面将 3+5*8-6 这个表达式的计算过程画成了一张图，结合图来理解刚讲的计算过程。</p>
<img data-src="https://i.loli.net/2021/08/17/IZquxRpiWfKBVN8.jpg" style="zoom:50%;" />

<p><strong>括号匹配</strong>：我们可以借助栈来检查表达式中的括号是否匹配。假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。</p>
<p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<h3 id="如何实习浏览器的前进、后退功能？"><a href="#如何实习浏览器的前进、后退功能？" class="headerlink" title="如何实习浏览器的前进、后退功能？"></a>如何实习浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 引用当前文件夹下的single_linked_list</span></span><br><span class="line">sys.path.append(<span class="string">&#x27;linked_stack.py&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> linked_stack <span class="keyword">import</span> LinkedStack</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewLinkedStack</span>(<span class="params">LinkedStack</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._top</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.forward_stack = NewLinkedStack()</span><br><span class="line">        self.back_stack = NewLinkedStack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Open new url %s&quot;</span> % url, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        self.forward_stack.push(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        top = self.forward_stack.pop()</span><br><span class="line">        self.back_stack.push(top)</span><br><span class="line">        print(<span class="string">&quot;back to %s&quot;</span> % top, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        top = self.back_stack.pop()</span><br><span class="line">        self.forward_stack.push(top)</span><br><span class="line">        print(<span class="string">&quot;forward to %s&quot;</span> % top, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    browser = Browser()</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> browser.can_back():</span><br><span class="line">        browser.back()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> browser.can_forward():</span><br><span class="line">        browser.forward()</span><br><span class="line"></span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br></pre></td></tr></table></figure>





<h3 id="为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"><a href="#为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？" class="headerlink" title="为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"></a>为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</h3><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p>
<p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
<h3 id="JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？"><a href="#JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？" class="headerlink" title="JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？"></a>JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？</h3><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度和广度优先搜索</title>
    <url>/archives/578d0877.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/18/eQqsCz3FBWHtDiR.jpg" style="zoom:50%;" />

<p>在社交网络中，有一个六度分割理论，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p>
<p>在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。那给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？</p>
<span id="more"></span>

<h3 id="什么是“搜索”算法？"><a href="#什么是“搜索”算法？" class="headerlink" title="什么是“搜索”算法？"></a>什么是“搜索”算法？</h3><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p>
<p>图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如这两种最简单、最“暴力”的深度优先、广度优先搜索，还有 A*、IDA*等启发式搜索算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">// 无向图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>度优先搜索（Breadth-First-Search），我们平常都简称 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p>
<img data-src="https://i.loli.net/2021/08/18/DVuS7w9mAT5CBI8.jpg" style="zoom:50%;" />

<p>下面代码里，bfs() 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 s 表示起始顶点，t 表示终止顶点。我们搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印s-&gt;t的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。</p>
<p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。</p>
<p><strong>prev</strong> 用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。为了正向打印出路径，我们需要递归地来打印。</p>
<img data-src="https://i.loli.net/2021/08/18/f513vUuR42prk6a.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/18/YMK954CkxLmSWwG.jpg" style="zoom:50%;" />

<img data-src="https://i.loli.net/2021/08/18/EFjHTwLK2bgmlqh.jpg" style="zoom:50%;" />

<p>广度优先搜索的时间、空间复杂度是多少呢？</p>
<p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。</p>
<p>广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p>
<h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。</p>
<p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略</p>
<p>看下图，搜索的起始顶点是 s，终止顶点是 t，我们希望在图中寻找一条从顶点 s 到顶点 t 的路径。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径。</p>
<img data-src="https://i.loli.net/2021/08/18/z7E48td9X2H63ZM.jpg" style="zoom:50%;" />

<p>深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深度优先搜索的时间、空间复杂度是多少呢？</p>
<p>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。</p>
<p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记一 -- 爬虫基础</title>
    <url>/archives/fc84b201.html</url>
    <content><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" />

<p>本章我们会详细了解 HTTP 原理、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，有助于我们更好理解和编写网络爬虫程序。</p>
<span id="more"></span>

<h3 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h3><ol>
<li><strong>URI 和 URL</strong></li>
</ol>
<p>URI (Uniform Resource Identifier)，即统一资源标识符；URL (Uniform Resource Locator)，即统一资源定位符。用来寻找互联网上某个资源的链接就是 URI/URL，且具有唯一性。URL 是 URI 的子集，URI 还包括一个子类，叫做URN(Universal Resource Name)，即统一资源名称，只为资源命名而不指定定位，使用很少。对于一般网页链接，都称为 URI 或 URL（习惯）。</p>
<p>URL遵循一定格式规范，中括号部分为非必要部分，如下：</p>
<p><code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][#fragment]</code></p>
<ul>
<li><code>scheme</code>:：协议。常用的有 http、https、ftp等，也称作 protocol</li>
<li><code>username</code>、password：用户名和密码。某些情况下 URL 需要提供用户名和密码才能访问</li>
<li><code>hostname</code>：主机地址。可以是域名或 IP 地址，如 <code>https://www.baidu.com</code>，<code>https://8.8.8.8</code></li>
<li><code>port</code>：端口。服务器设定的服务端口，如<code>https://8.8.8.8:1234</code>，有些 URL 没有端口信息，是使用默认端口，http 协议默认端口是 80，https 则是 443</li>
<li><code>path</code>：路径。指网络资源在服务器中的指定地址，如<code>https://github.com/favicon.ico</code>中的 favicon.ico</li>
<li><code>parameters</code>：参数。用来访问某个资源时的附加信息，如<code>https://8.8.8.8:1234/hello;user</code>，这和 query 不同，勿混用，parameters 是分号后内容</li>
<li><code>query</code>：查询。如果有多个查询，用 &amp; 隔开，如<code>https://www.example.com/s?wd=nba%ie=utf-8</code></li>
<li><code>fragment</code>：片段。是对资源描述的部分补充，可理解为资源内容的书签</li>
</ul>
<ol start="2">
<li><strong>HTTP 和 HTTPS</strong></li>
</ol>
<p>在爬虫中，我们抓取的页面通常是基于 HTTP(Hypertext Transfer Protocol) 和 HTTPS(Hypertext Transfer Protocol over Secure Socket Layer) 协议的。</p>
<p>HTTPS 是在 HTTP 下加入 SSL 层，通过该协议传输的内容都是经过 SSL 加密的，SSL 主要作用如下：</p>
<ul>
<li>建立一个信息安全通道，保证数据传输的安全性</li>
<li>确认网站的真实性。凡是使用 HTTPS 协议的网站，可通过单机浏览器地址栏锁头标志来查看网站认证之后的真实信息，也可通过 CA 机构颁发的安全签章来查询</li>
</ul>
<ol start="3">
<li><strong>HTTP 请求过程</strong></li>
</ol>
<p>在浏览器地址栏输入一个 URL，按下回车后便会向网站所在服务器发送一个请求，网站服务器接收到请求后对其进行处理和解析，然后返回对应响应并传回浏览器，响应中包含页面源代码等内容，浏览器对其进行解析呈现所需网页。</p>
<ol start="4">
<li><strong>请求</strong></li>
</ol>
<p>Request，由浏览器发往服务器，分为四部分：请求方法（Request Method）、请求网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。</p>
<ul>
<li>请求方法</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描  述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET *</td>
<td align="center">请求页面，返回页面内容</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">类似于 GET 请求，但响应无内容，用于获取报头</td>
</tr>
<tr>
<td align="center">POST *</td>
<td align="center">大多用于提交表单或上传文件，数据包含在请求体中</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">用客户端传向服务器的数据替换指定文档中的内容（更新）</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">请求服务器删除指定页面</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">把服务器当做跳板，让服务器代替客户端访问其他网页</td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td align="center">允许客户端查看服务器的性能</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td align="center">回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody></table>
<ul>
<li><p>请求网址<br>可唯一确定客户端需求资源。</p>
</li>
<li><p>请求头</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">请求头</th>
<th align="center">描  述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">请求报头域，用于指定客户端可接受哪些类型的信息</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">用于指定客户端可接受的语言类型</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">用于指定客户端可接受的内容编码</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">用于指定请求资源的主机 IP 和端口号，内容为请求 URL 的原始服务器或网关位置</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">也常用 Cookies，网站为了辨别用户，进行会话跟踪而存储在用户本地的数据。主要功能是维持当前访问会话</td>
</tr>
<tr>
<td align="center">Referer</td>
<td align="center">用于标识请求的来源页面，服务器可据此做相应处理，如来源统计、防盗链处理等</td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">简称 UA，使服务器识别，客户端使用的操作系统及版本、浏览器及版本信息。爬取时加上使得伪装浏览器程度更高</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">也叫互联网媒体类型（Internet Media Type）或 MIME 类型，表示请求中的媒体类型信息</td>
</tr>
</tbody></table>
<ul>
<li>请求体<br>一般承载的的是 POST 请求中的表单数据，对于 GET 请求，请求头为空。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Content-Type</th>
<th align="center">POST 提交数据方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application/x-www-form-urlencoded</td>
<td align="center">表单数据</td>
</tr>
<tr>
<td align="center">multipart/form-data</td>
<td align="center">表单文件上传</td>
</tr>
<tr>
<td align="center">application/json</td>
<td align="center">序列化 JSON 数据</td>
</tr>
<tr>
<td align="center">text/html</td>
<td align="center">XML 数据</td>
</tr>
</tbody></table>
<ol start="5">
<li><strong>响应</strong></li>
</ol>
<p>Response，由服务器返回给客户端，分为三部分：响应状态码（Response Status Code）、响应头（Response Headers）和响应体（Response Body）。</p>
<ul>
<li>响应状态码&emsp;&emsp;&emsp;&emsp;&emsp; </li>
</ul>
<table>
<thead>
<tr>
<th align="center"><span style="display:inline-block;width:60px">状态码</span></th>
<th align="center">说明</th>
<th align="center">详  情</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">Continue</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">Switching Protocols</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center"><strong>200</strong></td>
<td align="center">OK</td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">201</td>
<td align="center">Created</td>
<td align="center">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="center">202</td>
<td align="center">Accepted</td>
<td align="center">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="center">203</td>
<td align="center">Non-Authoritative Information</td>
<td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">No Content</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">205</td>
<td align="center">Reset Content</td>
<td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">Partial Content</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">Multiple Choices</td>
<td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">Moved Permanently</td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">Found</td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center">303</td>
<td align="center">See Other</td>
<td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">Not Modified</td>
<td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="center">305</td>
<td align="center">Use Proxy</td>
<td align="center">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="center">306</td>
<td align="center">Unused</td>
<td align="center">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="center">307</td>
<td align="center">Temporary Redirect</td>
<td align="center">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">Bad Request</td>
<td align="center">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">Unauthorized</td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center">402</td>
<td align="center">Payment Required</td>
<td align="center">保留，将来使用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="center">405</td>
<td align="center">Method Not Allowed</td>
<td align="center">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="center">406</td>
<td align="center">Not Acceptable</td>
<td align="center">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="center">407</td>
<td align="center">Proxy Authentication Required</td>
<td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="center">408</td>
<td align="center">Request Time-out</td>
<td align="center">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">Conflict</td>
<td align="center">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="center">410</td>
<td align="center">Gone</td>
<td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="center">411</td>
<td align="center">Length Required</td>
<td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="center">412</td>
<td align="center">Precondition Failed</td>
<td align="center">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="center">413</td>
<td align="center">Request Entity Too Large</td>
<td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="center">414</td>
<td align="center">Request-URI Too Large</td>
<td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="center">415</td>
<td align="center">Unsupported Media Type</td>
<td align="center">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="center">416</td>
<td align="center">Requested range not satisfiable</td>
<td align="center">客户端请求的范围无效</td>
</tr>
<tr>
<td align="center">417</td>
<td align="center">Expectation Failed</td>
<td align="center">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">Not Implemented</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center">502</td>
<td align="center">Bad Gateway</td>
<td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">Service Unavailable</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center">504</td>
<td align="center">Gateway Time-out</td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="center">505</td>
<td align="center">HTTP Version not supported</td>
<td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<ul>
<li>响应头</li>
</ul>
<table>
<thead>
<tr>
<th align="center">响应头</th>
<th align="center">描  述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Date</td>
<td align="center">用于标识响应产生的时间</td>
</tr>
<tr>
<td align="center">Last-Modified</td>
<td align="center">用于指定资源的最后修改时间</td>
</tr>
<tr>
<td align="center">Content-Encoding</td>
<td align="center">用于指定响应内容的编码</td>
</tr>
<tr>
<td align="center">Server</td>
<td align="center">包含服务器信息，如名称、版本号等</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">文档类型，指定返回数据类型</td>
</tr>
<tr>
<td align="center">Set-Cookie</td>
<td align="center">设置 Cookie，用于告诉浏览器需要将此内容放在 Cookie 中，下次请求时将 Cookie 带上</td>
</tr>
<tr>
<td align="center">Expires</td>
<td align="center">用于指定响应过期时间，可让代理服务器或浏览器将加载的内容更新到缓存中</td>
</tr>
</tbody></table>
<ul>
<li>响应体<br>响应正文数据都在响应体中，爬虫请求后要解析的就是响应体。在浏览器开发者工具中单机 Preview，可看到网页源代码。</li>
</ul>
<ol start="6">
<li><strong>HTTP 2.0</strong></li>
</ol>
<p>HTTP 协议自 2015 年发布 2.0 版本，特点是更快、更简单、更稳定。HTTP 2.0 在传输层做了很多优化，主要目标是通过支持完整的请求与响应复用来减少延迟，并通过有效压缩 HTTP 请求头字段的方式将协议开销降到最低，同时增加对请求优先级和服务器推送的支持。另外，修改版本为 2.0 是因为 2.0 版本实现了二进制分帧层，无法与 HTTP 1.x 的服务器和客户端兼容。</p>
<ul>
<li>二进制分帧层<br>在 1.x 版本中，请求和响应都是用文本格式传输的，头部和实体间是用文本换行符隔开的，HTTP 2.0 则将文本格式改为二进制格式，使得解析更高效。同时将请求和响应数据分割为更小的帧，并采用二进制编码，将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息，所有这些都可以在一个 TCP 连接中复用。</li>
<li>多路复用<br>在 HTTP 1.x 中，如果客户端要发起多个并行请求以提升性能，需要使用多个 TCP 连接，而且浏览器为了控制资源，对单个域名会有 6~8 个 TCP 连接请求的限制。但在 HTTP 2.0 中，客户端和服务器可将 HTTP 消息分解为互不依赖的帧，然后交错发送，再在另一端将其重新组装，达到以下效果：<ul>
<li>并行交错地发送多个请求，请求之间互不影响</li>
<li>并行交错地发送多个响应，响应之间互不干扰</li>
<li>使用一个连接并行发送多个请求和响应</li>
<li>不必再为绕过 HTTP 1.x 限制而做很多工作</li>
<li>消除不必要的延迟和提高现有网络容量的利用率，减少页面加载时间</li>
<li>同域名只需占用一个 TCP 连接，并行发送多个请求和响应，消除多余的延时和内存消耗</li>
<li>每个请求可以带一个 31 位的优先值，0 表示最高优先级，数值越大优先级越低。据此，客户端和服务器可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧   </li>
</ul>
</li>
<li>流控制<br>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。HTTP 2.0 提供了一组简单的构建块，允许客户端和服务器实现它们自己的数据流和连接级流控制。<ul>
<li>流控制具有方向性。每个接收方都可根据自身需要选择为每个数据流和整个连接设置任意的窗口大小</li>
<li>流控制的窗口大小是动态调整的。每个接收方都可公布其初始连接和数据流控制窗口（字节单位），当发送放发出 DATA 帧时窗口减小，在接收方发出 WINDOW_UPDATE 帧时窗口增大</li>
<li>流控制无法停用。建立 HTTP 2.0 连接后，客户端与服务器交换 SETTINGS 帧，这会在两个方向上设置流控制窗口</li>
</ul>
</li>
<li>服务器推送<br>服务器可对一个客户端请求发送多个响应，除了对最初请求响应外，也可主动推送资源，无须客户端明确请求。</li>
<li>HTTP 2.0 发展现状<br>任重而道远，虽然一些主流网站和主流浏览器实现了对 HTTP 2.0 的支持，但总体上大部分网站仍以 HTTP 1.1 为主。另外，一些编程语言库还未完全支持 HTTP’ 2.0，对 Python 来说，hyper、httpx 等库已支持 2.0，但广泛使用的 request 库依然只支持 HTTP 1.1。</li>
</ul>
<h3 id="爬虫基本原理"><a href="#爬虫基本原理" class="headerlink" title="爬虫基本原理"></a>爬虫基本原理</h3><p>把互联网比作一张大网，爬虫（网络爬虫）便是在网上爬行的蜘蛛。把网中的节点比作一个个网页，蜘蛛爬到节点相当于爬虫访问了一个页面。节点间的连线可比作网页间的链接关系，蜘蛛通过一个节点后，顺着节点连线继续爬行到下一个节点，意味着爬虫通过网页间的链接关系继续获取后续网页，直至将整个网站涉及页面都访问到并存储获取到的数据。</p>
<p>爬虫就是获取网页并提取和保存信息的自动化程序。</p>
<h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>很多页面需要登录才可以访问，为了保持这种登录状态，就要用到 Session 和 Cookie。</p>
<p>HTTP 有一个特点，无状态。是指 HTTP 协议对事物处理是没有记忆能力的，服务器并不知道客户端处于什么状态，如果需要多次处理之前的消息，客户端就需要额外传递一些重复请求，才能获取后续响应。</p>
<p>Session，即会话，本义指有始有终的一系列动作、消息。如打电话时，从拿起电话拨号通话，到挂断电话之间的一系列过程可称为一个 Session。它位于服务端，用来保持用户的 Session 信息。当用户请求到来，如果还没对应 Session，则会新建。当 Session 过期或被放弃后，服务器会终止该 Session。</p>
<p>Cookie 在客户端，浏览器在下次访问相同网页时会自动带上，Cookie 中携带了 Session ID 信息，服务器通过识别 Cookie 鉴定出具体用户，然后判断是否处于登录状态，并返回对应响应。</p>
<p>Cookie 包含的内容如下：</p>
<table>
<thead>
<tr>
<th>条目</th>
<th align="center">描  述</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td align="center">Cookie 名称，一经创建，不可更改</td>
</tr>
<tr>
<td>Value</td>
<td align="center">Cookie 值，若为 Unicode 字符，则需要为字符编码；若为二进制数据，则需要使用 BASE64 编码</td>
</tr>
<tr>
<td>Domain</td>
<td align="center">指定可以访问该 Cookie 的域名</td>
</tr>
<tr>
<td>Path</td>
<td align="center">Cookie 的使用路径。如 / 表示所有页面，/path/ 表示路径为 /path/ 的页面才能访问</td>
</tr>
<tr>
<td>Max-Age</td>
<td align="center">Cookie 的失效时间，单位秒，常和 Expires 一起使用，通过此属性可计算 Cookie 的有效时间。若为负数，Cookie 在浏览器关闭后失效</td>
</tr>
<tr>
<td>Size</td>
<td align="center">Cookie 的大小</td>
</tr>
<tr>
<td>HTTP</td>
<td align="center">Cookie 的 httponly 属性。若为 true，则只有在 HTTP Headers中才会带有此 Cookie 的信息，不能通过 document.cookie 访问此 Cookie</td>
</tr>
<tr>
<td>Secure</td>
<td align="center">是否仅允许使用安全协议传输 Cookie。使用安全协议在传输数据前会先加密，默认为 false</td>
</tr>
</tbody></table>
<p><strong>tips</strong></p>
<p>除非程序通知服务器删除一个 Session，否则服务器会一直保留。当浏览器关闭后 Cookie 就消失的情况，等再次打开连接服务器，新 Cookie 无法连接到原先的 Session。如果将 Cookie 保存到硬盘上，或使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookie 发给服务器，则又能保持登录状态。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>网站会采取一些反爬虫措施，如检测某个 IP 在单位时间内的请求次数，如果请求次数超过设定阈值，会拒绝响应请求，并返回一些错误信息，这种情况称为封 IP。一种有效的伪装 IP 的方式就是使用代理。</p>
<ol>
<li><strong>基本原理</strong></li>
</ol>
<p>代理是发挥着网络信息中转站的作用，当客户端发起请求时，先由代理服务器接收，再由代理服务器发给 Web 服务器，返回的响应也是先由代理服务器接收，再发给客户端。如此，Web 服务器便无法识别真实 IP。</p>
<ol start="2">
<li><strong>代理作用</strong></li>
</ol>
<ul>
<li>突破自身 IP 的访问限制，访问一些平时不能访问的站点</li>
<li>访问一些单位和团体的内部资源，如使用教育网内地址段的免费代理服务器，就可以下载和上传对教育网开放的各类 FTP，也可以查询、共享各类资料等</li>
<li>提高访问速度。通常，代理服务器会设置一个较大的硬盘缓冲区，当外界信息通过时，会保存到缓冲区中，当其他用户访问相同信息时，直接从缓冲区取出信息，提高访问速度</li>
<li>隐藏真实 IP。上网者可以隐藏自己的 IP，免受攻击或防止被封锁</li>
</ul>
<ol start="3">
<li><strong>代理分类</strong></li>
</ol>
<p>根据<strong>协议</strong>区分：</p>
<ul>
<li>FTP 代理服务器：主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121等</li>
<li>HTTP 代理服务器：主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128等</li>
<li>SSL/TLS 代理：主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位），端口一般为 443</li>
<li>RTSP 代理：主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554</li>
<li>Telnet 代理：主要用于 Telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为 23</li>
<li>POP3/SMTP 代理：主要用于以 POP3/SMTP 方式收发邮件，一般有缓存功能，端口一般为 110/25</li>
<li>SOCKS 代理：单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 只支持 TCP，后者则支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等</li>
</ul>
<p>根据<strong>匿名程序</strong>区分</p>
<ul>
<li>高度匿名代理：会将数据包原封不动地转发</li>
<li>普通匿名代理：会对数据包对一些改动，服务器可能会发现访问的是代理服务器，并有一定概率去追查真实 IP。这里代理服务器通常会加入的 HTTP 头有 HTTP_VIA 和 HTTP_X_FORWARDED_FOR</li>
<li>透明代理：不但改动了数据包，还告诉服务器客户端的真实 IP。这种代理主要利用缓存技术提高访问速度，用内容过滤提高安全性，如内网中的硬件防火墙</li>
<li>间谍代理：由阻止或个人创建的代理服务器，用于记录用户传输的数据，然后对记录的数据进行研究、监控等</li>
</ul>
<ol start="4">
<li><strong>常见代理设置</strong></li>
</ol>
<h3 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h3><ol>
<li><strong>多线程含义</strong></li>
</ol>
<p>进程是线程的集合，进程是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的最小运行单元。如在一个浏览器中，播放音乐是一个线程，播放视频也是一个线程，这些线程并发或并行执行使得浏览器可以同时运行多个任务。</p>
<ol start="2">
<li><strong>并发与执行</strong></li>
</ol>
<p>处理器同一时间只能执行一条指令。并发（concurrency）是指多个线程对应的多条指令被快速轮换执行，从宏观上看起来是同时运行的，但同一时刻只有一个线程被执行。</p>
<p>并行（parallel）是指同一时刻有多条指令在多个处理器上同时执行，意味着并行必须依赖多个处理器。</p>
<ol start="3">
<li><strong>多线程适用场景</strong></li>
</ol>
<p>在一个程序的进程中，有些操作是比较耗时的，如等待数据库查询结果的返回、等待网页的响应。处理器在等待过程中，是可以使用多线程去执行其他操作的。</p>
<p>网络爬虫就是一个典型例子，爬虫向服务器发起请求后，有一段时间需要等待服务器响应，这属于 IO 密集型任务，对于这种任务，使用多线程就可以提高整体爬取效率。</p>
<ol start="4">
<li><strong>多进程含义</strong></li>
</ol>
<p>进程（progress）是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。多进程就是指同时运行多个进程。</p>
<ol start="5">
<li><strong>Python 中的多线程和多进程</strong></li>
</ol>
<p>Python 中 GIL(Global Interpreter Lock，全局解释锁) 的限制导致不论是在单核还是多核条件下，同一时刻只能运行一个线程，使得 Python 多线程无法发挥多核并行优势。</p>
<p>GIL设计之初是出于对数据安全的考虑，Python 多线程下，每个线程执行方式如下：</p>
<ul>
<li>获取 GIL</li>
<li>执行对应线程代码</li>
<li>释放 GIL</li>
</ul>
<p>GIL 就好像一个通行证，一个 Python 进程中，只有一个 GIL，线程只有拿到通行证才能执行，也就是说多进程能更好发挥多核优势。</p>
<p>对于爬虫这种 IO 密集型任务来说，多线程和多进程产生影响差别不大，但对于计算密集型任务来说，由于 GIL 的存在，Python 多线程的整体运行效率在多核情况下可能反而比单核还低。而 Python 多进程相比多线程，运行效率在多核情况下比单核会有成倍提升。</p>
<p>整体来看，Python 多进程比多线程更有优势。另外，由于进程是系统进行资源分配和调度的一个独立单位，所以各进程间的数据是不共享的，进程之间的数据须有单独的机制来实现。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记三 -- 解析库的使用</title>
    <url>/archives/79659fc4.html</url>
    <content><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" />

<p>本章我们了解几种解析库的使用，包括 XPath、Beautiful Soup、PyQuery、Parsel，实际可根据场景和个人使用习惯来选择。</p>
<span id="more"></span>

<h3 id="XPath-的使用"><a href="#XPath-的使用" class="headerlink" title="XPath 的使用"></a>XPath 的使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">html = etree.html(text)</span><br><span class="line"><span class="comment"># html = etree.parse(&#x27;./test.html&#x27;, etree.HTMLParser())</span></span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>全称是 XML Path Language，etree 模块可以自动修正 HTML 文本。其常用规则如下表：</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nodename</td>
<td align="center">选取此节点的所有子节点</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">从当前节点选取直接子节点</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">从当前节点选取子孙节点</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">选取当前节点</td>
</tr>
<tr>
<td align="center">..  or parent::</td>
<td align="center">选取当前节点的父节点</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">选取属性</td>
</tr>
<tr>
<td align="center">text()</td>
<td align="center">文本获取</td>
</tr>
<tr>
<td align="center">contains()</td>
<td align="center">属性多值匹配，包含属性值即可匹配</td>
</tr>
<tr>
<td align="center">last()</td>
<td align="center">最后一个</td>
</tr>
<tr>
<td align="center">position()</td>
<td align="center">用于索引位置判断</td>
</tr>
<tr>
<td align="center">节点轴</td>
<td align="center">ancestor::, attribute::, child::, descendant::, following::, following-sibling::</td>
</tr>
</tbody></table>
<p>运算符</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">or</td>
<td align="center">或</td>
<td align="center">age=19 or age=20</td>
<td align="center">ture or false</td>
</tr>
<tr>
<td align="center">and</td>
<td align="center">与</td>
<td align="center">age&gt;19 and age&lt;21</td>
<td align="center">ture or false</td>
</tr>
<tr>
<td align="center">mod</td>
<td align="center">计算除法余数</td>
<td align="center">5 mod 2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">计算两个节点集</td>
<td align="center">//book|//cd</td>
<td align="center">返回所有拥有 book 和 cd 元素的节点集</td>
</tr>
<tr>
<td align="center">+, -, *, div</td>
<td align="center">加减乘除</td>
<td align="center">—</td>
<td align="center">ture or false</td>
</tr>
<tr>
<td align="center">=, !=, &lt;, &lt;=, &gt;, &gt;=</td>
<td align="center">等于。。。</td>
<td align="center">—</td>
<td align="center">ture or false</td>
</tr>
</tbody></table>
<h3 id="Beautiful-Soup-的使用"><a href="#Beautiful-Soup-的使用" class="headerlink" title="Beautiful Soup 的使用"></a>Beautiful Soup 的使用</h3><p>借助网页结构和属性等特性来解析的一个库，它可以自动将输入文档转换为 Unicode 编码，将输出文档转换为 utf-8 编码，还有很多强大的功能，帮助使用者省去许多烦琐工作，提高解析效率。</p>
<p>Beautiful Soup 解析是依赖解释器的，除了支持 Python 标注库中的 HTML 解释器，还支持其他第三方解释器，如 LXML HTML、LXML XML、html5lib，推荐使用 lxml，初始化的时候这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure>

<p>可以直接调用节点，调用后包含的常用属性和方法有：</p>
<ul>
<li>name: 节点名称</li>
<li>attrs: 属性内容</li>
<li>string: 文本内容</li>
<li>content: 直接子节点</li>
<li>children: 直接子节点，生成器类型</li>
<li>descendants: 子孙节点，生成器类型</li>
<li>parent: 直接父节点；复数取得所有祖先节点，生成器</li>
<li>previous_sibling: 上一个兄弟节点；复数取得前面所有兄弟节点，生成器</li>
<li>next_sibling: 下一个兄弟节点；复数取得后面所有兄弟节点，生成器</li>
</ul>
<p>Beautiful Soup 还提供许多查询方法：</p>
<ul>
<li>find_all(name, attrs, recursive, text, **kwargs) 所有元素，其中 attr 常用属性 id, text, class(关键词，需改为 class_) 可直接使用，如 <code>find_all(id=‘list-1’)</code></li>
<li>find() 第一个匹配元素</li>
<li>find_parent() 直接父节点，复数所有祖先节点</li>
<li>find_next_sibling(), find_previous_sibling()</li>
<li>find_all_next(), find_next(), find_all_previouf(), find_previous()</li>
<li>select()：CSS 选择器</li>
<li>get_text() 同 string 属性</li>
</ul>
<h3 id="PyQuery-的使用"><a href="#PyQuery-的使用" class="headerlink" title="PyQuery 的使用"></a>PyQuery 的使用</h3><p>更强大的 CSS 选择器功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">doc = pq(html)</span><br><span class="line"><span class="comment"># doc = pq(url=&#x27;example.com&#x27;)</span></span><br><span class="line"><span class="comment"># doc = pq(filename=&#x27;demo.html&#x27;)</span></span><br><span class="line">print(doc(<span class="string">&#x27;li&#x27;</span>))</span><br><span class="line">print(doc(<span class="string">&#x27;#container .list li&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>需要的参数是 CSS 选择器，常用方法和属性有：</p>
<ul>
<li>find() 返回所有子孙节点</li>
<li>children() 只返回子节点</li>
<li>parent() 直接父节点，复数是查找祖先节点</li>
<li>siblings() 兄弟节点</li>
<li>attr 调用方式可以是 a.attr(‘href’), a.attr.href，如果 a 是多个节点，只会返回第一个节点属性</li>
<li>text() html() 获取文本和 html 文本</li>
</ul>
<p>pyquery 提供了系列方法对节点进行动态修改：</p>
<ul>
<li>addClass()  -&gt; li.addClass(‘active’)</li>
<li>removeClass() -&gt; li.removeClass(‘active’)</li>
<li>attr() -&gt; li.attr(‘name’, ‘link’)</li>
<li>text() -&gt; li.text(‘changed item’)</li>
<li>html() -&gt; li.html(‘&lt;span&gt;changed item&lt;/span&gt;’)</li>
<li>remove() -&gt; li.find(‘p’).remove()</li>
</ul>
<p>CSS 选择器的强大之处还在于支持伪类选择器，下面依次选择了第一个 li 节点、最后一个 li 节点、第二个 li 节点、第三个 li 之后的节点、偶数位置 li 节点、包含 second 文本的 li 节点：</p>
<ul>
<li>doc(‘li:first-child’)</li>
<li>doc(‘li:last-child’)</li>
<li>doc(‘li:nth-child(2)’)</li>
<li>doc(‘li.gt(2)’)</li>
<li>doc(‘li:nth-child(2n’)</li>
<li>doc(‘li:contains(second)’)</li>
</ul>
<h3 id="Parsel-的使用"><a href="#Parsel-的使用" class="headerlink" title="Parsel 的使用"></a>Parsel 的使用</h3><p>这个库可以解析 HTML 和 XML，支持使用 XPath 和 CSS 选择器对内容进行提取和修改，还融合了正则表达式的提取功能，同时也是 Python 最流行的爬虫框架 Scrapy 的底层支持。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">items = selector.css(<span class="string">&#x27;.item-0&#x27;</span>)</span><br><span class="line">items2 = selector.xpath(<span class="string">&#x27;//li[contains(@class, &quot;item-0&quot;)]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取文本</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">	text = item.xpath(<span class="string">&#x27;.//text()&#x27;</span>).get()</span><br><span class="line">	print(text)</span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0 *::text&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取属性</span></span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0.active a::attr(href)&#x27;</span>).get()</span><br><span class="line">result2 = selector.xpath(<span class="string">&#x27;//li[contains(@class, &quot;item-0&quot;) and contains(@class, &quot;active&quot;)]/a/@href&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则提取</span></span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0&#x27;</span>).re(<span class="string">&#x27;link.*&#x27;</span>)</span><br><span class="line">result2 = selector.css(<span class="string">&#x27;.item-0&#x27;</span>).re_first(<span class="string">&#x27;&lt;span class=&quot;bold&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记五 -- Ajax 数据爬取</title>
    <url>/archives/4ca1a587.html</url>
    <content><![CDATA[<img data-src="https://s2.loli.net/2022/02/22/xCpa2HQnmMqcX3P.png" style="zoom: 67%;" />

<p>现在越来越多的页面数据都是异步加载的，原始页面开始不会包含某些数据，等原始页面加载完后，再向服务器通过 Ajax 请求后获取呈现的，本章我们就来认识一下 Ajax。</p>
<span id="more"></span>

<p>Ajax，全称是 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML，它是一种在保证页面不被刷新、页面链接不改变的情况下实现页面内容局部刷新的技术。</p>
<p>以<a href="https://m.weibo.cn/u/2830678474">微博</a>为例，页面上划加载更多的功能就有用到 Ajax 技术，打开浏览器开发者工具，选择网络，选择 XHR 标签，可筛选出来， 其标志是请求头中带有<code>X-Requested-With: XMLHttpRequest</code>。同时查看 Preview(预览)项，可看到获取的数据，这也为我们爬取数据提供了思路。</p>
<p><img data-src="https://s2.loli.net/2022/02/22/yLPbOZCNHx8E7tw.png"></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本节爬取网站和本系列第二篇内容基本一样，只不过后台数据处理的逻辑和数据加载方式不一样：<a href="https://spa1.scrape.center/">链接</a></p>
<p><img data-src="https://s2.loli.net/2022/02/22/t7Yeyfqhp3u1PAB.png"></p>
<p>点击页码，筛选请求，发现其 Ajax 请求基础 URL 为<code>https://spa1.scrape.center/api/movie/</code>，主要参数有两个，<code>limit</code>和<code>offset</code>，前者固定为 10，后者为页码 * 10。电影详情页链接为<code>https://spa1.scrape.center/api/movie/20/</code>最后的参数是可变的，且这个 id 在爬取列表页数据时已经获得，爬取的结果是结构化的 JSON 数据，无需额外解析。</p>
<p><img data-src="https://s2.loli.net/2022/02/22/R4wC9UMKGxkPYjg.png"></p>
<p>下面开始写代码，用到了 logging 库来输出信息，pymongo 库来存储数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa1.scrape.center/api/movie/?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&#x27;</span></span><br><span class="line">DETAIL_URL = <span class="string">&#x27;https://spa1.scrape.center/api/movie/&#123;id&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION = <span class="string">&#x27;mongodb://localhost:27017&#x27;</span></span><br><span class="line">MONGO_DB = <span class="string">&#x27;movies&#x27;</span></span><br><span class="line">MONGO_COLLECTION = <span class="string">&#x27;movies&#x27;</span></span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(MONGO_CONNECTION)</span><br><span class="line">db = client[MONGO_DB]</span><br><span class="line">collection = db[MONGO_COLLECTION]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_api</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl page by url and return its html</span></span><br><span class="line"><span class="string">    :param url: page url</span></span><br><span class="line"><span class="string">    :return: html of the page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">        logging.error(<span class="string">&#x27;get invalid status code %s while crawling %s&#x27;</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while crawling %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_index</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl index page</span></span><br><span class="line"><span class="string">    :param page: page of index page</span></span><br><span class="line"><span class="string">    :return: html of index page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    index_url = INDEX_URL.<span class="built_in">format</span>(limit=LIMIT, offset=LIMIT * (page - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> crawl_api(index_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取详情页数据，id 列表页数据中获取</span></span><br><span class="line"><span class="string">    :param id: 电影 id</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">return</span> crawl_api(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Save data to MongoDB，这里会有去重的功能，但实际电影是会有同名现象</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    collection.update_one(&#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: data</span><br><span class="line">    &#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">page</span>):</span></span><br><span class="line">    index_data = crawl_index(page)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">&#x27;results&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">            <span class="built_in">id</span> = item.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">            print(<span class="string">&#x27;id&#x27;</span>, <span class="built_in">id</span>)</span><br><span class="line">            detail_data = crawl_detail(<span class="built_in">id</span>)</span><br><span class="line">            logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>, detail_data)</span><br><span class="line">            save_data(detail_data)</span><br><span class="line">            logging.info(<span class="string">&#x27;data saved successfully&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;item data is None, something wrong...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># Pycharm 输入快捷键 main</span></span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记二 -- 基本库的使用</title>
    <url>/archives/50c99347.html</url>
    <content><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" />

<p>本章我们了解基础的 HTTP 库，如 urllib、requests、httpx等，最后一起来完成对一个静态网站的爬取案例实战。</p>
<span id="more"></span>

<h3 id="urllib-库的使用"><a href="#urllib-库的使用" class="headerlink" title="urllib 库的使用"></a>urllib 库的使用</h3><p>urllib 库包含 4 个模块：request、error、parse、robotparser，具体用法如下：</p>
<ol>
<li><strong>发送请求</strong></li>
</ol>
<p>使用 request 库，可以很方便的发起请求并得到响应。</p>
<ul>
<li><strong>urlopen</strong></li>
</ul>
<p>以爬取 Python 官网为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img data-src="https://s2.loli.net/2022/02/15/JdV92QIylBomrgU.png" alt="image-20220215101452116"></p>
<p>可看到我们得到了网页的源代码，其中的链接、图片、文本信息就可以提取出来了。</p>
<p>使用 <code>print(type(response))</code>，输出结果是<code>&lt;class &#39;http.client.HTTPResponse&#39;</code>，响应是一个 HTTPResponse 类型的对象，主要包含 read、readinto、getheader、getheaders、fileno 等方法，以及 msg、version、status、reason、debuglevel、closed 等属性，我们可以调用上述方法和属性，得到返回的一系列信息。</p>
<p>urlopen最基本用法就是传入 URL 参数，其完整 API 如下：</p>
<p><code>urllib.request.urlopen(url, data=None, [timeout,]*, cafile=None, capath=None, cadefault=False, context=None)</code></p>
<p>下面详细说明参数含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data：添加该参数时，需要使用 bytes 方法将其参数转化为字节流编码格式的内容，即 bytes 类型。另外，如果传递了这个参数，，请求方式就变为 POST 了。urllib.parse 模块中 的urlencode(data, encode&#x3D;‘utf-8’)可以转化编码，第二个参数指定编码方式；</span><br><span class="line"></span><br><span class="line">timeout：超时时间，单位秒，超时会抛出 socket.timeout 类型的异常</span><br><span class="line"></span><br><span class="line">其他参数：context 参数必须是 ssl.SSLContext 类型，用来指定 SSL 的设置。cafile 和 capath 用来指定 CA 证书和其路径。cadefault 参数已弃用，默认 False。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Request</strong></li>
</ul>
<p>urlopen 发起的是最基本的请求，如果需要加上 Headers 等信息，就得用到 Request 类来构建请求。构造方法如下：</p>
<p><code>urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url 和 data 参数解释同 urlopen</span><br><span class="line"></span><br><span class="line">headers：请求头，这也可通过调用请求实例的 add_headers 方法添加。最常见的方法就是通过修改 User-Agent 来伪装浏览器，默认的 UA 是 Python-urllib。如可设置 UA 为 Mozilla&#x2F;5.0 (X11; U; Linux i686) Gecko&#x2F;20071127 FireFox&#x2F;2.0.0.11</span><br><span class="line"></span><br><span class="line">origin_req_host：请求方的 host 名称或 IP 地址</span><br><span class="line"></span><br><span class="line">unverifiable：表示请求是否是无法验证的，默认 False，为 True 则表示用户没有权限来接收这个请求结果</span><br><span class="line"></span><br><span class="line">method：指示请求使用的方法，如 GET、POST 和 PUT 等</span><br><span class="line"></span><br><span class="line">其他参数：context 参数必须是 ssl.SSLContext 类型，用来指定 SSL 的设置。cafile 和 capath 用来指定 CA 证书和其路径。cadefault 参数已弃用，默认 False。</span><br></pre></td></tr></table></figure>
<p>下面尝试构建请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/post&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.httpbin.org&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">query = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>&#125;</span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(query), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">req = request.Request(url, data, headers, method=<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;form&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;germey&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;identity&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-620b1624-3d236f007cd3de6c15dfe6ba&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;json&quot;</span>: null, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;117.136.71.145&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>高级用法</strong></li>
</ul>
<p>为了进行 Cookie 处理、代理设置等操作，就绪也用到 urllib.request 中的 BaseHandler 类，有各种子类继承 BaseHandler：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTPDefaultErrorHandler 用于处理响应错误，所有错误会抛出 HTTPError 类型异常</span><br><span class="line">HTTPRedirectHandler 用于处理重定向</span><br><span class="line">HTTPCookieProcessor 用于处理 Cookie</span><br><span class="line">ProxyHandler 用于设置代理，默认为空</span><br><span class="line">HTTPPasswordMgr 用于管理密码</span><br><span class="line">HTTPBasicAuthHandler 用于管理认证</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代理</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Cookie</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;cookie.txt&#x27;</span></span><br><span class="line">cookie = http.cookiejar.CookieJar(filename)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>) <span class="comment"># save as file</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name + <span class="string">&#x27;=&#x27;</span> + item.value)</span><br><span class="line"> </span><br><span class="line">------------- result -------------</span><br><span class="line">BAIDUID=BB78F3CB65EB85782F1ECF6B3C04D0DB:FG=<span class="number">1</span></span><br><span class="line">BIDUPSID=BB78F3CB65EB8578C40219B54CB0A2E7</span><br><span class="line">PSTM=<span class="number">1644894666</span></span><br><span class="line">BD_NOT_HTTPS=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>处理异常</strong></li>
</ol>
<ul>
<li><strong>URLError</strong></li>
</ul>
<p>来自 urllib库的 error 模块，继承自 OSError 模块，由 request 模块产生的异常都可以用这个类处理。</p>
<ul>
<li><strong>HTTPError</strong><ul>
<li>code：HTTP状态码</li>
<li>reason：返回错误原因</li>
<li>headers：返回请求头</li>
</ul>
</li>
</ul>
<p>URLError 的子类，专门用于处理 HTTP 请求错误，有 3 个属性。</p>
<ol start="3">
<li><strong>解析链接</strong></li>
</ol>
<p>本小节介绍 parse 模块的常用方法。</p>
<ul>
<li><strong>urlparse</strong></li>
</ul>
<p>API <code>urllib.parse.urlparse(urlstring, scheme=&#39;&#39;, allow_fragments=True)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlstring：必填项，待解析 URL</span><br><span class="line">scheme：默认协议（如 http、https 等）。如果 urlstring 没有带协议值，则赋该值</span><br><span class="line">allow_fragments：是否忽略 fragment，如果忽略，则会被解析为 path、params 或 query 的一部分</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">&#x27;https://www.baidu.com/index.html;user?a=6#comment&#x27;</span>)</span><br><span class="line">print(<span class="built_in">type</span>(result))</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">urllib</span>.<span class="title">parse</span>.<span class="title">ParseResult</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">ParseResult</span>(<span class="params">scheme=<span class="string">&#x27;https&#x27;</span>, netloc=<span class="string">&#x27;www.baidu.com&#x27;</span>, path=<span class="string">&#x27;/index.html&#x27;</span>, params<span class="string">&#x27;user&#x27;</span>, query=<span class="string">&#x27;id=5&#x27;</span>, fragment=<span class="string">&#x27;comment&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>urlunparse</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse</span><br><span class="line"></span><br><span class="line">data = [<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;a=6&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>]</span><br><span class="line">print(urlunparse(data))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/index.html;user?a=6#comment</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>urlsplit、urlunsplit</strong></li>
</ul>
<p>和 urlparse、urlunparse 很相似，但不在单独解析 params，也不用组合 params内容 。</p>
<ul>
<li><strong>urljoin</strong></li>
</ul>
<p>API <code>urllib.parse.urljoin(base_url, new_url)</code></p>
<p>urljoin 会分析 base_url  中的 scheme、netloc 和 path，并对 new_url 缺失的部分进行补充，最后返回结果。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">urljoin(<span class="string">&#x27;https://www.baidu.com?wd=abc&#x27;</span>, <span class="string">&#x27;https://example.com/index.php&#x27;</span>)</span><br><span class="line">urljoin(<span class="string">&#x27;https://www.baidu.com&#x27;</span>, <span class="string">&#x27;?category=2#comment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/index.php</span><br><span class="line">https://www.baidu.com?category=2#comment</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>urlencode</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">&#x27;https;//www.baidu.com&#x27;</span></span><br><span class="line">url = base_url + urlencode(params)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https;//www.baidu.com?name=germey&amp;age=25</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>parse_qs</strong></li>
</ul>
<p>反序列化，可将一串 GET 请求参数转化为字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">query = <span class="string">&#x27;name=germey&amp;age=25&#x27;</span></span><br><span class="line">print(parse_qs(query))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;germey&#x27;</span>], <span class="string">&#x27;age&#x27;</span>: [<span class="string">&#x27;25&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>parse_qsl</strong></li>
</ul>
<p>与 parse_qs 相似，但运行结果是元组列表，运行结果如下：</p>
<p><code>&#123;(&#39;name&#39;: &#39;germey&#39;), (&#39;age&#39;: &#39;25&#39;)&#125;</code></p>
<ul>
<li><strong>quote</strong></li>
</ul>
<p>将内容转化为 URL 编码格式。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">keyword = <span class="string">&#x27;壁纸&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?wd=&#x27;</span> + quote(keyword)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>unquote</strong></li>
</ul>
<p>URL 解码，用上面代码运行结果可以解码出中文。</p>
<ul>
<li><strong>Robots 协议</strong></li>
</ul>
<p>也叫做爬虫协议、机器人协议，全名为网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取、哪些不可以。通常是一个 robots.txt 的文本文件，放在网站根目录下。</p>
<p>样例，限定搜索爬虫只能爬取 public 目录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">User-Agent: * <span class="comment"># 搜索爬虫名称，常见名称见下表</span></span><br><span class="line">Disallow: /</span><br><span class="line">Allow: /public/</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">爬虫名称</th>
<th align="center">网站名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BaiduSpider</td>
<td align="center">百度</td>
</tr>
<tr>
<td align="center">Googlebot</td>
<td align="center">谷歌</td>
</tr>
<tr>
<td align="center">360Spider</td>
<td align="center">360 搜索</td>
</tr>
<tr>
<td align="center">YodaoBot</td>
<td align="center">有道</td>
</tr>
<tr>
<td align="center">ia_archiver</td>
<td align="center">Alexa</td>
</tr>
<tr>
<td align="center">Scooter</td>
<td align="center">altavista</td>
</tr>
<tr>
<td align="center">Bingbot</td>
<td align="center">必应</td>
</tr>
</tbody></table>
<p>了解 Robots 协议后，就可以使用 robotparser 模块来解析 robots.txt 文件了，用法：</p>
<p><code>urllib.robotparse.RobotFileParse(url=&#39;&#39;)</code></p>
<h3 id="requests-的使用"><a href="#requests-的使用" class="headerlink" title="requests 的使用"></a>requests 的使用</h3><p>requests 库比 urllib 库更强大，在处理网页验证、Cookie 以及实现 POST、PUT 等请求会更方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line">headers = &#123; <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;...&#x27;</span> &#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url, headers=headers, params=data) <span class="comment"># 发起请求，返回结果是 str 类型</span></span><br><span class="line">print(r.json()) <span class="comment"># 如果结果是 JSON 格式，可将结果转化为字典</span></span><br><span class="line">print(r.text()) <span class="comment"># 返回 Unicode 类型数据，即取文本内容</span></span><br><span class="line">print(r.content()) <span class="comment"># 结果转化为 bytes 类型数据 </span></span><br><span class="line">print(r.cookies) <span class="comment"># 获取 Cookie，通过 for key, value in r.cookies.item() 解析</span></span><br><span class="line"><span class="comment"># 登录网站后，将请求头中的 Cookie 内容复制加到爬虫的请求头中，便可获取登录后的信息结果</span></span><br><span class="line">print(r.__dict__) <span class="comment"># 可查看返回结果的所有属性内容</span></span><br><span class="line">print(<span class="built_in">dir</span>(r)) <span class="comment"># 查看所有属性名</span></span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;test.com&#x27;</span>, files=files) <span class="comment"># post 请求</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Session 维持</strong></li>
</ul>
<p>设想，某次利用 post 请求登录网站后，想再次获取登录后的个人信息，使用 get 方法请求，这样是无法获取到的，这相当于开了两个浏览器。</p>
<p>下面举例 Session 的用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line">s.get(<span class="string">&#x27;https://www.httpbin.org/cookies/set/number/123456&#x27;</span>)</span><br><span class="line">r = s.get(<span class="string">&#x27;https://www.httpbin.org/cookies&#x27;</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123; <span class="string">&quot;cookies&quot;</span>: &#123;<span class="string">&quot;number&quot;</span>: <span class="string">&quot;123456&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可看到 Cookie 获取成功，利用 Session 可以模拟在同一个浏览器中打开同一站点的不同页面。</p>
<ul>
<li><strong>其他参数配置</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">verify： 设置为 False 可忽略 SSL 证书的验证</span><br><span class="line">timeout：超时设置，可设置为固定值，也可是元组（请求实际可分为连接和读取两个阶段，超时时间可自定）</span><br><span class="line">auth：身份认证，传递元组 (&#39;user&#39;, &#39;password&#39;)</span><br><span class="line">proxies：代理设置，如果代理需要使用身份认证，可使用类似 http:&#x2F;&#x2F;user:password@host:port 语法设置</span><br></pre></td></tr></table></figure>



<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>用一定语法规则将特定文本提取出来的方式就是正则表达式匹配，常用匹配规则见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式规则</a>。</p>
<ul>
<li><strong>match</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line">print(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.match(<span class="string">&#x27;Hello\s\d\d\d\s(\d&#123;4&#125;)\s\w&#123;10&#125;&#x27;</span>, content)</span><br><span class="line">print(result) <span class="comment"># \s 匹配空白字符，\d 匹配数字，\w 匹配单字字符（字母、数字或者下划线）</span></span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line">print(result.span())</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">25</span>), match=<span class="string">&#x27;Hello 123 4567 World_This&#x27;</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line"><span class="number">4567</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure>

<p>从字符串开头开始匹配，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。用 () 将想提取的字符串括起来，匹配结果调用 group 方法，传入分组索引即可获取提取结果。另外<code>.*</code>是通用匹配，代码中的表达式也可以变为 <code>^Hello.*Demo$</code>，<code>^ $</code> 表示开始和结束标识。</p>
<p><strong>贪婪与非贪婪</strong></p>
<p>来看一种情况，想要获取目标字符串中的数字，用 <code>.*</code> 简化成下面的表达式，运行如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;^Hello.*(\d+).*Demo$&#x27;</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">41</span>), match=<span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>只得到了数字 7，这是因为前面的 <code>.*</code> 会匹配尽可能多的字符，只给 \d+ 剩下一个可满足条件的数字 7，表现出贪婪性，这里我们需要将其变成非贪婪匹配，写法是 <code>.*?</code>，如此运行结果就正常了。</p>
<p><strong>修饰符</strong></p>
<p>在网页匹配过程中会遇到换行符等情况，这时候运行就会报错，因为无法匹配换行符，解决方法是 match 加上第三个参数 re.S，常见的修饰符见下表：</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">re.I</td>
<td align="center">使匹配对大小写不敏感</td>
</tr>
<tr>
<td align="center">re.L</td>
<td align="center">实现本地化识别（locale-aware）匹配</td>
</tr>
<tr>
<td align="center">re.M</td>
<td align="center">多行匹配，影响 ^ 和 $</td>
</tr>
<tr>
<td align="center">re.S</td>
<td align="center">使匹配内容包括换行符在内的所有字符</td>
</tr>
<tr>
<td align="center">re.U</td>
<td align="center">根据 Unicode 字符集解析字符，影响 \w、\W、\b 和 \B</td>
</tr>
<tr>
<td align="center">re.X</td>
<td align="center">忽略表达式中空白和注释（# 引导），以便将正则表达式写得更易于理解</td>
</tr>
</tbody></table>
<p><strong>转移匹配</strong></p>
<p>当在目标字符串中遇到用作正则匹配模式的特殊字符时，在此字符前加 \ 转义即可。</p>
<ul>
<li><strong>search</strong></li>
</ul>
<p>匹配时会扫描整个字符串，返回第一个匹配成功的结果，为了匹配方便，尽量使用、 search()。</p>
<ul>
<li><strong>findall</strong></li>
</ul>
<p>返回所有匹配成功的结果，结果是列表类型，列表中每个元素则是元组类型。</p>
<ul>
<li><strong>sub</strong></li>
</ul>
<p>正则替换，<code>re.sub(&#39;\d+&#39;, &#39;str&#39;, content)</code>，解释：在 content 中匹配所有数字，将其替换为 str 字符（可为空）。很多时候爬取下来的数据都需要进行清洗，再进行匹配提取操作，sub 方法是不错的选择。</p>
<ul>
<li><strong>compile</strong></li>
</ul>
<p>为了复用正则表达式，可以用 compile 方法给表达式做一层封装，方便使用，且 compile 中还可加入修饰符。</p>
<h3 id="httpx-的使用"><a href="#httpx-的使用" class="headerlink" title="httpx 的使用"></a>httpx 的使用</h3><p>urllib 和 requests 有个问题就是只支持 HTTP/1.1，对采用 HTTP/2.0 的网站无法爬取数据，目前支持 HTTP/2.0 有代表性的库有 hyper 和 httpx，后者使用更方便，功能也更强大，用法上和 requests 基本差不多，这里主要说明不一样的地方。</p>
<ul>
<li><strong>Client 对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> httpx.Client() <span class="keyword">as</span> client:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="comment"># 推荐 with as 用法，等价于：</span></span><br><span class="line">client = httpx.Client()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure>

<p>声明 Client 对象时也可指定 headers 等参数，如果开启 HTTP/2.0（默认关闭），写法为：</p>
<p><code>client = httpx.Client(http2=True)</code></p>
<blockquote>
<p>注意：启用 HTTP/2.0 前必须保证客户端和服务器都支持 HTTP/2.0，不然就得改用 1.1 版本</p>
</blockquote>
<ul>
<li>支持异步请求</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient(http2=<span class="literal">True</span>) <span class="keyword">as</span> client:</span><br><span class="line">        response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(fetch(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本节爬取一个基本的静态网站来练手。</p>
<p><strong>链接</strong> <a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a></p>
<p><img data-src="https://s2.loli.net/2022/02/15/kbYzSNa8wFvcWsC.png"></p>
<p><strong>目标</strong></p>
<ul>
<li>使用 requests 爬取电影列表，包括每个电影的详情页；</li>
<li>用正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等；</li>
<li>爬取的内容保存为 JSON 文本文件；</li>
<li>使用多线程加速爬取</li>
</ul>
<p><strong>分析</strong></p>
<p>进入网页后，打开开发者工具（F12），如下图：</p>
<p><img data-src="https://s2.loli.net/2022/02/16/1SDINWzmiwVCBEx.png"></p>
<p>可以看到电影名称就是一个 h2 节点文本，父节点是一个 a 节点，带有 href 属性，表示的是电影详情页的 URL，其他的电影信息都可以通过提取源代码节点中的内容来获得。下面，再来看分页逻辑，将页面拉到底，点击第 2 页，可看到跳转链接为原链接加上 /page/2，继续点击第 3 页、第 4 页，发现逻辑一样，分页思路就清晰了。</p>
<p><img data-src="https://s2.loli.net/2022/02/16/MAkavb7fxm689wj.png"></p>
<p>要完成列表页的爬取，我们可以这么实现：</p>
<ul>
<li>遍历所有页面，索引为1-10</li>
<li>从每个页面提取每个电影的详情页 URL</li>
<li>提取每个详情页的页面元素信息并存储</li>
</ul>
<p>具体实现中，我们使用 requests 获取源代码，用 re 库采用正则表达式提取有关信息，并保存为 json 格式的 txt 文本，代码中用到了 logging 库输出信息，可区分内容级别，相比 print 输出定制化程度更高，且线程安全。还用到了 multiprocessing 库实现多进程爬取，全部代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"></span><br><span class="line"><span class="comment"># logging 用来输出信息，相比 print 线程安全</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br><span class="line">BASE_URL = <span class="string">&#x27;https://ssr1.scrape.center&#x27;</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span>  <span class="comment"># 定义页面数量</span></span><br><span class="line">RESULT_DIR = <span class="string">&#x27;results&#x27;</span>  <span class="comment"># 存储文件夹</span></span><br><span class="line">exists(RESULT_DIR) <span class="keyword">or</span> makedirs(RESULT_DIR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl page by url and return its html</span></span><br><span class="line"><span class="string">    :param url: page url</span></span><br><span class="line"><span class="string">    :return: html of the page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        logging.error(<span class="string">&#x27;get invalid status code %s while crawling %s&#x27;</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while cring %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_index</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl index page</span></span><br><span class="line"><span class="string">    :param page: page of index page</span></span><br><span class="line"><span class="string">    :return: html of index page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    index_url = <span class="string">f&#x27;<span class="subst">&#123;BASE_URL&#125;</span>/page/<span class="subst">&#123;page&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> crawl_page(index_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    parse detail url</span></span><br><span class="line"><span class="string">    :param html: html of index page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?class=&quot;name&quot;&gt;&#x27;</span>)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        detail_url = urljoin(BASE_URL, item)</span><br><span class="line">        <span class="comment"># logging.info(&#x27;get detail url %s&#x27;, detail_url)</span></span><br><span class="line">        <span class="keyword">yield</span> detail_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单独定义一个 crawl_detail 可使逻辑更清晰，灵活性更好</span></span><br><span class="line"><span class="string">    如果后续需要添加日志输出、预处理等功能就不用改动 crawl_page 方法</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> crawl_page(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    parse detail page</span></span><br><span class="line"><span class="string">    :param html:</span></span><br><span class="line"><span class="string">    :return: data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cover_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;class=&quot;item.*?&lt;img.*?src=&quot;(.*?)&quot;.*?class=&quot;cover&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line">    name_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>)</span><br><span class="line">    categories_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;button.*?category.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/button&gt;&#x27;</span>, re.S)</span><br><span class="line">    published_at_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)\s?上映&#x27;</span>)</span><br><span class="line">    drama_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;class=&quot;drama.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br><span class="line">    score_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;p.*?class=&quot;score.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line">    cover = re.search(cover_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(cover_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    name = re.search(name_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(name_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    categories = re.findall(categories_pattern, html) <span class="keyword">if</span> re.findall(categories_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    published_at = re.search(published_at_pattern, html).group(<span class="number">1</span>) <span class="keyword">if</span> re.search(published_at_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    drama = re.search(drama_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(drama_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    score = <span class="built_in">float</span>(re.search(score_pattern, html).group(<span class="number">1</span>).strip()) <span class="keyword">if</span> re.search(score_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;publish_at&#x27;</span>: published_at,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Save data to json file</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULT_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">page</span>):</span></span><br><span class="line">    index_html = crawl_index(page)</span><br><span class="line">    detail_urls = parse_index(index_html)</span><br><span class="line">    <span class="comment"># logging.info(&#x27;detail urls %s&#x27;, list(detail_urls))</span></span><br><span class="line">    <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">        detail_html = crawl_detail(detail_url)</span><br><span class="line">        data = parse_detail(detail_html)</span><br><span class="line">        logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>, data)</span><br><span class="line">        logging.info(<span class="string">&#x27;save data to json file&#x27;</span>)</span><br><span class="line">        save_data(data)</span><br><span class="line">        logging.info(<span class="string">&#x27;data saved successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># Pycharm 输入快捷键 main</span></span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 登录土巴兔，解决 RSA 加密</title>
    <url>/archives/6310.html</url>
    <content><![CDATA[<p>使用 python3 模拟登录土巴兔装修网，主要解决 RSA 加密问题</p>
<p><img data-src="https://i.loli.net/2021/06/07/b6g9NspVKuXcPd8.png"></p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先进行一次登录，在开发者工具里搜索关键词</p>
<p><img data-src="https://i.loli.net/2021/06/05/NZC3DYEXJbIwtFc.png"></p>
<p>可以看到账号和密码都经过了加密处理，接下来就继续找加密函数，可以看到名为 loginAndReg.js 的文件，点进去一看很明显是 <code>jQuery </code>的语法，其中对数据进行了 RSA 算法加密</p>
<p><img data-src="https://i.loli.net/2021/06/05/u4JBDqfwbyI96Ev.png"></p>
<p>开始常规操作，下断点，一步步找到关键的 <code>public_key</code></p>
<p><img data-src="https://i.loli.net/2021/06/05/dAKpw9cBjFrRqHT.png"></p>
<p><img data-src="https://i.loli.net/2021/06/05/P9pxErM6cBwYnoU.png"></p>
<p><img data-src="https://i.loli.net/2021/06/05/DzshSRTyMqLUwvV.png"></p>
<p><img data-src="https://i.loli.net/2021/06/05/XE4OMspPUx37NZI.png"></p>
<p><code>public_key</code> 找到了，即 RSA 算法的公钥，关键的解决掉了，接下来就是一个验证码的处理过程，不细展开了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">To8To</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,username,password</span>):</span></span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.username = self.RSAString(username)</span><br><span class="line">        self.password = self.RSAString(password)</span><br><span class="line">        self.login()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># RSA算法并进行urlencode编码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RSAString</span>(<span class="params">self,text</span>):</span></span><br><span class="line">        publickeystr = <span class="string">&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhNhuAr4UjFv+cj99PbAQWWx9H</span></span><br><span class="line"><span class="string">X+3jSRThJqJdXkWUMFMTRay8EYRtPFIiwiOUU4gCh4ePMxiuZJWUBHe1waOkXEFc</span></span><br><span class="line"><span class="string">Kg17luhVqECsO+EOLhxa3yHoXA5HcSKlG85hNV3G4uQCr+C8SOE0vCGTnMdnEGmU</span></span><br><span class="line"><span class="string">nG1AGGe44YKy6XR4VwIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----&quot;&quot;&quot;</span></span><br><span class="line">        result = rsa.encrypt(text.encode(<span class="string">&#x27;utf-8&#x27;</span>),rsa.PublicKey.load_pkcs1_openssl_pem(publickeystr.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> requests.utils.quote(base64.b64encode(result).decode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登陆土巴兔</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&quot;https://www.to8to.com/new_login.php&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;439&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="comment"># &#x27;Cookie&#x27;: &#x27;uid=CgoLDl+fxedYQcbnA9+SAg==; sourcepath=b1; to8to_landtime=1604306408; to8to_keywordlist=,,,,,,,,,土巴兔; tracker2019session=%7B%22session%22%3A%22175881d12a348b-054bffcd976ceb-c781f38-2073600-175881d12a4664%22%7D; tracker2019jssdkcross=%7B%22distinct_id%22%3A%22175881d12a823b-0b99c9a8d8c678-c781f38-2073600-175881d12a93b1%22%7D; to8to_tcode=sz; to8to_tname=%E6%B7%B1%E5%9C%B3; to8to_townid=1130; Hm_lvt_dbdd94468cf0ef471455c47f380f58d2=1604306408; to8tocookieid=16ca84d48a125ffcf2b9c3901c5edc0f853582; to8tosessionid=s_ab26dc179eaefefdea5b3b108cbf2bf1; to8to_cook=OkOcClPzRWV8ZFJlCIF4Ag==; tender_popup_flag=true; layer-popup=true; to8to_landpage=http%3A//sz.to8to.com/; to8to_sourcepage=; to8to_nowpage=http%253A%252F%252Fsz.to8to.com%252F; PHPSESSID=bo9224bbpec2hms9upgn240105; agreementRead=true; Hm_lpvt_dbdd94468cf0ef471455c47f380f58d2=1604307019; act=freshen&#x27;,</span></span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.to8to.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://www.to8to.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;val&#x27;</span>: self.username,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: self.password</span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.post(url=url,headers=headers,data=data)</span><br><span class="line">        print(response.text)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;用户名不存在&quot;</span> <span class="keyword">in</span> response.text <span class="keyword">or</span> <span class="string">&quot;登录失败次数过多，请30分钟后再试！&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            html = etree.HTML(response.text)</span><br><span class="line">            yzm_url = <span class="string">&#x27;https:&#x27;</span> + html.xpath(<span class="string">&#x27;//img[@id=&quot;passport&quot;]/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            data[<span class="string">&#x27;yzm&#x27;</span>] = self.img_to_text(yzm_url)</span><br><span class="line">            response = self.session.post(url=url, headers=headers, data=data)</span><br><span class="line">            print(response.text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证码识别</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">img_to_text</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        parses = requests.utils.urlparse(url)</span><br><span class="line">        path = parses.path + parses.params + <span class="string">&#x27;?&#x27;</span> + parses.query</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;referrer&#x27;</span>:<span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;path&#x27;</span>: path,</span><br><span class="line">            <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-user&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url=url,headers=headers)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;yzm.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.content)</span><br><span class="line">        yzm = Image.<span class="built_in">open</span>(<span class="string">&#x27;yzm.png&#x27;</span>)</span><br><span class="line">        yzm = yzm.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        threshold = <span class="number">127</span></span><br><span class="line">        table = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">1</span>)</span><br><span class="line">        yzm.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pytesseract.image_to_string(yzm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    To8To(<span class="string">&#x27;账号&#x27;</span>,<span class="string">&#x27;密码&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img data-src="https://i.loli.net/2021/06/05/GCSr5vm9MTwgjpt.png"></p>
<h2 id="声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。"><a href="#声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。" class="headerlink" title="声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。"></a>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记四 -- 数据的存储</title>
    <url>/archives/39ed07bf.html</url>
    <content><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" />

<p>解析库解析出数据后，可以将数据保存文本文件，如 TXT、JSON、CSV 等，也可以将数据保存到数据库 MySQL，非关系型数据库 MongoDB、Redis 等，另外，还可以直接把数据存储到搜索引擎（如 Elasticsearch）中，以便检索和查看。</p>
<span id="more"></span>

<h3 id="TXT-文本文件存储"><a href="#TXT-文本文件存储" class="headerlink" title="TXT  文本文件存储"></a>TXT  文本文件存储</h3><p>基本用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"><span class="comment">#简化写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">	file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>文件打开方式包括：</p>
<ul>
<li>r：以只读方式打开，默认；</li>
<li>rb：以二进制只读方式打开，通常用于音频、图片、视频等二进制文件；</li>
<li>r+：以读写方式打开；</li>
<li>rb+：以二进制读写方式打开；</li>
<li>w：以写入方式打开，如存在则覆盖，不存在则新建；</li>
<li>wb：以二进制写入方式打开，如存在则覆盖，不存在则新建；</li>
<li>w+：以读写方式打开，如存在则覆盖，不存在则新建；</li>
<li>wb+：以二进制读写方式打开，如存在则覆盖，不存在则新建；</li>
<li>a：以追加方式打开，如存在则追加到已有内容后，不存在则新建；</li>
<li>ab：以二进制追加方式打开，如存在则追加到已有内容后，不存在则新建；</li>
<li>a+：以读写方式打开，如存在则追加到已有内容后，不存在则新建；</li>
<li>ab+：以二进制追加方式，如存在则追加到已有内容后，不存在则新建；</li>
</ul>
<h3 id="JSON-文件存储"><a href="#JSON-文件存储" class="headerlink" title="JSON 文件存储"></a>JSON 文件存储</h3><p>基本用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 JSON，JSON 字符串中必须使用双引号，不然会报错</span></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Bob&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;: &quot;male&quot;</span></span><br><span class="line"><span class="string">&#125;, &#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Selina&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;: &quot;female&quot;</span></span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">data = json.loads(text) </span><br><span class="line">print(data1)</span><br><span class="line">print(<span class="built_in">type</span>(data2))</span><br><span class="line"><span class="comment"># load 方法传入文件对象，使用 open 方法读取；loads 传入 JSON 字符串，使用更灵活</span></span><br><span class="line">data2 = json.load(<span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">[&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Selina&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;]</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 输出 <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">with</span> <span class="title">open</span>(<span class="params"><span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span></span>) <span class="title">as</span> <span class="title">file</span>:</span></span><br><span class="line">    <span class="comment"># 使用 intend 参数可保存为 JSON 对象缩进格式，表示缩进字符个数</span></span><br><span class="line">    <span class="comment"># 默认输出 Unicode 字符，使用 ensure_ascii=False 可输出中文</span></span><br><span class="line">    file.write(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>



<h3 id="CSV-文件存储"><a href="#CSV-文件存储" class="headerlink" title="CSV 文件存储"></a>CSV 文件存储</h3><p>基本用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file: <span class="comment"># 可加 encodeing 指定编码格式</span></span><br><span class="line">    writer = csv.writer(file) <span class="comment"># 可加 delimiter=&#x27; &#x27; 参数，自定义输入内容分隔符</span></span><br><span class="line">    writer.writerow([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;20&#x27;</span>])</span><br><span class="line">    writer.writerows([[<span class="string">&#x27;10002&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], [<span class="string">&#x27;10003&#x27;</span>, <span class="string">&#x27;Jodan&#x27;</span>, <span class="string">&#x27;21&#x27;</span>]])</span><br><span class="line">    </span><br><span class="line">------------- result -------------</span><br><span class="line">data.csv:</span><br><span class="line">	<span class="built_in">id</span>,name,age</span><br><span class="line">	<span class="number">10001</span>,Mike,<span class="number">20</span></span><br><span class="line">	<span class="number">10002</span>,Bob,<span class="number">21</span></span><br><span class="line">	<span class="number">10003</span>,Jodan,<span class="number">21</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment"># 字典写入方式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    fieldnames = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    writer = csv.DictWriter(file, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;20&#x27;</span>&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure>

<h3 id="MySQL-存储"><a href="#MySQL-存储" class="headerlink" title="MySQL 存储"></a>MySQL 存储</h3><p>关系型数据库是基于关系的数据库，而关系模型是基于二维表来保存的，所以关系型数据库中数据的存储方式就是行列组成的表，每一列代表一个字段、每一行代表一条记录。表可以看做实体的集合，实体之间存在的联系需要通过表与表之间的关联关系体现，例如主键和外键的关联关联。由多个表组成的数据库，就是关系型数据库。</p>
<p>关系型数据库有很多，如 SQLite、MySQL、Oracle、SQL Server、DB2 等，本节主要了解 MySQL 数据库的存储操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可同时指定数据库和编码方式，参数为 db, charset</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT VERSION()&#x27;</span>)</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&#x27;Database version: &#x27;</span>, data)</span><br><span class="line"><span class="comment"># 数据库和数据表都可以手动新建</span></span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8mb4&quot;</span>)</span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY(id))&quot;</span>)</span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="built_in">id</span> = <span class="string">&#x27;20220220&#x27;</span></span><br><span class="line">user = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO students(id, name, age) values(%s, %s, %s)&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (<span class="built_in">id</span>, user, age))</span><br><span class="line">    <span class="comment"># 数据增删改都需要 commit 操作</span></span><br><span class="line">    db.commit()</span><br><span class="line">    print(<span class="string">&#x27;Data inserted successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 执行失败则执行数据回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line">    print(e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<p><strong>事务</strong>机制能够保证数据的完整性，例如插入一条数据，要么全部插入，要么都不插入，这就是事务的原子性，其他还有三个属性——一致性、隔离性和持久性，这四个属性通常称为 ACID 特性：</p>
<ul>
<li>原子性（atomicity）：事务是一个不可分割的工作单位，事务中包括的操作要么都做、要么都不做。</li>
<li>一致性（consistency）：事务必须从一个一致性状态变到另一个一致性状态。一致性和原子性是密切相关的。</li>
<li>隔离性（isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持久性（durability）：也成永久性（permanence），指一个事务一旦提交，它对数据库中数据做的改变就该是永久性的。接下来的操作或故障不应该对数据有任何影响。</li>
</ul>
<p>上面的插入操作有一个弊端，如果需要增加字段，就需要该 SQL 语句，很不方便，我们可以将其改为一个通过方法，只需传入一个动态变化的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220220&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;:Bob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">keys = <span class="string">&#x27;, &#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES(&#123;values&#125;)&#x27;</span>.<span class="built_in">format</span>(table=table, keys=keys, values=values)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql, <span class="built_in">tuple</span>(data.values())):</span><br><span class="line">        print(<span class="string">&#x27;Successful&#x27;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line">    print(e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">    db.rollback()</span><br></pre></td></tr></table></figure>

<p>更新和删除操作类似，这里还需要说明下查询过程常用的几个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.execute(sql)</span><br><span class="line">print(<span class="string">&#x27;Count: &#x27;</span>, cursor.rowcount) <span class="comment"># 获取查询结果条数</span></span><br><span class="line">result = cursor.fetchone() <span class="comment"># 获取第一条查询结果</span></span><br><span class="line">result = cursor.fetchall() <span class="comment"># 获取所有数据</span></span><br><span class="line"><span class="comment"># 如果数据较多，使用 fetchall() 占用开销较大，推荐下面方法</span></span><br><span class="line">row = cursor.fetchone()</span><br><span class="line"><span class="keyword">while</span> row:</span><br><span class="line">    print(<span class="string">&#x27;Row: &#x27;</span>, row)</span><br><span class="line">    row = cursor.fetchone()</span><br></pre></td></tr></table></figure>



<h3 id="MongoDB-文档存储"><a href="#MongoDB-文档存储" class="headerlink" title="MongoDB 文档存储"></a>MongoDB 文档存储</h3><p>NoSQL(Not Only SQL)，意为不仅仅是 SQL，泛指非关系型数据库。NoSQL 是基于键值对的，不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</p>
<p>非关系型数据库可细分为：</p>
<ul>
<li>键值存储数据库：Redis、Voldemort 和 Oracle BDD 等；</li>
<li>列存储数据库：Cassandra、HBase 和 Riak 等；</li>
<li>文档型数据库：CouchDB 和 MongoDB 等；</li>
<li>图形数据库：Neo4J、InfoGrid 和 Infinite Graph 等。</li>
</ul>
<p>对爬虫的数据存储来说，非关系型数据库往往更简单高效。</p>
<p>MongoDB 是用 C++ 编写的，内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># client = pymongo.MongoClient(&#x27;mongodb://localhost:27017/&#x27;)</span></span><br><span class="line">db = client.test  <span class="comment"># 或 client[&#x27;test&#x27;]</span></span><br><span class="line">collection = db.students  <span class="comment"># db[&#x27;students&#x27;]</span></span><br><span class="line">student = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220220&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jordan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert_one(student)</span><br><span class="line">result1 = collection.insert_many([student1, student2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;pymongo.results.InsertOneResult <span class="built_in">object</span> at <span class="number">0x000001F46043BE80</span>&gt;</span><br><span class="line">62123cdad1351490060fecf3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">result2 = collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>&#125;)</span><br><span class="line">result3 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">20</span>&#125;&#125;)  <span class="comment"># 查找所有数据，结果为生成器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查询条件中的比较符号一览：</span></span><br><span class="line"><span class="string">$lt, $gt, $lte, $gte, $ne, $in, $nin </span></span><br><span class="line"><span class="string">小于，大于，小于等于，大于等于，不等于，在范围内，不在范围内</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">功能符号一览：</span></span><br><span class="line"><span class="string">$regex</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数</span></span><br><span class="line">count = collection.find().count()  </span><br><span class="line"><span class="comment"># 排序，偏移，指定获取个数 -&gt; sort result: [&#x27;Harden&#x27;, &#x27;Jordan&#x27;, &#x27;Kevin&#x27;, &#x27;Mark&#x27;, &#x27;Mike&#x27;]</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line">-&gt; [&#x27;Kevin&#x27;, &#x27;Mark&#x27;]</span><br><span class="line"><span class="comment"># 数据量非常庞大时（千万、亿级别），最好不要用大偏移，可能导致内存溢出，可使用如下操作来查询</span></span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line">collection.find(&#123;<span class="string">&#x27;_id&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: ObjectId(<span class="string">&#x27;62123cdad1351490060fecf3&#x27;</span>)&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: student&#125;)  <span class="comment">## update_many()</span></span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)  <span class="comment"># 匹配数据条数和影响的数据条数</span></span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;pymongo.results.UpdateResult <span class="built_in">object</span> at <span class="number">0x10d17b678</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">result = collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Kevin&#x27;</span>&#125;)  <span class="comment">## delete_many()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">PyMongo 还提供了一些组合方法，如 </span></span><br><span class="line"><span class="string">find_one_and_delete, find_one_and_replace, find_one_and_update 等</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>还有一些功能符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">含义</th>
<th align="center">实例</th>
<th align="center">实例含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$regex</td>
<td align="center">正则匹配</td>
<td align="center">{‘name’, {‘$regex’: ‘^M.*’}}</td>
<td align="center">name 以 M 开头</td>
</tr>
<tr>
<td align="center">$exists</td>
<td align="center">属性是否存在</td>
<td align="center">{‘name’, {‘$exists’: True}}</td>
<td align="center">存在 name 属性</td>
</tr>
<tr>
<td align="center">$type</td>
<td align="center">类型判断</td>
<td align="center">{‘age’, {‘$type’: ‘int’}}</td>
<td align="center">age 类型为 int</td>
</tr>
<tr>
<td align="center">$mod</td>
<td align="center">数字模操作</td>
<td align="center">{‘age’, {‘$mod’: [5, 0]}}</td>
<td align="center">age 模 5 余 0</td>
</tr>
<tr>
<td align="center">$text</td>
<td align="center">文本查询</td>
<td align="center">{‘$text’: {‘$search’: ‘Mike’}}</td>
<td align="center">text 类型属性中包含 Mike</td>
</tr>
<tr>
<td align="center">$where</td>
<td align="center">高级条件查询</td>
<td align="center">{‘$where’: ‘obj.fans_count == obj.follows_count’}</td>
<td align="center">自身粉丝数等于关注数</td>
</tr>
</tbody></table>
<p><a href="https://docs.mongoing.com/">官方手册</a></p>
<h3 id="Redis-缓存存储"><a href="#Redis-缓存存储" class="headerlink" title="Redis 缓存存储"></a>Redis 缓存存储</h3><p>Redis 是一个基于内存的、高效的键值型非关系型数据库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">- 也可以这样连接</span></span><br><span class="line"><span class="string">pool = ConnectionPool(host=&#x27;localhost&#x27;, port=6379, db=0, password=&#x27;test&#x27;)</span></span><br><span class="line"><span class="string">redis = StrictRedis(connection_pool=pool)</span></span><br><span class="line"><span class="string">- ConnectionPool 支持 URL 连接</span></span><br><span class="line"><span class="string">url = &#x27;redis://:test@localhost:679/0&#x27;</span></span><br><span class="line"><span class="string">pool = ConnectionPool.from.url(url)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">print(redis.get(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>Redis 支持多种数据存储结构，并提供了丰富的 API，包括键操作、字符串操作、列表操作、集合操作、有序集合操作、散列操作。具体可以查看 <a href="https://redis.com.cn/commands.html">Redis 命令手册</a></p>
<h3 id="Elasticsearch-搜索引擎存储"><a href="#Elasticsearch-搜索引擎存储" class="headerlink" title="Elasticsearch 搜索引擎存储"></a>Elasticsearch 搜索引擎存储</h3><p>如果为了便于存储和检索，想要实现自己的搜索引擎，Elasticsearch 就是不二之选。这是一个全文搜索引擎，可以快速存储、检索和分析海量数据。</p>
<p>Elasticsearch是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 的基础之上。</p>
<p>Lucene 是目前拥有最先进、高性能的全功能搜索引擎功能的库，Elasticsearch 对 Lucene 做了一层封装，提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索，可以如此形容：</p>
<ul>
<li>一个分布式的实时文档存储库，每个字段都可以被索引与搜索；</li>
<li>一个分布式的实时分布搜索引擎；</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li>
</ul>
<p><a href="https://blog.csdn.net/winnershili/article/details/122944188">安装方法</a>， Kibana 支持对 Elasticsearch 数据进行可视化和分析，配合使用更佳。</p>
<p>有几个概念需要明确：</p>
<ul>
<li>节点和集群：单个 Elasticsearch 实例称为一个节点（Node），一组节点构成一个集群（Cluster）；</li>
<li>索引：即 index，Elasticsearch 会索引所有字段，经过处理后写入一个反向索引（inverted index）。Elasticsearch 数据管理的顶层单位就是索引，相当于数据库的概念，另外，索引名字必须小写；</li>
<li>文档：索引里的单条记录称为文档（document），同一个索引中的文档不要求有相同的结构（scheme），但最好保持一致，有助提高搜索效率；</li>
<li>类型：文档可以分组，叫做类型（Type），类似 MySQL 中的数据表、MongoDB 中的集合。不同类型的文档应该具有相似的结构，即应该把不同性质的数据存成两个索引。Elasticsearch 6.x 每个索引只能包含一个类型，而到 7.x 会移除类型；</li>
<li>字段：每个文档类似 JSON 结构，包含许多字段，每个字段有其对应的值，类比为 MySQL 数据表中字段。</li>
</ul>
<p>用对比图来直观类比 Elasticsearch 和传统关系型数据库：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Reletional DB -&gt; Database -&gt; Tables -&gt; Rows      -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices  -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>

<p>Elasticsearch 的特殊强大之处就在检索功能</p>
<ul>
<li>Elasticsearch 对模糊搜索非常擅长（搜索速度很快）</li>
<li>从 Elasticsearch 搜索到的数据可以根据<strong>评分</strong>过滤，如只返回评分高的给用户</li>
<li>没有那么准确的关键字也能搜出相关的结果（能匹配有相关性的记录）</li>
</ul>
<p><a href="https://elasticsearch-py.readthedocs.io/en/master/">使用手册</a>，<a href="https://cloud.tencent.com/developer/article/1583402">什么是 Elasticsearch？一篇搞懂</a></p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>为了降低进程间的耦合度，需要一个类似消息队列的中间件来存储和转发消息，实现进程间通信。</p>
<p>RabbitMQ 是一款使用 Erlang 语言开发的，实现 AMQP(高级消息队列协议)的开源消息中间件，其主要特点有面向消息、队列、路由(包括点对点和发布/订阅)，可靠性、安全性。具体特点有以下这些：</p>
<ul>
<li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li>
<li>灵活的分发消息策略。这应该是 RabbitMQ 的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>
<li>支持集群。多台 RabbitMQ 服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li>高可用：消息队列在部分节点出问题的情况下仍然可用。</li>
<li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>支持多种语言客户端。RabbitMQ 几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li>
<li>可视化管理界面。RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li>
<li>插件机制。RabbitMQ 提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li>
</ul>
<p>使用上主要三个步骤，声明队列，生产内容和消费内容。</p>
<p><code>producer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME, body=<span class="string">&#x27;Hel World!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>consumer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;Get <span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># auto_ack=True 表示获取消息后会通知消息队列当前消息已处理</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;scrape&#x27;</span>, auto_ack=<span class="literal">True</span>, on_message_callback=callback)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<p>运行 <code>producer.py</code>后会往消息队列放入一个消息，<code>consumer.py</code>运行后会一直监听，可以发现输出结果为<code>Get b&#39;Hello World!&#39;</code></p>
<p>上面的例子实现的是最简单的生产者和消费者间通信，但这在实际爬虫中是不太现实的，因为把消费者实现为了“订阅”模式，会一直处于监听状态，一旦有消息就要立马处理，无法主动控制取用消息的时机。下面我们实现一种随取随用的例子，里面还用到了优先级队列和队列持久化技术：</p>
<p><code>producer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 input() 来获取生产者数据，输入字符串和优先级，输入后会被放入消息队列中</span></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, priority = <span class="built_in">input</span>().split()</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME, properties=pika.BasicProperties(priority=<span class="built_in">int</span>(priority)),</span><br><span class="line">                          body=data)</span><br><span class="line">    print(<span class="string">f&#x27;Put <span class="subst">&#123;data&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">foo <span class="number">40</span></span><br><span class="line">Put foo</span><br><span class="line">bar <span class="number">20</span></span><br><span class="line">Put bar</span><br><span class="line">baz <span class="number">50</span></span><br><span class="line">Put baz</span><br></pre></td></tr></table></figure>

<p><code>consumer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 input() 来控制消费者何时获取下一个数据，同时按照优先级取出对应消息</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    method_frame, header, body = channel.basic_get(queue=<span class="string">&#x27;scrape&#x27;</span>, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        print(<span class="string">f&#x27;Get <span class="subst">&#123;body&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>

<p>实战，爬取电源网站链接</p>
<p><code>producer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle  <span class="comment"># 序列化</span></span><br><span class="line"></span><br><span class="line">TOTAL = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape_queue&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL + <span class="number">1</span>):</span><br><span class="line">    url = <span class="string">f&#x27;https://ssr1.scrape.center/detail/<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">    request = requests.Request(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME,</span><br><span class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>),</span><br><span class="line">                          body=pickle.dumps(request))</span><br><span class="line">    print(<span class="string">f&#x27;Put request of <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s2.loli.net/2022/02/21/M1kRlrJvc3uUDgE.png"></p>
<p><code>consumer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape_queue&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = session.send(request.prepare())</span><br><span class="line">        print(<span class="string">f&#x27;success scraped <span class="subst">&#123;response.url&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        print(<span class="string">f&#x27;error occurred when scraping <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    method_frame, header, body = channel.basic_get(queue=QUEUE_NAME, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        request = pickle.loads(body)</span><br><span class="line">        print(<span class="string">f&#x27;Get <span class="subst">&#123;request&#125;</span>&#x27;</span>)</span><br><span class="line">        scrape(request)</span><br></pre></td></tr></table></figure>

<p><img data-src="https://s2.loli.net/2022/02/21/qv4mLSx3awF8i79.png"></p>
<p>可以看到，消费者依次取出请求对象完成了一个个爬取任务。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬取百度文库数据</title>
    <url>/archives/62201.html</url>
    <content><![CDATA[<p>使用 python3 抓取百度文库特点文章数据，只对可查看的内容有效。通过分析查找传输内容数据的 js 链接，而后请求即可</p>
<img data-src="https://i.loli.net/2021/06/07/igN6U5TuVYI7wrC.png"  />

<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>经过排查，发现数据所在文件位置</p>
<p><img data-src="https://i.loli.net/2021/06/05/BRLcKDuITevVJSf.png"></p>
<p>查看其 url 请求，发现有个 <code>authorization</code></p>
<p><img data-src="https://i.loli.net/2021/06/05/geCMP8j7KS3wxzH.png"></p>
<p>开启 Ctrl F 大法，找到了 url 请求的出处，用正则把其中的链接给提前出来就可以取到数据了</p>
<p><img data-src="https://i.loli.net/2021/06/05/FVmD7PR8nYULI6t.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WenKu</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.get_url()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&quot;https://wenku.baidu.com/view/b35a73c5ee3a87c24028915f804d2b160b4e86c6&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;wenku.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.get(url=url,headers=headers)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        script_content = html.xpath(<span class="string">&#x27;//script[2]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        recompile = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?var pageData = (.*?);.*?window.pageData = pageData;.*?&#x27;</span>,re.S)</span><br><span class="line">        page_data = json.loads(recompile.findall(script_content)[<span class="number">0</span>])</span><br><span class="line">        js = json.loads(page_data[<span class="string">&#x27;readerInfo2019&#x27;</span>][<span class="string">&#x27;htmlUrls&#x27;</span>])[<span class="string">&#x27;json&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> page_load_urls <span class="keyword">in</span> js:</span><br><span class="line">            page_load_url = page_load_urls[<span class="string">&#x27;pageLoadUrl&#x27;</span>]</span><br><span class="line">            self.get_data(page_load_url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;wkbjcloudbos.bdimg.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.get(url=url,headers=headers)</span><br><span class="line">        print(response.content.decode(<span class="string">&#x27;unicode_escape&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    WenKu()</span><br></pre></td></tr></table></figure>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img data-src="https://i.loli.net/2021/06/05/HzgZkCqL15JyNTj.png"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/archives/f89cb603.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/6DqeRPSahmWwAYF.jpg" style="zoom:50%;" />

<p>二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)，要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树。</p>
<p>很多书籍里，但凡讲到平衡二叉查找树，就会拿红黑树作为例子。不仅如此，如果你有一定的开发经验，你会发现，在工程中，很多用到平衡二叉查找树的地方都会用红黑树。你有没有想过，<strong>为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</strong></p>
<span id="more"></span>

<h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。</p>
<p>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是[AVL](<a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树 - 维基百科，自由的百科全书 (wikipedia.org)</a>) 树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p>
<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p>
<p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p>
<p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，它的定义是不严格符合平衡二叉查找树的定义的。红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重</strong>。</p>
<p>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log2n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log2n 就好了。</p>
<p>首先，我们来看，如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？</p>
<p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p>
<img data-src="https://i.loli.net/2021/08/17/iFYVgouaCSKzs84.jpg" style="zoom:50%;" />

<p>前面红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p>
<p>完全二叉树的高度近似 log2n，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 log2n。我们现在知道只包含黑色节点的“黑树”的高度，那我们现在把红色节点加回去，高度会变成多少呢？</p>
<p>从上面红黑树的例子和定义看，在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。</p>
<p>所以，红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>几种动态数据结构对比：</p>
<ul>
<li><p>散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。</p>
</li>
<li><p>跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。</p>
</li>
<li><p>红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。</p>
</li>
</ul>
<hr>
<img data-src="https://i.loli.net/2021/08/17/D4Gh3ySZAavLlQ8.jpg" style="zoom:50%;" />

<p>上一节，我们讲到红黑树定义的时候，提到红黑树的叶子节点都是黑色的空节点。当时我只是粗略地解释了，这是为了代码实现方便，那更加确切的原因是什么呢？</p>
<h3 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h3><p>红黑树的平衡过程跟魔方复原非常神似，大致过程就是：<strong>遇到什么样的节点排布，我们就对应怎么去调整</strong>。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p>
<p>先介绍两个非常重要的操作，<strong>左旋（rotate left）、右旋（rotate right）</strong>。左旋全称其实是叫<strong>围绕某个节点的左旋</strong>，那右旋的全称估计你已经猜到了，就叫<strong>围绕某个节点的右旋</strong>。</p>
<img data-src="https://i.loli.net/2021/08/17/2RMTkCSpXZWD358.jpg" style="zoom:50%;" />

<h3 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h3><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</p>
<ul>
<li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li>
</ul>
<p>除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p>
<p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫做<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p>
<p>新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。</p>
<p><strong>CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色</strong>，我们就依次执行下面的操作：</p>
<ul>
<li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；</li>
<li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li>
<li>关注节点变成 a 的祖父节点 c；</li>
<li>跳到 CASE 2 或者 CASE 3。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/JDXZ1aEyduUKekG.jpg" style="zoom:50%;" />

<p><strong>CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点</strong>，我们就依次执行下面的操作：</p>
<ul>
<li>关注节点变成节点 a 的父节点 b；</li>
<li>围绕新的关注节点b 左旋；</li>
<li>跳到 CASE 3。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/Gb9yfuQrqJ5MlwH.jpg" style="zoom:50%;" />

<p><strong>CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</strong>，我们就依次执行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的祖父节点 c 右旋；</li>
<li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</li>
<li>调整结束。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/Ernv3yQxod1SOaw.jpg" style="zoom:50%;" />

<h3 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h3><p>删除操作的平衡调整分为两步，第一步是<strong>针对删除节点初步调整</strong>。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是<strong>针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p>
<ol>
<li><strong>针对删除节点初步调整</strong></li>
</ol>
<p>这里需要注意一下，红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p>
<p>在下面的讲解中，如果一个节点既可以是红色，也可以是黑色，在画图的时候，我会用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，我会用左上角的一个小黑点来表示额外的黑色。</p>
<p><strong>CASE 1：如果要删除的节点是 a，它只有一个子节点 b</strong>，那我们就依次进行下面的操作：</p>
<ul>
<li>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li>
<li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li>
<li>调整结束，不需要进行二次调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/15/31TUMeu7Ymi6Xvg.jpg" style="zoom:50%;" />

<p><strong>CASE 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</strong>。我们就依次进行下面的操作：</p>
<ul>
<li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li>
<li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li>
<li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；</li>
<li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/fg3K8FRyrde4Hqj.jpg" style="zoom:50%;" />

<p><strong>CASE 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；</li>
<li>将节点 a 替换成后继节点 d；</li>
<li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li>
<li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；</li>
<li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/N8HPL5yF1DQzoAU.jpg" style="zoom:50%;" />

<ol start="2">
<li><strong>针对关注节点进行二次调整</strong></li>
</ol>
<p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p>
<p><strong>CASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的父节点 b 左旋；</li>
<li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li>
<li>关注节点不变；</li>
<li>继续从四种情况中选择适合的规则来调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/J6VTUz3wRKhi5bc.jpg" style="zoom:50%;" />

<p><strong>CASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li>
<li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li>
<li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；</li>
<li>关注节点从 a 变成其父节点 b；</li>
<li>继续从四种情况中选择符合的规则来调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/8Tvira7pKY9gOnZ.jpg" style="zoom:50%;" />

<p><strong>CASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的兄弟节点 c 右旋；</li>
<li>节点 c 和节点 d 交换颜色；</li>
<li>关注节点不变；</li>
<li>跳转到 CASE 4，继续调整。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/MxRpFfetV2N7TSj.jpg" style="zoom:50%;" />

<p><strong>CASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</strong>，我们就依次进行下面的操作：</p>
<ul>
<li>围绕关注节点 a 的父节点 b 左旋；</li>
<li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li>
<li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li>
<li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li>
<li>将关注节点 a 的叔叔节点 e 设置为黑色；</li>
<li>调整结束。</li>
</ul>
<img data-src="https://i.loli.net/2021/08/17/7YRw2l4mSnZ9K1Q.jpg" style="zoom:50%;" />

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p><strong>为什么红黑树的定义中，要求叶子节点是黑色的空节点？</strong></p>
<p>要我说，之所以有这么奇怪的要求，其实就是为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为我们刚刚讲的那几种情况。</p>
<p>还是有点不好理解，我通过一个例子来解释一下。假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”，我们往一棵红黑树中插入一个数据，新插入节点的父节点也是红色的，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。那我们应该如何调整呢？</p>
<img data-src="https://i.loli.net/2021/08/17/6Wb15uI2RdHPDFS.jpg" style="zoom: 50%;" />

<p>你会发现，这个时候，我们前面在讲插入时，三种情况下的平衡调整规则，没有一种是适用的。但是，如果我们把黑色的空节点都给它加上，变成下面这样，你会发现，它满足 CASE 2 了。</p>
<img data-src="https://i.loli.net/2021/08/17/iDdTgm5YP2BhbSt.jpg" style="zoom:50%;" />

<p>你可能会说，你可以调整一下平衡调整规则啊。比如把 CASE 2 改为“如果关注节点 a 的叔叔节点 b 是黑色或者不存在，a 是父节点的右子节点，就进行某某操作”。当然可以，但是这样的话规则就没有原来简洁了。</p>
<p>你可能还会说，这样给红黑树添加黑色的空的叶子节点，会不会比较浪费存储空间呢？答案是不会的。虽然我们在讲解或者画图的时候，每个黑色的、空的叶子节点都是独立画出来的。实际上，在具体实现的时候，我们只需要像下面这样，共用一个黑色的、空的叶子节点就行了。</p>
<img data-src="https://i.loli.net/2021/08/17/mapBqIcMj9Furyz.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性排序</title>
    <url>/archives/89c5f6b.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/fVpL8jIaYTs5yv6.jpg" style="zoom:50%;" />

<p>如何根据年龄给 100 万用户排序？</p>
<span id="more"></span>

<p> 这个问题用归并、快排也能搞定，但时间复杂度最低也是$O(nlongn)$，这次我们学习几种线性排序（Linear sort）：桶排序、计数排序、基数排序，时间复杂度都是$O(n)$。</p>
<h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<img data-src="https://i.loli.net/2021/08/17/6jH2cPAJTQvBYqS.jpg" style="zoom:50%;" />

<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong></p>
<p>当然是否定的。首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p>
<p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p>
<p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<p>举个例子，有10GB的订单数据需要按照订单金额进行排序（假设金额都是正数），但我们内存有限，只有几百MB，无法一次性加载10GB数据。</p>
<p>首先可以扫描一遍文件，看订单金额数据范围，假设扫描后得到金额在1元到10万元间，我们将订单金额划分到100个桶里，第一个桶存储1元到1000元之间的订单，第二桶存储1001元到2000元之间的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p>
<p>理想情况下，订单金额在1元到10万元之间均匀分布， 那订单就会均匀划分到100个文件中，每个小文件存储约100MB数据，再依次对其进行快排排序，等文件都排好序后，再按照文件编号，从小到大依次取出每个文件中的订单数据即可。</p>
<p>不过，你也发现了，订单按照金额不一定是均匀分布的，假如金额在1元到1000元之间的较多，那还可以将这个区间在此划分为跨度为100元的10个小区间，甚至继续划分，直到所有文件可以读入内存为止。</p>
<h3 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h3><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>现在假设所在省有 50 万考生，如何通过成绩快速排序得出名次呢？考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p>
<p>这就是计数排序的算法思想，跟桶排序非常类似，只是桶的大小粒度不一样。<strong>不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</strong></p>
<p>要搞明白这个问题，先简化下数据规模，假设只有8个考生，分数在0~5分之间，将其放到一个数组A[8]中：2,5,3,0,2,3,0,3</p>
<p>用C[6]表示桶，遍历考生分数，容易得到：</p>
<img data-src="https://i.loli.net/2021/08/05/kT19nlmAj87CShK.jpg" style="zoom:50%;" />

<p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。</p>
<img data-src="https://i.loli.net/2021/08/05/fn1N4psSJZb3W26.jpg" style="zoom:50%;" />

<p>现在问题是如何快速计算出每个分数的考生在有序数组中对应的存储位置呢？</p>
<p>我们先对C[6]数组顺序求和，C[k]里存储小于等于分数 k 的考生个数。</p>
<img data-src="https://i.loli.net/2021/08/05/DnK3VLPW6ywCQbk.jpg" style="zoom:50%;" />

<p>我们<strong>从后往前</strong>（为了稳定排序）扫描数组A，比如扫描到3，从数组C中取出下标为3的值7，表示分数小于等于3的考生有7个，即3是数组R的第7个元素，取出3放入数组R中，相应的C[3]减1。依次类推，扫描完整个数组A，数组R中的数据就是按照分数大小有序排序了。</p>
<img data-src="https://i.loli.net/2021/08/17/uViQdJvcwxEpasU.jpg" style="zoom:50%;" />

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，利用另一个数组来计数的实习方式就是将其称为计数排序的原因。</p>
<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p>
<p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p>
<h3 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h3><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p>
<p>之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，就可以用上基础排序了。</p>
<p>可以先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。先来看张过程分解图：</p>
<img data-src="https://i.loli.net/2021/08/17/JCgDPliSdn9K5BA.jpg" style="zoom:50%;" />

<p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p>
<p>当要排序的数据不是等长的，比如英文单词，可以把所有的单词补齐到相同长度，位数不够可以在后面补“0”。</p>
<p>总结一下，基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/archives/a4ce31d2.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/31/MoGBOnAhSrNsIic.jpg" style="zoom:50%;" />

<p>贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。先来看看如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。</p>
<span id="more"></span>

<h3 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h3><p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？</p>
<img data-src="https://i.loli.net/2021/08/31/9XlHKkf26GV1Mej.jpg" style="zoom:50%;" />

<p>我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。</p>
<p>这个问题本质上就是贪心算法，可以总结一下贪心算法解决问题的步骤：</p>
<ol>
<li><p>当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p>
</li>
<li><p>尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</p>
</li>
<li><p>举例验证贪心算法是否得到最优结果。严格证明贪心算法的正确性是很复杂的，设计较多数学推理，一般举几个例子验证即可。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p>
</li>
</ol>
<h3 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h3><ol>
<li><strong>分糖果</strong></li>
</ol>
<p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。</p>
<p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p>
<p>可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。</p>
<p>如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p>
<ol start="2">
<li><strong>钱币找零</strong></li>
</ol>
<p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
<p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。</p>
<ol start="3">
<li><strong>区间覆盖</strong></li>
</ol>
<p>假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p>
<img data-src="https://i.loli.net/2021/08/31/pex8BA6jSbROlfW.jpg" style="zoom:50%;" />

<p>这个处理思想在很多贪心算法问题中都有用到，比如任务调度、教师排课等等问题。</p>
<p>这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</p>
<p>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p>
<img data-src="https://i.loli.net/2021/08/31/HkgiFSfI7yljNLQ.jpg" style="zoom:50%;" />

<h3 id="如何用贪心算法实现霍夫曼编码？"><a href="#如何用贪心算法实现霍夫曼编码？" class="headerlink" title="如何用贪心算法实现霍夫曼编码？"></a>如何用贪心算法实现霍夫曼编码？</h3><p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p>
<p>假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)</span><br></pre></td></tr></table></figure>

<p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。它不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p>
<p>对于等长的编码来说，我们解压缩起来很简单。比如刚才那个例子中，我们用 3 个 bit 表示一个字符。在解压缩的时候，我们每次从文本中读取 3 位二进制码，然后翻译成对应的字符。但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</p>
<img data-src="https://i.loli.net/2021/08/31/wX4VyIJAriGnZxp.jpg" style="zoom:50%;" />

<p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p>
<img data-src="https://i.loli.net/2021/08/31/f25VwgtNoeSpLba.jpg" style="zoom:50%;" />

<p>如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？这里的处理稍微有些技巧。</p>
<p>我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p>
<img data-src="https://i.loli.net/2021/08/31/MTwHPpVdEYgNLum.jpg" style="zoom:50%;" />

<p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p>
<img data-src="https://i.loli.net/2021/08/31/vu5VPLzaEH8mWO6.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/archives/c6654282.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/VdcAmps3zq26fw4.jpg" style="zoom:50%;" />

<p>现在很多APP都有注册返佣的功能，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p>
<p><strong>那给定一个用户ID，如何查找该用户的“最终推荐人”？</strong></p>
<span id="more"></span>

<h3 id="如何理解递归？"><a href="#如何理解递归？" class="headerlink" title="如何理解递归？"></a>如何理解递归？</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。</p>
<p>举个例子，周末带着女票去看电影，她问你咱们坐在第几排啊？电影院太黑没法数，这会递归法就能上场了，你可以问你前面一排的哥们是第几排，你只要在他的数字上加一就能知道了。但是，前面的人也不清楚，所以他也问前面的人，依次前推，知道第一排的人说了答案，然后再一排排传回数字，最终你就能告诉女票位置了。</p>
<p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n)&#x3D;f(n-1)+1 其中，f(1)&#x3D;1</span><br></pre></td></tr></table></figure>

<p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return f(n-1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归需要满足的三个条件？"><a href="#递归需要满足的三个条件？" class="headerlink" title="递归需要满足的三个条件？"></a>递归需要满足的三个条件？</h3><p>只要问题满足以下三个条件，就可以用递归来解决。</p>
<ol>
<li>一个问题的解可以分解为几个子问题的解</li>
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li>
<li>存在递归终止条件</li>
</ol>
<h3 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h3><p>最关键的就是<strong>写出递推公式，找到终止条件</strong>。</p>
<p>举个例子。假设有n个台阶，每次你可以跨越1个台阶或2个台阶，请问走着n个台阶有多少种走法？如果有7个台阶，可以选择2,2,2,1走上去，也可以选择1,2,1,1,2走上去。</p>
<p>仔细思考，走法可以分为两类，第一步走1个台阶，以及第一步走2个台阶。n个台阶的走法就等于先走1阶后，n-1的走法，加上先走2阶后，n-2个台阶的走法，公式表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure>

<p>有了递推公式，再来考虑终止条件。当只有一个台阶时，不需要递归，只有一种走法。所以$f(1)=1$​​。这个条件够了吗？我们可以用$n=2，n=3$靠近临界点的数试验。</p>
<p>$n=2$​时，$f(2)=f(1)+f(0)$。如果终止条件只有$f(1)=1$​，那f(2)​就无法求解了，还需要满足$f(0)=1$，表示走0个台阶有一种走法，但这不符合逻辑。所以，还要把$f(2)=2$​也作为一种终止条件，表示走2个台阶有两种走法，一次走完或两次一步。</p>
<p>最后得到，递归终止条件就是$f(1)=1，f(2)=2$，当然，可以也应该再拿n=3，n=4来验证是否正确。得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(<span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">f(n) = f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>转成递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，写递归代码的关键就是<strong>找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong>。</p>
<p>前面电影院的例子比较简单，递归只调用一个分支，但实际问题往往更为复杂，需要分解为多个子问题。</p>
<p>人脑是有限的，更倾向于平铺直叙的思维方式，不要试图想清楚递和归的过程，这就进入了一个思维误区，重复的事让计算机来完成。</p>
<p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p>
<p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p>
<h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<p><strong>那么，如何避免出现堆栈溢出呢？</strong></p>
<p>可以通过在代码中限制调用递归的最大深度的方法来解决，递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度。</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ++depth；</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p>
<h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h3><p>除此之外，使用递归时还会出现重复计算的问题。刚才第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的:</p>
<img data-src="https://i.loli.net/2021/08/17/KcLTQAmVSOGhWaj.jpg" style="zoom:50%;" />

<p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>
<p>改造代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了这两个常见问题，递归还有很多其他问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p>
<h3 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h3><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p>
<p>电影院的例子，抛开场景，只看f(n)=f(n-1)+1这个递推公式，可以改写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = ret + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子也可以改写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上，所有的递归代码都可以改为这种迭代循环的非递归写法，因为递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>
<h3 id="调试递归"><a href="#调试递归" class="headerlink" title="调试递归"></a>调试递归</h3><ol>
<li>打印日志发现，递归值。</li>
<li>结合条件断点进行调试。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>谁动了我的奶酪</title>
    <url>/archives/43828.html</url>
    <content><![CDATA[<img data-src="C:\Users\Pro\AppData\Roaming\Typora\typora-user-images\image-20220216223801858.png" style="zoom: 50%;" />

<p>《谁动了我的奶酪》（Who　Moved　My　Cheese?），生动的阐述了“变是唯一的不变”这一生活真谛，据说已经成为全世界最畅销的书。或许每一个人看完的感受都不一样，但千万不要说这个道理我懂，如果那样就说明你依然惧怕改变自己。</p>
<span id="more"></span>

<p><em>作者：（美）约翰逊</em> </p>
<h3 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h3><p>　　《谁动了我的奶酪？》是个简单的寓言故事，内容充满了人生中有关变化寓意深长的真理。这是个有趣且能启蒙智慧的故事，内容是在描绘四个住在“迷宫”里的人物，他们竭尽所能地在寻找能滋养他们身心、使他们快乐的“奶酪”的过程。 这四个小人物中，有两只是名叫“嗅嗅”和“匆匆”的老鼠；其他两位则是身体大小和老鼠差不多的小人，名叫“唧唧”和“哼哼”，而且这两个小人的外型与行为和现今的人类差不多。 这里所谓的“奶酪”是一种比喻，它可以被当成我们生命中最想得到的东西。它可能是一份工作、人际关系、金钱、财产、健康、心灵的宁静。 书中所谓的“迷宫”，代表的是一个你花费时间与精力追寻你所欲求的东西的地方，它可以是你所服务的机构或你所居住的社区。 在故事里，这些人物面临突如其来的变化。最后，他们之中有一个成功地对这些变化做出适当的应变，并在迷宫的墙上写下他改变自己的心路历程及从中所得到的经验。 当你看到那些墙上的标语时，你就能自己找出处理变化的方法，了解了这些方法，你就不会感到太多压力，并且能够在生活中或工作中得到更多的成就感（不管你怎么定义这些成就感和压力）。 这本书适合任何的年龄层，而且阅读这故事花费你不到一小时的时间，但其中独特的真知灼见却能对你产生一辈子的影响力和帮助。</p>
<hr>
<blockquote>
<p>再完美的计划也时常遭遇不测<br>生活并不是笔直通畅的走廊，<br>让我们轻松自在地在其中旅行，<br>生活是一座迷宫，<br>我们必须从中找到自己的出路，<br>我们时常会陷入迷茫，<br>在死胡同中搜寻。<br>但如果我们始终深信不疑，<br>有扇门就会向我们打开，<br>它也许不是我们曾经想到的那一扇门，<br>但我们最终将会发现，<br>它是一扇有益之门。<br>…….. </p>
</blockquote>
<p>故事中虚构的四个角色：老鼠嗅嗅和匆匆，小矮人哼哼和唧唧，用来代表我们的不同方面，即我们简单的一面和复杂的一面。</p>
<p>我们每个人都具有这些不同的方面，不论我们的年龄、性别、种族和国籍如何。</p>
<p>有时我们的行为象：嗅嗅，他能够及早嗅出变化的气息；或者像：匆匆，他能够迅速行动；或者像：哼哼，他因为害怕改变而否认和拒绝变化，这会使事情变得更糟，或者像：唧唧，当他看到变化会使事情变得更好时，能够及时地调整自己去适应变化!</p>
<p>不管我们选择哪一面，我们都有共同的方面，那就是：</p>
<p>需要在迷宫中找到我们自己的道路，帮助我们在变化的时代获得成功。 </p>
<hr>
<h3 id="故事背后的故事"><a href="#故事背后的故事" class="headerlink" title="故事背后的故事"></a>故事背后的故事</h3><p>— <em>肯尼思·布兰查德博士</em></p>
<p>　　几年前，斯宾塞·约翰逊和我一起合著《一分钟经理人》的时候，给我讲了一个精彩的故事—-“奶酪的故事”。自从我听到这个寓意深长的故事以后，我就一直盼望着他能把这个故事写成书，使我们大家都能读到它，一起分享书中的带给我们的快乐和教益，因为从那时起，我就一直在回味这个绝妙的故事，惊叹于它带给我的启迪。</p>
<p>　　现在，我怀着激动的心情向大家介绍这本《谁动了我的奶酪》，并给各位讲述有关这个故事背后的故事。</p>
<p>　　《谁动了我的奶酪》讲的是一个关于“变化”的故事。故事发生在一个迷宫中，有四个可爱的小生灵在迷宫中寻找他们的奶酪。故事里的“奶酪”是对我们在现实生活中所追求目标的一种比喻，它可以是一份工作，一种人际关系，可以是金钱，一幢豪宅，还可以是自由、健康、社会的认可和老板的赏识。它只是一种精神上的宁静，甚至还可以只是一项运动，如马术、高尔夫球等等。 我们每个人的内心都有自己想要的“奶酪”，我们追寻它，想要得到它，因为我们相信，它会带给我们幸福和快乐。而一旦我们得到了自己梦寐以求的奶酪，又常常会对它产生依赖心理，甚至成为的附庸；这时如果我们忽然失去了它，或者它被人拿走了，我们将会因此而受到极大的伤害。 故事里的“迷宫”代表着你花时间寻求着的东西所在的地方，它可以是你效力的机构，你生活的社区，亦或是你生活中的某种人际关系。</p>
<p>　　我到世界各地演讲时就时常讲到这个各位即将在本书中读到的“奶酪的故事”，并且我常常听到人们在听完这个故事以后所发出的由衷的感叹，感叹这个故事带给他们的影响与改变。</p>
<p>　　信不信由你，这个小小的“奶酪的故事”已经获得了普遍的赞誉，它帮助了许许多多的人，因为它挽救了他们的事业、婚姻以及他们的生活!</p>
<p>　　这里我经大家讲一个真实的故事，主人翁就是深孚众望的NBC电视节目主持人查理·琼斯。他就是因为这个“奶酪的故事”，而使自己的事业生涯获得了转机。虽然电视节目主持人的职业很特殊，但是查理从故事中所学到的道理都适合于任何一种职业特性，并且人人都可以学习和掌握。</p>
<p>　　以下就是发生在查理·琼斯身上的故事。</p>
<p>　　查理早期所从的主要工作，是报道奥运会的田径项目，他在这项工作上很努力而且一直都干得非常出色。但是，突然有一天老板告诉他，下一届奥运会将派他去报道游泳和跳水项目。听到这个消息，查理既吃惊又难过。</p>
<p>　　因为他对游泳和跳水这两个项目完全不熟悉，这样的安排使他有一种挫折感，觉得自己不被重用和赏识。他说当时他感到这样的安排对他来说太不公平了，他为此而愤愤不平。并且这种愤怒的情绪几乎影响到了他所做的每一件事情，他的生活开始变得一团糟。 就在这时，他听到了这个故事—-“谁动了我的奶酪”。</p>
<p>　　听完故事后，他觉得自己以前的态度和行为十分可笑并迅速采取行动，进行调整。从此，他的工作和行为大大地改善了。因为他已经明白，老板只是拿走了他的奶酪而已，而他所应该做的就是调整自己，适应变化。于是他很快调整好自己的状态，以便适应新的工作，并开始下功夫去熟悉、了解游泳和跳水项目。在开展新工作的过程中，他惊奇地发现，做新的事情竟然使他感觉又焕发了青春。 不久，老板发现查理改变了工作态度，并且重新焕发出了新的活力，于是，给他分派了更多的新的有挑战的工作。从此查理走上了不断成功的道路，并从中享受到了前所未有的喜悦。后来，他被推选为“职业足球名人堂”最佳播音员之一。</p>
<p>　　我听到很多人表示，这个故事对他们的职业生涯和情感生活产生了巨大的冲击和震憾，而查理·琼斯的故事只是真实生活中这许许多多例子中的一个。</p>
<p>　　我是如此地相信“谁动了我的奶酪”这个故事所具有的影响力和震撼力，以致于我把这个故事成书之前的一个版本，送给每一位同我们公司有合作的人(大约二百多人)。我为什么这样做呢？</p>
<p>　　因为，一个公司的经营，不能只停留在求生存的阶段，而必须始终保持一种竞争的状态。我们布兰查德培训公司就是在不断地改变着，有人不断地拿走我们的“奶酪”。过去，传统的公司喜欢忠诚刻板的员工；而今天，我们更需要的是迅捷灵活的人而不是那种习惯于“按部就班”工作的雇员。</p>
<p>　　我们都知道，工作与生活就像不断翻滚的浪花，各种变化都在时时发生。生活在其中，的确使人感到紧张不安，除非有一种办法能使我们关注到这些变化，并且能够从中得到启迪。有一条找到这种办法的途径，那就是走进“奶酪的故事”。</p>
<p>　　当人们听我讲起这个故事后，就纷纷开始去读《谁动了我的奶酪》。而在阅读过程中，几乎每个人都感觉到这个故事让人有一种释放压力并开始放松的神奇作用。各个部门的人一个又一个地跑来感谢我向他们介绍了这本书，并且告诉我这本书对他们的帮助是多么巨大，使得他们能够从不同的角度看待公司正面临的种种变化。</p>
<p>　　请相信我，这则简短的寓言只需花费你不多的时间，但它带给你的影响将是深远的。</p>
<p>　　本书包括三个部分。</p>
<p>　　第一部分，“同学聚会”—-讲述一群过去的同窗在一次聚会上讨论如何应对生活中的种种变化。</p>
<p>　　第二部分是全书的核心—-“谁动了我的奶酪”的故事。</p>
<p>　　在故事里，你会发现，当面对变化时两个老鼠做得比两个小矮人要好，因为他们总是把事情简单化；而当两个小矮人所具有的复杂的脑筋和人类的情感，却总是把事情变得复杂化。这并不是说老鼠比人更聪明，我们都知道人类更具智慧。但换个角度想，人类那些过于复杂的智慧和情感有时又何尝不是前进道路上的阻碍呢？</p>
<p>　　当你观察故事中四个角色的行为时，你会发现，其实老鼠和小矮人代表我们自身的不同方面—-简单的一面和复杂的一面。当事物发生变化时，或许简单行事会给我们带来许多的便利和益处。</p>
<p>　　本书的第三部分，“讨论”—-是那些同窗好友们围绕这个故事展开的讨论，他们讨论这个故事的意味，以及如何把这个故事带给人们的启迪运用到生活与工作中去。</p>
<p>　　有些读过成书之前的手稿的读者读完故事本身后就停下来，不再继续阅读关于这个故事的讨论。另外一些人则更乐于阅读故事后面的“讨论”，因为他们认为从中可以受到启发，可以思考如何将从故事中的东西运用到他们的实际生活中去。</p>
<p>　　无论怎样，我都真诚地希望各位像我一样，在每次阅读这个故事的时候，都能从中领悟到一些新的、有用的东西；希望它能帮助你妥善地应对各种变化，不论你的成功目标是什么，它都能助你走向成功。</p>
<p>　　我希望你们能欢欣于你们从故事中所发现的道理，并能享受到这一发现的乐趣。祝你们一切顺利。 请记住一句话：<strong>随着‘奶酪’的变化而变化，并且享受变化</strong>。</p>
<hr>
<h3 id="芝加哥的同学聚会"><a href="#芝加哥的同学聚会" class="headerlink" title="芝加哥的同学聚会"></a>芝加哥的同学聚会</h3><p>　　芝加哥一个阳光明媚的星期天，许多过去在学校曾是好朋友的同班同学聚在一起搞午餐会。前一天晚上，他们刚参加完全体高中同学的聚会。在一阵打闹嬉笑和丰盛的午餐后，他们坐下来开始了饶有兴致的交谈，希望彼此多了解一些后的生活经历。</p>
<p>　　安杰拉曾是班上最受欢迎的人之一，她第一个发表感慨：“生活真和是跟我们做学生时想象的完全不一样，变化太多了。”</p>
<p>　　“的确如此!”内森附和道。内森正如大家所预料的那样，毕业后就进入了他的家族企业。这家企业的经营模式经年未变，在当地人的记忆中，那可是一家历史悠久的老字号了。因此，当内森若有所思地附和着安杰拉，并发出如此感叹时，大家都感到有些吃惊。 内森好像并未注意到大家的诧异，表情忧郁地接着说：“你们是否注意到，当周围的事情已经发生变化时，我们都不想对自己有所改变。”</p>
<p>　　卡洛斯接着说道：“我们拒绝改变，是因为我们害怕改变。”</p>
<p>　　杰西拉接过他的话：“噢，卡洛斯，你可是学校的足球队长，我们心目中的英雄，我从没想过还有什么东西可以让你害怕的。”</p>
<p>　　大家都笑起来。他们意识到，尽管大家毕业后都在各自不同的方面发展—-从在家工作到在外经营管理公司—-但好像都有类似的感觉—-害怕改变。</p>
<p>　　这些年来，每个人都试图对发生在生活中的各种意想不到的变化。但大家都承认，他们找不到一种很好的应对方法。</p>
<p>　　这时，迈克尔发话了：“我过去也一直害怕改变，直到有一天，我们的生意出现了一个重大的变故，但我们公司所有的人都不知道怎样去应付，由于我们没有及时做出调整，使我们几乎丢掉了全部的生意。”</p>
<p>　　“后来，”迈克尔继续讲道：“我听到了一个故事，这个故事使一切都改变了。”</p>
<p>　　“此话怎讲？”内森问道。</p>
<p>　　“喔，因为这个故事改变了我害怕改变的个性以及我对变化的看法—-从害怕失去某些东西到期待获得某些东西—-它教会我如何去做。从那以后，我的一切都迅速地改善了—-无论工作还是生活。”</p>
<p>　　“是什么故事这么神奇？”好几个人异口同声地问道。</p>
<p>　　“一开始，我被这个故事显而易见的简单给惹恼了，它就像我们小时候听腻了的那些寓言故事一样。”</p>
<p>　　“后来我发现，其实我是被自己惹恼了，我为自己不懂得这样简单明白的道理，在事情发生变化时不能采取有效的举动而感到恼怒。”</p>
<p>　　“再后来，我把这个故事告诉我们公司里的其他人，其他人又讲给其他人听。很快，公司里的业务有了明显的改进，因为我们大家都能及时地做出很好的调整以随时应对变化。与我的感受一样，许多人都说，这个故事使他们的个人生活大受裨益。”</p>
<p>　　“当然，也有人说他们从中没有得到什么，他们或者是知道这样的教训而且已经领教多次了。或者，更普遍的是，他们觉得自己已经懂得够多，不需要再学习什么了。他们甚至假装看不到如此多的人正在从中受益。”</p>
<p>　　“我的一位有些呆板的高级主管就说，读这个故事只是浪费时间。然而大家都取笑他，把他比做故事中的一个角色—-从不学习新的东西而且从不愿意改变。“</p>
<p>　　安杰拉有些迫不及待：“别卖关子了，这究竟是一个什么样的故事？”</p>
<p>　　“故事的名字叫作‘谁动了我的奶酪’。”</p>
<p>　　大家都哄笑起来。卡洛斯说：“我想仅凭这个名字，我就己经喜欢上这个故事了。你能讲给我们听听吗？或许我们也会从中有所收获。”</p>
<p>　　“当然，”迈克尔答道：“我非常愿意把这个故事讲给你们听。它并不长。”于是，他开始给大家讲述这个故事。</p>
<hr>
<h3 id="“谁动了我的奶酪-”的故事"><a href="#“谁动了我的奶酪-”的故事" class="headerlink" title="“谁动了我的奶酪?”的故事"></a>“谁动了我的奶酪?”的故事</h3><p>　　从前，在一个遥远的地方，住着四个小家伙。为了填饱肚子和享受乐趣，他们每天在不远处的一座奇妙的迷宫里跑来跑去，在哪里寻找一种叫做“奶酪”的黄橙橙、香喷喷的食物。</p>
<p>　　有两个小家伙是老鼠，一个叫“嗅嗅”，另一个叫“匆匆”。另外两个家伙是小矮人，和老鼠一样大小，但和人一个模样，而且他们的行为也和我们今天的人类差不多。他俩的名字，一个叫“哼哼”，另一个叫“唧唧”。</p>
<p>　　由于他们四个实在太小了，他们在干什么当然不太会引起旁人的注意。但如果你凑近去仔细观察，你会发现许多令人惊奇不已的事情！ 两个小老鼠和两个小矮人每天都在迷宫中度过，在其中寻找他们各自喜欢的奶酪。嗅嗅、匆匆的大脑和其他啮齿类动物的差不多一样简单，但他们有很好的直觉。和别的老鼠一样，他们喜欢的是那种适合啃咬的、硬一点的奶酪。</p>
<p>　　而那两个小矮人，哼哼和唧唧，则靠脑袋行事，他们的脑袋里装满了各种各样的信念和情感。他们要找的是一种带字母“C”的那奶酪。他们相信，这样的奶酪会给他们带来幸福。使他们成功。</p>
<p>　　尽管小老鼠和小矮人的目标各不相同，但他们做的事情是差不多的。每天早上，他们会各自穿上运动服和慢跑鞋，离开他们的小房子，跑进迷宫寻找他们各自钟爱的奶酪。</p>
<p>　　迷宫中有许多曲折的走廊和好像蜂窝的房间，其中的一些房间里藏着美味的奶酪，但更多的地方是黑暗的角落和隐藏的死胡同，任何人走进去都很容易迷路。</p>
<p>　　同时，这座迷宫还有一种神奇的力量，对那些找到出路的人，它能使他们享受到美好的生活。</p>
<p>　　两个小老鼠，嗅嗅和匆匆，总是运用简单低效的反复尝试的办法找奶酪。他们跑进一条走廊，如果走廊的房间都是空的，他们就返回来，再去另一条走廊搜寻。没有奶酪的走廊都会记住。就这样，很快地他们从一个地方找到另一个地方。嗅嗅可以用他那了不起的鼻子嗅出奶酪大致的方向，匆匆则跑在前面开路。然而迷宫太大太复杂，如你所料，他们经常会迷路，离开正道走错了方向，有时甚至还会撞倒墙上。</p>
<p>　　两个小矮人，哼哼和唧唧，则运用他们思考的能力，从过去的经验中学习。他们靠复杂的脑筋，搞出了一套复杂的寻找奶酪的方法。</p>
<p>　　哼哼和唧唧的方法比他们的老鼠朋友要高效，因此他们走进死胡同和碰壁的情况要比小老鼠们少得多。他们也为此而时常沾沾自喜很是得意，甚至有些看不起低智商的老鼠朋友。然而有时候，人类复杂的头脑所带来的复杂感情也会战胜他们的理性思维，使他们看问题的眼光变得暗淡起来。这也使得他们在迷宫里的生活更加复杂化，也更具有挑战性了。</p>
<p>　　但不管怎样，这四个家伙嗅嗅和匆匆，哼哼和唧唧，都以他们各自不同的方式不懈的追寻着他们想要得到的东西。最后，终于有一天，在某个走廊的尽头，在奶酪C站，他们都找到了自己想要的奶酪。</p>
<p>　　这里真是一个天堂，四个小家伙被眼前的情景惊呆了，无数各种各样的奶酪堆积如山，闪着诱人的光亮。四个小家伙呆了半晌，然后就疯了般地冲进奶酪堆，开始狂欢。 从那以后，这四个家伙，小老鼠和小矮人，每天早上穿上他们的跑步装备后便毫不犹豫地直奔奶酪C站。不久，他们都建立了熟悉的路线，并形成了各自的生活习惯。</p>
<p>　　嗅嗅和匆匆仍旧每天都起得很早，然后沿着相同的路线跑进迷宫中。</p>
<p>　　当老鼠们到达目的地后，他们脱下自己的跑鞋，有条不紊地将两只鞋系在一起，挂在脖子上;以便需要的时候很快穿上。然后他们才开始尽情地享用奶酪。</p>
<p>　　在开始一段时间里，哼哼和唧唧也是如此行事，每天早上赶到奶酪C站，按部就班的把鞋子挂在脖子上，享用在那里等着他们的美味佳肴。</p>
<p>　　然而不久以后，小矮人们改变了他们的常规。</p>
<p>　　哼哼和唧唧每天起得比老鼠们晚一些，懒懒地穿好运动服，然后信步走到奶酪C站。不管怎样，反正已经找到了奶酪。</p>
<p>　　他们从没想过，奶酪是从哪里来的，是谁把他们放在那里的。他们只是理所当然地认为，奶酪总是会在 那里的。</p>
<p>　　每天，哼哼和唧唧到奶酪C站以后，就像回到自己的家一样，舒服的呆在哪里。他们脱下运动衣，把它们挂起来，甩掉脚上的鞋子，换上拖鞋。他们找到了奶酪，感觉实在是太惬意了。</p>
<p>　　“真是太好了！”哼哼说：“这里有这么多奶酪，足够我们享用一辈子了。”小矮人们充满了幸福和成功的感觉，觉得从此可以无忧无虑了。</p>
<p>　　不久，哼哼和唧唧更理所当然地认定，他们在奶酪C站发现的奶酪就是“他们自己的”奶酪了。这里的奶酪库存是如此的丰富，于是他们决定把家搬到各靠近奶酪C站的地方，还在周围一带开展了他们的社交活动。 </p>
<p>　　为了使这里更像家的感觉，哼哼和唧唧把墙壁装饰了一通，还在墙上写了一些格言，并精心地画上了一些非常可口的奶酪的图案。他们看着这些图画和格言，会心地笑了，其中一幅图画的内容是：</p>
<p><strong>拥有奶酪，就拥有幸福。</strong></p>
<p>　　有时，他们会带朋友来参观他们在奶酪C站里成堆的奶酪，自豪地指着这些奶酪说：“多么美妙可口的奶酪呀，不是吗？”有时，他们还会与朋友们一起分享这些奶酪，而有时则是单独享用。</p>
<p>　　“我们应该拥有这些奶酪，”哼哼说，“为了找到它们，我们可是付出了长期而艰苦的努力的，我们当然有资格拥有它们。”他一边说着一边拿起一块鲜美的奶酪放进嘴里，享用起来，脸上流露出幸福的光彩。</p>
<p>　　然后，就像往常一样，哼哼享受完奶酪便睡着了，梦里还路除满足而惬意的笑容。</p>
<p>　　每天晚上，小矮人们在美美地饱餐了奶酪后，就摇摇摆摆地走回家，第二天早上他们又会信心十足地走进奶酪C站，去享用更多的奶酪。</p>
<p>　　这样的境况维持了相当长的一段时间。</p>
<p>　　逐渐地，哼哼和唧唧的自信开始膨胀起来。面对成功，他们开始变得妄自尊大。在这种安逸的生活中，它们丝毫没有察觉到正在发生的变化。</p>
<p>　　随着时间的流逝，嗅嗅和匆匆日复一日地重复着他们的生活。每天早早地赶到奶酪C站，四处闻一闻、抓一抓，看看这区域和前一天有什么不一样。等到确定没有任何异常后他们才会坐下来细细品味奶酪，好好享受一番。</p>
<p>　　一天早上，当嗅嗅和匆匆到达奶酪C站时，发现这里已经没有奶酪了。<br>　　对此，他们并不感到吃惊，因为他们早已察觉到，最近好像有一些奇异的事情正在奶酪C站里发生，因为这里的奶酪已经越来越小，并且一天比一天少了。他们对这种不可避免的情况早有心理准备，而且直觉地知道该怎么办。</p>
<p>　　他们相互对望了一眼，毫不犹豫地取下挂在脖子上的跑鞋，穿上脚并系好鞋带。</p>
<p>　　两只小老鼠对此并没有做什么全面细致的分析，事实上，也没有足够复杂的脑细胞可以支持他们进行这么复杂的思维。</p>
<p>　　对老鼠来说，问题和答案都是一样的简单。奶酪C站的情况发生了变化，所以，他们也决定随之而变化。</p>
<p>　　他们同时望向迷宫深处。嗅嗅扬起他的鼻子闻了闻，朝匆匆点点头，匆匆立刻拔腿跑向迷宫的深处，嗅嗅则紧跟其后。</p>
<p>　　他们开始迅速行动，去别的地方寻找新的奶酪，甚至连头都没有回一下。</p>
<p>　　同一天的晚些时候，哼哼和唧唧也像往常一样溜溜达达地来到奶酪Ｃ站，一路上哼着小曲。他们过去一直没有察觉到这里每天都在发生的细小变化，而想当然地以为他们地奶酪还在那里。</p>
<p>　　面对新的情况，他们毫无准备。</p>
<p>　　“怎么！竟然没有奶酪？”哼哼大叫道，然后他开始不停地大喊大叫，“没有奶酪？怎么可能没有奶酪？”好像他叫喊地声音足够大的话，就会谁把奶酪送回来似的。</p>
<p>　　“谁动了我的奶酪？”他声嘶力竭地呐喊着。</p>
<p>　　最后，他把手放在屁股上，脸憋得通红，用他最大的嗓门叫道：“这不公平！”</p>
<p>　　唧唧则站在那里，一个劲的摇头，不相信这里已经发生的变化。对此，他同样没有任何心里准备，他满以为在这里照旧可以找到奶酪。他长时间地站在那里，久久不能动弹，完全被这个意外给惊呆了。</p>
<p>　　哼哼还在疯狂地叫嚷着什么，但唧唧不想听，他不想面对眼前的现实，他拼命告诉自己，这只是一个噩梦，他只想回避这一切。</p>
<p>　　他们的行为并不可取，而且也于事无补，但我们总还是能够理解的。</p>
<p>　　要知道找到奶酪并不是一件容易的事情。更何况，对这两个小矮人来说，奶酪绝不仅仅只是一样填饱肚子的东西，它意味着他们悠闲的生活、意味着他们的荣誉、意味着他们的社交关系以及更多重要的事情。</p>
<p>　　对他们来说，找到奶酪是获得幸福的唯一途径。根据不同的偏爱，他们对奶酪的意义有各自不同的看法。对有些人而言，奶酪代表的是一种物质上的享受；而对另一些人来说，奶酪则意味着健康的生活，或者是一种安宁富足的精神世界。</p>
<p>　　对唧唧来说，奶酪意味着安定，意味着某一天能够拥有一个可爱的家庭，生活在名人社区的一座舒适的别墅里。</p>
<p>　　对哼哼来说，拥有奶酪可以使他成为大人物，可以领导很多的人，而且可以在卡米伯特山顶上拥有一座华丽的宫殿。</p>
<p>　　由于奶酪对他们实在太重要了，所以这两个小矮人花了很长时间试图决定该怎么办。但他们所能够想到的，只是在奶酪Ｃ站里寻找，看看奶酪是否真的不存在了。</p>
<p>　　当嗅嗅和匆匆已经迅速行动的时候，哼哼和唧唧还在那里不停地哼哼唧唧、犹豫不决。</p>
<p>　　他们情绪激动地大声叫骂这世界的不公平，用尽一切恶毒的语言去诅咒那个搬走了他们奶酪的黑心贼。然后唧唧开始变的消沉起来，没有了奶酪，明天会怎样？他对未来的计划完全都建立在这些奶酪的基础上面的啊！</p>
<p>　　这两个小矮人不能接受这一切。这一切怎么可能发生呢？没有任何人警告过他们，这是不对的，事情不应该是这个样子的，他们始终无法相信眼前的事实。</p>
<p>　　那天晚上，哼哼和唧唧饥肠辘辘、沮丧地回到家里。在离开之前，唧唧在墙上写下了一句话：</p>
<p><strong>奶酪对你越重要，你就越想抓住它。</strong></p>
<p>　　第二天，辗转难眠了一晚上的哼哼和唧唧早早地离开家又回到奶酪C站，不管怎样，他们抱着一线希望，他们不断地欺骗自己，假定昨天走错了地方，他们仍然希望找回他们的奶酪。奶酪站的位置没有变化，然而奶酪的的确确早已不复存在。两个小矮人顿时手足无措，不知道该怎么办。哼哼和唧唧只是站在那里，一动不动，就像两座毫无生气的雕像。</p>
<p>　　唧唧紧紧闭上眼睛，用手捂住自己的耳朵，他只想把一切都堵在外面。他不愿相信奶酪是逐渐变得越来越小的，他宁愿相信奶酪是突然之间被全部拿走的。</p>
<p>　　哼哼则把现在的情况分析了又分析，他用他复杂的大脑把他所有的信条都翻了个遍。“他们为什么要这样做？”他终究没能找到答案，“这里究竟发生了什么事情？” 终于，唧唧睁开了眼睛，朝周围看了看说：“顺便问一下，嗅嗅和匆匆现在在哪里？你是否觉得他们知道某些我们还不知道的事情？”</p>
<p>　　“那两个弱智，他们能知道些什么？”哼哼的语气中充满了不屑。</p>
<p>　　他继续说：“他们只是头脑简单的老鼠，他们只会对发生的事情做出简单的反应。而我们是机伶聪明的小矮人，我们比老鼠有头脑。我们应该能够推测出这里的情况。”</p>
<p>　　“我知道我们更聪明，”唧唧说，“但是，我们现在的行为好像并不怎么聪明。我们周围的情况已经发生了变化，哼哼，也许我们需要做出一些改变，去做点什么不同的事情。”</p>
<p>　　“我们为什么要改变？”哼哼问道，“我们是小矮人，我们是不一样的。这样的事情不应该发生在我们的身上。即使出现了这样的情况，我们至少也应该从中得到一些补偿。”</p>
<p>　　“为什么我们应该得到一些补偿呢？”唧唧问。</p>
<p>　　“因为我们有这样的权利。”哼哼宣称。</p>
<p>　　“有什么样的权利？”唧唧不明白。</p>
<p>　　“有拥有我们奶酪的权利。”</p>
<p>　　“为什么？”唧唧还是不明白。</p>
<p>　　“因为这个问题不是我们引起的，”哼哼说，“是某些别有用心的人制造了这个局面，而不是我们，所 以我坚持认为我们总应该从中得到些补偿。”</p>
<p>　　“也许我们应该停止这种无用的分析，”唧唧提议，“分析问题到此为止。在我们还没有被饿死之前，我们应该赶紧出发去找新的奶酪。”</p>
<p>　　“噢，不！”哼哼反对说，“我们快要找到问题的根源了，要知道，我们曾经拥有过那么多、那么好的奶酪啊！”</p>
<p>　　当哼哼和唧唧还在争执着试图决定该怎么办的时候，嗅嗅和匆匆已经在很顺利的做他们的事情了。他们进入了迷宫的更深处，走过一条又一条走廊，在每一个他们遇到的奶酪站里仔细寻找着奶酪。</p>
<p>　　除了倾尽全力地寻找新的奶酪，他们并不考虑任何别的事情。</p>
<p>　　有好一段时间，他们找得很辛苦却一无所获。直到他们走进迷宫中一个他们从未到过的地方：奶酪N站。</p>
<p>　　他们高兴得尖叫起来，他们终于发现了他们一直在寻找的东西：大量新鲜的奶酪。</p>
<p>　　他们简直不敢相信自己的眼睛，这是他们见过的最大的奶酪仓库。</p>
<p>　　而与此同时，哼哼和唧唧仍然呆在奶酪C站，对他们目前的处境进行揣摩。他们正在忍受着失去了奶酪的痛苦，挫折感、饥饿感和由此而来的愤怒紧紧围绕着他们，折磨着他们，他们甚至为陷入眼前的困境而相互指责。</p>
<p>　　唧唧仍然时时想起他的老鼠朋友，猜想他们现在是否已经找到了奶酪。他相信他们也许过得很困难。在迷宫中穿行，总会面临许多难以预料的事情。但他也知道，什么事情也得有不容易的一个阶段。</p>
<p>　　有时，唧唧会想出嗅嗅和匆匆已经找到了新的奶酪并正在享用他们的情景。他忽然有一种冲动，想到迷宫中冒险去寻找新的奶酪。在迷宫中探险，找到新的奶酪并尽情享用，这一切该是多么的美好啊！想到这里，他觉得仿佛自己已经尝到了新鲜奶酪的美味。</p>
<p>　　正在寻找和享用新的奶酪，这样的情景在唧唧的头脑中越来越清晰。他觉得自己越来越想离开奶酪C站，出发去寻找新的奶酪。</p>
<p>　　突然，他大声宣布道：“我们走吧！”</p>
<p>　　“不！”哼哼很快作出了反应：“我喜欢这里。我只熟悉这里，这里很好很舒服。再说，离开这里到外 面去是很危险的。”</p>
<p>　　“不会的，”唧唧说：“以前我们也曾经到过这个迷宫中的许多地方，我们还可以再去其他地方找找看。”</p>
<p>　　“我觉得自己已经有些老了，不能再做这种跑来跑去到处冒险的事了。”哼哼说：“而且，我也不想像个傻瓜似的，时常迷路。你觉得呢？” 听哼哼这么一说，失败的恐惧感又袭上了唧唧的心头，他的那点发现新奶酪的希望有逐渐消退了。</p>
<p>　　就这样，这两个小矮人继续作着以前每天所作的事。他们仍然每天都去奶酪C站，发现还是找不到奶酪，然后怀着忧虑和挫败的心情回到家里。</p>
<p>　　他们试图否认眼前发生的一切，开始失眠，力气一天比一天小，变得越来越烦躁易怒。</p>
<p>　　他们的家，也不再是美好舒适的地方。他们睡不上一个安稳觉，而且每晚的时光都伴着找不到奶酪的噩梦度过。</p>
<p>　　但他们仍然每天回到奶酪C站，仍然每天在那里等待。</p>
<p>　　哼哼说：“你知道，如果我们再努力一些，我们也许会发现事情并没有发生太大的变化。奶酪也许就在 附近，他们也许只是被人藏到墙的后面去了。”</p>
<p>　　第二天，哼哼和唧唧带了工具回到奶酪C站。哼哼拿着凿子，唧唧则用锤子敲打。他们费了九牛二虎之力，终于在墙上打出了一个洞，朝里面窥视，却依旧没有发现奶酪的踪迹。</p>
<p>　　尽管他们感到非常失望，但他们仍然相信问题会得到解决，以后，他们起得更早，工作时间更长、更努力。但是，一段时间以后，他们得到的只是一个个更大的空洞。</p>
<p>　　唧唧开始认识到行动和结果之间的区别。</p>
<p>　　“也许，”哼哼说：“我们只需要坐在这里，看看到底会发生什么事情。迟早他们会把奶酪再送回来的。”</p>
<p>　　唧唧希望他说的是真的。这样，他每天回家休息，然后勉强陪着哼哼去奶酪C站察看情况。但是，奶酪始终没有再出现。</p>
<p>　　由于焦虑和饥饿，这两个小矮人已经变得有些虚弱。唧唧已经开始厌倦等待—-完全被动地等着状况自己发生好转。他开始明白，他们在奶酪C站等待的时间越长，情况只会变得越糟糕。</p>
<p>　　唧唧明白，他们正失去自己的优势。</p>
<p>　　终于，有一天，唧唧开始自己嘲笑起自己来了：“唧唧呀唧唧，看看你自己吧！你居然等到每天重复同样的错误，还总是奇怪、怀疑为什么情况还没有得到改善，还有什么比你这种做法更可笑的呢？这如果不是荒谬，就是滑稽。”</p>
<p>　　唧唧并不想再到迷宫中去奔波。他知道他可能会迷路，而且他也不知道究竟应该到哪儿去寻找新的奶酪。但当他明白正是他的恐惧感使他如此裹足不前、坐以待毙的时候，他嘲笑自己的愚笨。</p>
<p>　　他问哼哼：“我们的运动衣和慢跑鞋放到哪里去了？”他花了很长时间才翻出了那些运动装备。当初，他们在奶酪C站找到奶酪以后，就把鞋啊什么的都扔到一边去了，因为他们满以为再也不会需要这些玩意儿了。</p>
<p>　　当哼哼看到他的朋友穿上运动服时，他说：“你不是真的要到迷宫中去吧？你为什么不留下来，和我一起在这里等，等着他们把奶酪送回来？” “因为如果这么做，我们将永远不会得到那些奶酪，”唧唧大声说：“不会有人把奶酪送回来了，现在已经到了去寻找新的奶酪的时候了，不要再想那些早已不存在的奶酪了！”</p>
<p>　　哼哼争辩说：“但是如果外面也没有奶酪怎么办？或者，即使有奶酪，但你找不到，又怎么办？”</p>
<p>　　“我不知道。”唧唧不耐烦地说。同样的问题，他已经问过自己多少遍了。他又感到了那种使他停滞不前的恐惧感。</p>
<p>　　但是马上，他又想到如果真的找到了新的奶酪呢？那种享受新奶酪的喜悦再度鼓起了他的勇气。 他最后问自己：“你希望到哪里去找奶酪—-这里还是迷宫中？”</p>
<p>　　于是他脑中出现了一幅图画，他看见自己面带微笑的在迷宫中探险。</p>
<p>　　这样的景象让他有些惊异，他发现自己终于克服了再次进入迷宫的恐惧。他看见自己在迷宫中迷了路，但仍然满怀信心地在那里寻找新的奶酪，一切美好的事物都随之而来。他又重新找回了自己的勇气。</p>
<p>　　于是，他尽量发挥自己的想象力，在脑海中为自己描绘了一幅他最信赖的、最具现实感的图画—-他在寻找和品尝新的奶酪。</p>
<p>　　他仿佛看见自己坐在一大堆奶酪中央，正在尽情品尝各种奶酪，像蜂窝状的瑞士奶酪、鲜黄的英国切达干酪、美国奶酪和意大利干酪，还有美妙又柔软的法国卡米伯特奶酪，等等。 唧唧简直想的入了神，知道他听见哼哼在一边嘟囔着什么，他才意识到自己仍然还站在奶酪C站。</p>
<p>　　于是唧唧转过身来对哼哼说：“哼哼，有时候，事情发生了改变，就再也变不会原来的样子了。我们现在遇到的情况就是这样。这就是生活！生活在变化，日子在往前走，我们也应随之改变，而不是在原地踟蹰不前。”</p>
<p>　　唧唧看着他那因饥饿和沮丧而显得有些憔悴的朋友，试图给他分析一些道理。但是，哼哼的畏惧早已变成了气恼，他什么也听不进去。</p>
<p>　　唧唧并不想冒犯他的朋友，但是他还是忍不住要嘲笑他们自己，因为现在看起来他们俩真是又狼狈又愚蠢。</p>
<p>　　当唧唧准备要出发的时候，他觉得自己整个人都变的充满了活力，他挺起了胸膛，他的精神开始振作起来：“让我们出发吧。”</p>
<p>　　唧唧大笑着宣称：“这是一个迷宫的时代！”</p>
<p>　　哼哼笑不出来，他几乎没有任何反应。</p>
<p>　　唧唧拾起一块坚硬的小石头，在墙上写下一句恳切的话，留给哼哼去思考。他没有忘记自己的习惯，在这句话的周围画上奶酪的图案。唧唧希望着幅画能给哼哼带来一丝希望，会对哼哼有所启发，并促使哼哼起身去追寻新的奶酪。但是哼哼根本不想朝墙上看一眼。</p>
<p>　　墙上的话是：</p>
<p>　　如果你不改变，你就会被淘汰。</p>
<p>　　在墙上留完言后，唧唧伸出脑袋小心翼翼地朝迷宫中望了望，回想着到达奶酪C站以前所走过的路线。</p>
<p>　　他曾经想过，也许迷宫中再也没有奶酪了，或者，他可能永远也找不到奶酪。这种悲观的情绪曾经那样深地植于他的心底，以至于差一点就毁了他。</p>
<p>　　想到这里，唧唧会心地微笑起来。他知道，哼哼现在一定还站在原地懊恼：“究竟是谁动了我的奶酪？”而唧唧此刻想到的确是：“我为什么没有早点行动起来，跟着奶酪移动呢？” 当唧唧终于走出奶酪C站踏入黑暗的迷宫时，他忍不住回头看了看这个曾经伴随他和哼哼很长一段时间的地方。那一瞬间他几乎无法控制自己，又想走回那个熟悉的地方，又想躲进那个虽然已没有奶酪但很安全的地方。</p>
<p>　　唧唧又有些担心起来，拿不准自己是否真的想要进入到迷宫中去。片刻以后，他又拿起石块在面前的墙上写下一句话，盯着它看了许久：</p>
<p><strong>如果你无所畏惧，你会怎样做呢？</strong></p>
<p>　　他对着这句话苦思冥想。</p>
<p>　　他知道，有时候，有所畏惧是有好处的。当你害怕不做某些事情会使事情变的越来越糟糕时，恐惧心反而会激起你去采取行动。但是，如果因为过分害怕而不敢采取任何行动时，恐惧心就会变成前进道路上最大的障碍。</p>
<p>　　他朝迷宫的右侧瞧了瞧，心中生出了恐惧，因为他从未到过那里面。</p>
<p>　　然后，他深吸了一口气，朝迷宫的右侧缓步跑去，跑向那片未知的领地。</p>
<p>　　在探路的时候，唧唧有些担心起来，一开始他还在奶酪C站犹豫了那么久，因为长时间没有吃到奶酪了，他有些虚弱。现在，在迷宫中穿行要比以前更加吃力，花的时间更长。他打定主意，一旦再有机会，他一定要尽早走出舒适的环境去适应事务的变化。他觉得立刻采取措施会使事情变的容易一些。 想到这里，唧唧无力地微笑了一下，感叹道：“迟做总比不做好。”</p>
<p>　　接下来地几天里，唧唧在周围偶尔能够找到一点奶酪，但都吃不了多久。他曾经希望能够找到足够多的奶酪，带回去给哼哼，鼓励他离开原地，走进迷宫。</p>
<p>　　但是，唧唧还是感到有些信心不足，他不得不承认，身在迷宫中，他感到十分困惑。里面很多地方跟以前完全不一样了。</p>
<p>　　他这样想着朝前走去，他觉得自己已经走了好远，却又好像就要迷失在迂回曲折的走廊中了。这就好像是在走两步退一步，对他来说真是一种挑战。不过他还是要承认，回到迷宫中寻找奶酪，其实并不像他想像的那样可怕。 随着时间的流逝，他开始有些怀疑，找到新奶酪的希望是否能变成现实。有种幻觉，有时他怀疑是否自己嘴里的奶酪太多而嚼不过来，这时，想到自己根本没有东西可嚼，他不禁哑然失笑。</p>
<p>　　每当他开始感到泄气的时候，他就提醒自己正在做什么。尽管现在很难受，但这样总比呆在没有奶酪的地方更实际。他在掌握控制权，而不是听天由命、束手无策。</p>
<p>　　他还提醒自己，如果嗅嗅和匆匆能不断前行，那么自己也能做到！</p>
<p>　　后来，唧唧回想起过去的事情，他终于明白奶酪C站的奶酪并不是像他曾经相信的那样一夜之间突然消失的。奶酪的数量是逐渐变少，直至完全消失的。而且，剩下的那一点也已经陈旧变质，美味丧失殆尽了。</p>
<p>　　那些陈旧的奶酪上面或许已经生出了霉菌，只是他没有注意到罢了。他还得承认，只要他愿意，应该能够注意的到，可惜他当初没有留意这些变化。</p>
<p>　　唧唧还认识到，如果他一直能够察觉到这些变化而且能够预见到这些变化，那么，这些变化就不会让他感到吃惊。也许，嗅嗅和匆匆一直就是这样做的。</p>
<p>　　他打定主意，从现在起，他要时刻保持警觉。他要期待着发生变化，而且还要去追寻变化，。他应该相信自己的直觉，能告意识到何时发生变化，并且能够做好准备去适应这些变化。</p>
<p>　　他停下来休息了一会，并在迷宫的墙上写道：</p>
<p>　　<strong>经常闻一闻你的奶酪</strong></p>
<p>　　你就会知道，</p>
<p>　　它什么时候开始变质。</p>
<p>　　一段日子以后，好像已经很久没有找到奶酪了。这天，唧唧遇到了一个很大的奶酪站，看起来里面似乎装满了奶酪。当他走进去以后，却发现里面空空如也，他失望至极。</p>
<p>　　“这种空空的感觉，对我来说太平常了。”他叹息道，他觉得自己就快要放弃了。</p>
<p>　　唧唧的体力正在慢慢地丧失。他知道自己迷路了，此刻，他有些担心自己能不能活下去。他想转身回到奶酪C站去。回去后，至少哼哼还在那里，唧唧就不会孤单一人了。这是，他又问了自己一个同样的问题：“如果我无所畏惧，我又会怎样做呢？” 唧唧觉得他正在克服和超越自己的恐惧，但他又越来越经常地感到害怕，害怕得甚至无法对自己承认。他常常难以确定自己到底害怕什么，但是在目前这样虚弱的状况下，他知道，他只是害怕一个人独自前行。唧唧其实并不清楚这一点，他只是在跟着这种感觉走，因为他一直在被这些恐惧得念头压迫着。</p>
<p>　　唧唧想知道哼哼是否已经离开了C站开始出发去寻找新的奶酪，或者是否仍然被自己得恐惧所吓倒，仍旧裹足不前。这时，唧唧想起他在迷宫中度过的时光，那些他曾经觉得是最美好的时光，其实正是他一个人穿行在迷宫中找寻奶酪的时候。</p>
<p>　　他又在墙上写下了一句话，以便提醒自己。同时，这句话也是一个标记，留给他的朋友哼哼，希望哼哼会跟上来。</p>
<p><strong>朝新的方向前进　你就会发现新的奶酪</strong></p>
<p>　　唧唧朝着黑暗深邃的通道中望去，又有一阵恐惧袭来。前面有些什么？是不是什么都没有？或者更糟，里面潜藏着危险？他开始想像各种可能降临到他头上的可怕的事情。他越想越怕，快把自己吓死了。</p>
<p>　　忽然，他又觉得自己真是可笑。他意识到，他的畏惧只会使事情变的更糟糕。于是，他采取了当他无所畏惧的时候他会采取的行动。他朝一个新的方向跑去。</p>
<p>　　当他跑向这条黑暗的走廊时，他笑了起来。唧唧还没认识到这一点，但他觉得他的灵魂得到了丰富。他正在放开自己，对前景充满了信心，尽管他并不能确切地知道前面究竟有些什么。</p>
<p>　　出乎意料，他开始对自己感到越来越满意。“为什么我感觉这么好？”他不明白：“我并没有找到奶酪，而且也不知道要到那里去。”</p>
<p>　　不久，他明白了他为什么会感觉这么好。他停下脚步，在墙上写道：</p>
<p>　　<strong>当你超越了自己的恐惧时，你就会感到轻松自在。</strong></p>
<p>　　他认识到，他原来是被自己的恐惧感给控制住了。如今朝一个新的方向迈进，使他获得了自由。</p>
<p>　　这时，从迷宫中吹来习习的凉风，使人感到神清气爽。他深吸了一口气，不觉振作起来。一旦克服了自己的恐惧感，他觉得一切比原来自己想像的要好得多。</p>
<p>　　唧唧已经很久没有这种感觉了。他几乎快要忘记了这种感觉是多么的惬意。</p>
<p>　　为了使事情更顺利地进行，他又开始在头脑中描绘一种景象。想像中，他在一种很棒的现实环境，坐在各种他喜欢的奶酪中间—-有切达奶酪还有布里奶酪！他看见自己在吃许多他喜欢吃的奶酪。这样的景象使他获得一种享受，他想像着这些奶酪的滋味该是多么美啊！</p>
<p>　　这种享受新奶酪的情景，他看得越清楚，就越相信这会变成现实。现在，他有一种感觉，他就要找到奶酪了，</p>
<p>　　他又在墙上写道：</p>
<p><strong>在我发现奶酪之前，想像我正在享受奶酪，这会帮我找到新的奶酪。</strong></p>
<p>　　唧唧一直在想的是他将会得到什么，而不是考虑他会失去什么。</p>
<p>　　他不明白，为什么自己过去总是觉得变化会使事情变得更糟，而现在他认识到，变化将会使事情变得更好。</p>
<p>　　“为什么以前我不明白这一点？”他反问自己。</p>
<p>　　于是，他以更大的勇气和力量快速灵敏地穿行在迷宫中。不久，他就发现了一个奶酪站。当他在迷宫的入口处发现一些新奶酪地碎屑时，他变得兴奋起来。</p>
<p>　　这是一些他从未见过的奶酪，但看起来挺不错，他尝了尝，真是美味啊！他吃掉了大部分能找到地小块奶酪，把剩下地放进口袋，以后也许可以和哼哼分享。他的体力也开始得到恢复。</p>
<p>　　他怀着兴奋地心情走进去。但是，让他感到惊愕的是，里面竟然是空的。有人已经来过这里，只留下了一些小块奶酪。</p>
<p>　　他认识到，如果能早一点行动，他就很可能早已在这里发现大量的新奶酪了。</p>
<p>　　唧唧决定会去，看看哼哼是否愿意和他一起行动，</p>
<p>　　在返回的路上，他停下来，在墙上写道：</p>
<p><strong>越早放弃旧的奶酪，你就会越早发现新的奶酪。</strong></p>
<p>　　不久，唧唧就回到了奶酪C站，找到了哼哼，他给哼哼一些新的小块奶酪，但被拒绝了。</p>
<p>　　哼哼很感激朋友的心意，但是他说：“我不喜欢新奶酪，这不是我习惯吃的那一种。我只要我自己的奶酪回来。除非可以得到我想要的东西，否则我是不会改变主意的。”</p>
<p>　　唧唧失望地摇摇头，不情愿地一个人踏上了自己地旅程。当走到他到达过的迷宫最深处时，他怀念起他的朋友来，但他明白，他喜欢的还是他的探险过程。虽然以前他想自己希望的是得到充足的新奶酪，但现在他清楚使自己快乐的并不仅仅是奶酪而已。 他高兴的是，他不再受自己的恐惧感的驱使。他喜欢自己正在做的事情，</p>
<p>　　明白了这一点，唧唧不再像在奶酪C站时，在没有奶酪的日子里感到那样的虚弱了。他知道，他不会再让恐惧感阻碍自己。他选择了一个新的方向，他的身心得到了滋养，体力得到加强。</p>
<p>　　现在，他觉得，找倒自己想要的东西只是一个时间问题。事实上，他感到自己已经找到了他一直在寻找的东西。</p>
<p>当他认识到这一点色时候，他不禁微笑起来，并在墙上写道：</p>
<p>　　<strong>在迷宫中搜寻比停留在没有奶酪的地方更安全。</strong></p>
<p>　　唧唧还认识到，就像他曾经体会过的那样，你所害怕的东西根本没有你想像的那样糟糕，在你心里形成的恐惧比你的实际处境更坏。他曾经是如此的害怕找不到新的奶酪，以致于他根本不想开始去寻找。然而一旦开始寻找的旅程，他就发现迷宫的走廊中有足够的奶酪使他继续找下去。现在，他期待着找到更多的奶酪。只要朝前看，他就会因为有所期待而兴奋起来。</p>
<p>　　他过去的思想被恐惧和忧虑蒙蔽了。过去考虑的总是没有奶酪，或者没有可以维持足够长时间的奶酪。以前总是觉得会把事情做错，而不是考虑把事情做好。</p>
<p>　　在他离开奶酪C站以后的日子里，一切都改变了。 过去他习惯于认为，奶酪决不会被拿走，改变总是不对的。</p>
<p>　　现在，他知道，变化会不断地发生，这是很自然的事情，不管你是否希望如此。只有当你不希望变化，也不想追寻变化的时候，变化才会让你感到吃惊。</p>
<p>当唧唧认识到自己的信念发生了变化时，他停下来，在墙上写道：</p>
<p><strong>陈旧的信念，不会帮助你找到新的奶酪。</strong></p>
<p>　　唧唧还没有找到奶酪，但在迷宫中穿行的时候，唧唧在想自己从中学到了什么。</p>
<p>　　他意识到，他的新的信念鼓舞着他采取新的行动。他的行为再不同于以往，再也不是总想回到同一个没有奶酪的地方。</p>
<p>　　他知道，当你改变了自己的信念，你也就改变了自己的行为。</p>
<p>　　你可以相信，变化对你有害，你可以拒绝它；或者，你会相信寻找新奶酪对你有好处，你会拥抱这种变化。</p>
<p>　　这些取决于你选择相信什么。</p>
<p>　　他在墙上写道：</p>
<p><strong>当你发现，你会找到新的奶酪，并且能够享用它时，你就会改变你的路线。</strong></p>
<p>　　唧唧知道，如果他能够早一些离开奶酪C站，早一点应对这些变化，他现在的状况就会更好一些。他的身体会更强壮，精神也会更坚强，会更好地去迎接挑战;寻找新奶酪的挑战。事实上，如果他不是浪费时间，否认已经发生了的变化，如果他能够期待改变，也许他已经找到奶酪了。 他再一次运用自己的想象力，看见自己正在发现和品尝新奶酪。他决定到更多的地方去，去迷宫中那些他还没有到过的地方。在这些地方，他偶尔找到一些小块的奶酪。唧唧又开始恢复了体力和信心。</p>
<p>　　当他回顾自己是怎么走过来的时候，他很高兴他在很多经过的地方的墙上都留下了字迹。他相信如果哼哼决定离开奶酪C站的话，这就是留给哼哼的路标，能帮助哼哼穿过迷宫。</p>
<p>　　唧唧只是希望自己在朝着正确的方向前进。他还想到了这种可能性—-哼哼将会读到墙上的字迹，并且循着它找到出路。</p>
<p>　　于是他又把这段时间以来他一直在思索着的心得写在了墙上：</p>
<p>　　<strong>尽早注意细小的变化，这将有助于你适应即将来临的更大的变化。</strong></p>
<p>　　此时此刻，唧唧早已把过去抛在脑后，正在适应现在。</p>
<p>　　他继续以更充沛的体力和更快的速度穿越迷宫。不久，期待已久的事情终于发生了。</p>
<p>　　当他感觉一直在迷宫中前行，而且好像永远都会在迷宫中前行的时候，他的旅程—-至少是现阶段的旅程;即将愉快地结束了。</p>
<p>　　唧唧正沿着一条走廊前进，这是一条他从未到过的走廊，拐过一个弯，在他的面前出现了奶酪N站，这里面堆满了新鲜的奶酪！</p>
<p>　　当他走进奶酪N站的时候，他被眼前的景象惊呆了。到处都是堆积如山的奶酪，他从未见过如此巨大的丰盛的贮藏。他并不完全认识这些奶酪，有些品种是全新的。 眼前的景象太壮观了，他犹豫了一会儿，不能肯定这是否是真的，或许这只是他的幻觉。直到他看见了他的老朋友嗅嗅和匆匆，他才相信这一切是真的。</p>
<p>　　嗅嗅冲唧唧点了点头，表示欢迎，匆匆则朝他挥了挥爪子。他们胖胖的小肚子表明，他们在这里已经有一段时间了。</p>
<p>　　唧唧很快向他们打了招呼，然后赶紧把他喜欢的各种奶酪都咬了一口。他脱掉鞋子，把两只鞋子系在一起，然后挂在脖子上，以便需要的时候能够迅速找到它们。嗅嗅和匆匆会心地笑了，并赞许地点了点头。而唧唧已经一头扎进了奶酪堆中。一顿饱餐之后，唧唧高兴地举起一块新鲜的奶酪欢呼：“呼啦。变化万岁！” 唧唧享受新的奶酪是同时，也在反思自己学到了什么。</p>
<p>　　他认识到，当他害怕变化的时候，他一直受困于对那已不复存在的就奶酪的幻想而无法自拔。</p>
<p>　　那又是什么使他发生了改变呢？难道是害怕饿死的恐惧？想到这里，唧唧笑了，他心里明白，这种恐惧当然起过很大的作用。</p>
<p>　　唧唧忽然发现，他已经学会自嘲了，而当人们学会自嘲，能够嘲笑自己的愚蠢和所作的错事时，他们就在开始改变了。他甚至觉得，改变自己的最快捷的方式，就是嘲笑自己的愚笨;这样，你就能对过往云烟轻松释然，迅速行动起来，直面变化。</p>
<p>　　唧唧相信他从他的老鼠朋友嗅嗅和匆匆那里，学到了一些有用的东西;不畏惧改变，勇往直前。老鼠朋友们简单地对待生活，他们不会反复分析，也不会把事情搞得很复杂。当形势发生改变，奶酪被移走了的时候，他们会迅速随之改变，循着奶酪的移动方向而移动。唧唧告诉自己，要牢记这些体会。</p>
<p>　　唧唧相信拥有了这些体会，凭借着自己聪慧的头脑，再遇到任何变化时他一定能够做得比老鼠朋友们更好。</p>
<p>　　他的头脑里出现了清晰的图画，他的生活将会变得更美好，而且他还会在迷宫中发现一些更好的东西。 唧唧不断地反思自己过去犯下的错误，他要汲取这些经验教训，去构划自己的未来。他知道，自己完全可以通过总结和学习，掌握如何应对变化：</p>
<p>　　首先要更清醒地认识到，有时需要简单地看待问题，以及灵敏快速地行动。</p>
<p>　　你不必把事情过分复杂化，或者一味地让那其次必须要善于发现一开始发生的那些细微的变化，以便你为即将来临的更大的变化做好准备。</p>
<p>　　他知道，他需要做出更快的调整。因为，如果不能及时调整自己，就可能永远找不到属于自己的奶酪。 还有一点必须承认，那就是阻止你发生改变的最大的制约因素就是你自己。只有自己发生了改变，事情才会开始好转。</p>
<p>　　最重要的事，新的奶酪始终总是存在于某个地方，不管你是否已经意识到了他的存在。只有当你克服了自己的恐惧念头，并且勇于走出久已习惯的生活，去享受冒险带来的喜悦的时候，你才会得到新奶酪给你的报偿和奖赏。</p>
<p>　　唧唧还认识到，有些畏惧是需要加以认真对待的，它会帮助你避开真正的危险。但绝大部分的恐惧都是不明智的，它们只会在你需要改变的时候，使你回避这种改变。 唧唧曾经那样地惧怕改变，他真的希望生活能够永远按照原有的样子继续，但现在他意识到，生活并不会遵从某个人的愿望发展。改变随时有可能降临，但积极地面对改变却会让你发现更好的奶酪，真的是塞翁失马，焉知非福。</p>
<p>　　唧唧已经看到了变化更好的一面。</p>
<p>　　当他回想起这些自己所学到的东西时，他不由得想起了他的朋友哼哼。他不知道哼哼是否读到了哪些他在奶酪C站和迷宫各个角落墙上的留言，不知道哼哼是否已经走出了迷宫。</p>
<p>　　哼哼是否已经决定放开已经失去的过去并且开始行动？他是否已经重新回到迷宫中。并且发现了能使他的生活变得更好的东西？</p>
<p>　　或者，他因为不肯改变，还在那里迟疑不前？</p>
<p>　　唧唧在考虑回到奶酪C站去，看看是否能找到哼哼—-但首先得肯定自己能找到回来的路。如果找到哼哼，他会把自己学到的东西告诉他，帮助他摆脱困境。但唧唧又想起他已经试图改变过他的失败的经历。</p>
<p>　　哼哼必须自己发现适合自己的道路，摆脱安逸，超越恐惧。没有人可以代替他做到这一点，或者告诉他应该怎样去做。他必须迈出第一步，否则他永远不会看到改变自己所带来的好处。</p>
<p>　　唧唧知道自己已经给哼哼留下了足够的标记，只要他能够迈出第一步，读到墙上的字迹，他就会找到奶酪。 于是唧唧打消了回奶酪C站的念头，他站起来走到奶酪N站最大的一面墙前，把他一路上得到的心得体会的要点写了下来。他拿起一块很大的奶酪，这是他见过的奶酪中最大的一块。唧唧品尝着新鲜的奶酪，望着自己写下的体会，脸上绽出了微笑：</p>
<p>　　&lt;变化总是在发生&gt;</p>
<p>　　他们总是不断地拿走你的奶酪。</p>
<p>　　&lt;预见变化&gt;</p>
<p>　　随时做好奶酪被拿走的准备。</p>
<p>　　&lt;追踪变化&gt;</p>
<p>　　经常闻一闻你的奶酪，以便知道它们什么时候开始变质。</p>
<p>　　&lt;尽快适应变化&gt;</p>
<p>　　越早放弃旧的奶酪，你就会越早享用到新的奶酪。</p>
<p>　　&lt;改 变&gt;</p>
<p>　　随着奶酪的变化而变化。</p>
<p>　　&lt;享受变化&gt;！</p>
<p>　　尝试冒险，去享受新奶酪的美味！</p>
<p>　　&lt;做好迅速变化的准备，不断地去享受变化&gt;</p>
<p>　　记住：他们仍会不断地拿走你的奶酪。　</p>
<p>　　唧唧在想，自从他在奶酪C站和哼哼分道扬镳以来已经有多久了。他知道自己前进了一大步，打他也很清楚，如果他过分沉溺于N区的安逸生活之中，他就会很快滑落到原来的困境。所以，他每天都仔细检查奶酪N站的情况。他在做一切力所能及的事情，以尽量避免被意料之外的变化打个措手不及。</p>
<p>　　当他还有大量的奶酪贮备时，他就开始经常到外面的迷宫中去，他所新的领地，以便自己与周围发生的变化随时保持联系。现在他非常明白，了解各种实际的选择，要比呆在舒适的环境里把自己孤立起来安全的多。 “窸窸窣窣”，他听到什么，唧唧竖起耳朵听了听，他觉得是从迷宫里传来的走动的声音。这声音渐渐大起来，他知道有人正向着这边跑来。</p>
<p>　　会是哼哼到了吗？他会循着那个弯转过来吗？</p>
<p>　　唧唧念了几句祈祷语，他真的希望;像他以前曾多次希望的那样—-也许，他的朋友终于能够……<br>  结局……或者是新的开始？</p>
<hr>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论:"></a>讨论:</h3><p>　　同一天傍晚，故事讲完以后的讨论</p>
<p>　　迈克尔讲完他的故事后，环顾四周，发现他的老同学都在微笑着倾听。</p>
<p>　　有几个人站起身来向他表示感谢，说他们从故事中得到了很多启发。</p>
<p>　　内森问大家：“一会儿我们聚在一起讨论一下这个故事，你们觉得怎样？”</p>
<p>　　大多数人都表示他们的确很想谈一谈自己的感受。于是，他们决定先去喝点东西，再吃晚餐，然后一起讨论这个故事。</p>
<p>　　当天晚上，他们聚集在饭店的房间，相互开着玩笑说，看见他们自己在迷宫中寻找各自的“奶酪”。</p>
<p>　　安杰拉要大家安静下来，并询问道：“你们觉得自己是这故事中的谁？嗅嗅和匆匆，还是哼哼或唧唧？”</p>
<p>　　卡洛斯第一个回答说：“呃，整个下午，我都在考虑这个问题。我清楚地记得，有一段时间，在我开始我的运动器材生产之前，我曾遇到过一次突如其来的改变。”</p>
<p>　　“我不是嗅嗅—-我没能及早嗅出潜在的危机并看出已经发生的变化。我也不像匆匆—–因为我没有立即投入行动。”</p>
<p>　　“我想我更像是哼哼，当时我只愿意呆在自己熟悉的领域。事实上，我根本不想去应对改变，我甚至不想看到变化。” 迈克尔和卡洛斯在学校时是好朋友，现在还是像以前一样亲密，他不解地问道：“兄弟，你所说的那个突然的改变究竟是怎么回事？”</p>
<p>　　卡洛斯说：“那是工作上的一个意想不到的变化。”</p>
<p>　　迈克尔笑起来：“你被开除了？”</p>
<p>　　“噢，还不如说，我只是从来不曾想过要去寻找新的奶酪。我曾经想到很多理由，总觉得变化不应该发生在我身上，老实说，那段时间，我感到非常沮丧。”</p>
<p>　　刚开始的时候，有几位同学一直没有参加讨论，现在听了迈克尔的话也都开始议论。首先是已经应征入伍的弗兰克。</p>
<p>　　“哼哼使我想起了我的一位朋友，”他说：“所有迹象显示他所在的部门将被裁撤，但他不肯面对这个现实。公司为所有人做了重新安排。我们都试图劝说他，只要愿意改变，公司里还有很多其他的机会，但他始终觉得自己没有必要改变。当他所在的部门最终关闭时，他是惟一惊讶得不知所措的人。现在，他正在做出艰难的调整，以适应他应为不该发生的变化。”</p>
<p>　　杰西卡说：“我也一向认为这种事情不会发生在我身上，但我的奶酪已经不止一次地被拿走了，尤其是在我的个人生活中。但最后我总能找到我的奶酪。”</p>
<p>　　除了内森，大家都笑了。</p>
<p>　　“也许，这就是关键之处，”内森说：“变化发生在我们每一个人身上。”</p>
<p>　　他补充道：“我真希望我的家人以前就听到过这个故事。不幸的是，我们第一个人都不愿意面对发生在我们家族企业中的变化。现在为时已晚—–我们不得不关闭我们的许多家店铺了。”</p>
<p>　　内森的话让很多人吃了一惊，因为大家一向都很羡慕内森幸运，认为他可以躺在自己的家族企业中，年复一年地依靠它。</p>
<p>　　“发生了什么事？”杰西卡急于问个究竟。</p>
<p>　　“当超级商场进入小镇时，我们的小型连锁店突然间显得过时了。他们有大量丰富且价格低廉的商品，我们完全与之竞争。”</p>
<p>　　“现在我终于明白了，这一切后果归咎于我的家人都不是嗅嗅和匆匆，我们就象哼哼。我们呆在原来的地方固步自封，拒绝改变；我们故意忽略外面的世界，企图对发生的一切视而不见。现在我们陷入了麻烦，这一要只是因为我们不愿意嘲讽自己，不愿意改变所做的。我们真应该从唧唧身上学到些什么。”</p>
<p>　　劳拉已经是一位很成功的商人，到现在为止，她很少说话，一直在聆听。“这个下午，我也一直在思考这个故事，”这时她说：“我不知自己要怎样做才能更像唧唧，才能够看到自己的错误，坦然面对自己，改变自己，并将一切做得更好。”</p>
<p>　　沉默了一会儿，她继续说：“我想知道，我们这时有多少人害怕改变？”见没有人回答。于是她又提议：“请举手示意。”</p>
<p>　　只有一个人举了手。“很好，看起来，我们之中总算还有一个诚实的人!”她说，并继续道：“也许你们更愿意回答下一个问题。有多少认为别人害怕改变？”这一次几乎每个人都举了手。见此情景，大伙都大笑起来。</p>
<p>　　“刚才的现象说明了什么？”</p>
<p>　　“我们都拒绝承认自己害怕改变。”内森回答。</p>
<p>　　“确实是这样，”迈克尔表示赞同，“有时候，连我们自己也没有意识到我们在害怕，或者说我们在努力想掩盖自己的恐惧。我知道我就是如此，当我第一次听到这个故事的时候，我就非常喜欢这句话，‘当你无所畏惧时，你会怎样’。” 杰西卡接口道：“我从这个故事中得到的启示是，变化无时无处不要发生，无论我们是害怕还是喜欢改变，但如果我们能尽快调整自己适应变化，我们应该可以做得更好。”</p>
<p>　　“我还记得几年前我们公司发生的事情。当时我们正在销售一套百科全书，全套书有二十多本。有个人想要说服我们，他告诉我们应该把整套百科全书做成一张计算机光盘，只卖现在价格的零头。这样做，既可以及时更新，又可以使生产费用大为减少，而且将有更多的人买得起并可以使用它。但是当时我们拒绝了这个建议。”</p>
<p>　　“你们为什么要拒绝呢？”内森问道。</p>
<p>　　“因为当时我们确信，我们企业的主力，是我们挨家挨户地推销的庞大销售队伍，我们的高价产品使我们的销售人员可以获得高额佣金从而更加卖力气地工作。长期以来，我们一直都这样做并且做得很成功，我们都认为这种方式还会继续有效。”</p>
<p>　　劳拉说：“也许这就是故事里所要表明的，哼哼和唧唧由于成功而形成的傲慢。他们从来没有，他们需要改变那些曾经是有效的东西。”</p>
<p>　　“这方法就是你们的奶酪!”内森说：“并且你们认为这块旧奶酪是你们惟一的奶酪。”</p>
<p>　　“的确如此，我们甚至想依靠这种方法直到永远。”</p>
<p>　　“当我回过头去想发生的事情时，我发现，奶酪不仅仅会被移走。奶酪也有自己的生命，终究有被吃完的一天。”</p>
<p>　　“结果怎么样呢？”劳拉问。</p>
<p>　　“我们没有变。一个竞争者做了改变，所以我们的生意一落千丈，一直到现在我们都很艰难。如今，在这个产业领域里技术上已经发生了很大的变化，但我们公司里却没有一个人想去应对这种变化。这看起来很不妙，我想我快要失业了。” </p>
<p>　　“这真是一个迷宫的时代!”卡洛斯忽然叫道。大家都笑了起来，杰西卡也笑了。</p>
<p>　　卡洛斯转向杰西卡说道：“你已经可以坦然地嘲笑你自己了，这很好啊。”</p>
<p>　　弗兰克附和说：“这也是我从故事中得到的体会，我们常常过于认真地看待自己。我注意到在故事里，当唧唧终于能够坦然嘲笑自己错误的过去时，他得到了应对变化的方法。关键就在于要敢于否定自己，勇敢地嘲讽自己做的傻事，难怪他的名字要叫作唧唧。”</p>
<p>　　大家都模仿这个词，发出哼哼唧唧的声音。</p>
<p>　　安杰拉问大家：“你们认为哼哼是否会改变，是否能够找到新的奶酪？”</p>
<p>　　依莱恩说：“我想他会的。” “我认为不会，”柯瑞说：“有的人绝对不肯改变，并为此付出了代价。在我行医的时候，我见过像哼哼这样的人。他们觉得他们天生具备拥有自己的奶酪的资格和权力，当奶酪被拿起以后，他们觉得自己是受害都并为此而指责别人，抱怨能够抱怨的一切。他们比那些最终能够放开自己去行动的人要病得厉害得多。”</p>
<p>　　这时，内森轻轻地、好像自言自语般地说道：“我觉得，真正的问题是，‘我们需要放弃什么，以及应该朝哪里行动？’”</p>
<p>　　好一会儿，大家都不说话。</p>
<p>　　“我必须承认，”内森又说：“当我看到其他地方的商业经营运作方式正在改变时，我完全有时间有能力改变自己去就应对这种变化，然而我们当时只是一厢情愿地认为这种变化不会影响到我们。所以我认为，率先变化比对变化做出反应和调整要强得多。也许，我们应该做的就是移走我们自己的奶酪。” </p>
<p>　　“你的意思是……”弗兰克问。</p>
<p>　　内森回答说：“我不禁在想，如果当初我们卖掉我们商店的不动产，建立一个大型的现代化商场与那些超级商场竞争，结果又会是怎样？”</p>
<p>　　劳拉说：“也许这就是唧唧写在墙上的意思‘尝试冒险，与奶酪一起变动’。”</p>
<p>　　弗兰克说：“我现在认识到，如果我很早就随着我的‘奶酪’移动，我会好得多。但我觉得有些东西是应该保持不变的，例如，我们的基本价值观。”</p>
<p>　　“噢，迈克尔，这真是一个有意义的小故事。”理查德说，他是班上的怀疑论者，“但是，我们究竟应该是怎样把它实际运用到我们的生活中去呢？”</p>
<p>　　大家都不知道，但理查德自己的生活正在经历某些变化。最近，他和妻子离婚了，因此既要做好工作又要照顾好十几岁的孩子。</p>
<p>　　迈克尔回答说：“你知道吗？以前我的工作就是处理每天正在发生的问题。现在我发现实际上我应该做的是，朝前看，把注意力放在我们公司发展的在大方向上，而不是不断地应付眼前的小事。”</p>
<p>　　“我整个人都投入到处理这些枝节问题中去了—-一天二十四小时，感受不到任何乐趣。我陷入老鼠赛跑的圈子，无法跑出来。”</p>
<p>　　“所以，你总是为琐事纠缠无暇喘息，而其实你更应该抽身出来，主动支配时间。”劳拉说。</p>
<p>　　“确实如此。”迈克尔说：“后来，当我听到‘谁动了我的奶酪’的故事后，我认识到我的工作应该是描绘一幅‘新奶酪’的图景—-公司全体员工都希望追寻的‘新奶酪’，然后将这新奶酪清晰、真实地呈现在所有员工的面前。这样，我们才会享受到变化和成功的喜悦，否认是在工作中还是在生活中。”</p>
<p>　　内森问道：“你在工作中是怎样去做的？”</p>
<p>　　“喔，我问我们公司里的人，他们是故事中的谁，发现我们公司中这四种角色都有。我看到了嗅嗅、匆匆、哼哼和唧唧，每一种角色都需要区别对待。”</p>
<p>　　“我们的嗅嗅能够敏锐地嗅出市场的变化，以便我们能够及时调整公司的战略。公司鼓励他们去识别哪些变化会影响顾客对新产品和服务的需求。嗅嗅们喜欢这项工作，他们告诉我，他们喜欢在这样的环境中工作，在这里他们能够识别变化并及时做出调整。”</p>
<p>　　“我们的匆匆喜欢做事，在公司的新战略，在公司的新战略中，他们被鼓励去采取行动。他们只需要稍加引导，以免跑错了方向。公司获得了新奶酪，这应归功于他们的行动。他们喜欢在这样的公司里工作，在这里能够体现行动的结果和价值。”</p>
<p>　　“那么，哼哼们就像是船锚想使我们停下来，”迈克尔说：“他们或者是太在意享受眼前的安逸，或者是过分害怕改变。不过当我向他们展示了具体的景象，并说明变化将会带来的好处时，有些哼哼最终改变了。”</p>
<p>　　“我们的哼哼们说，他们想要在一个安全的环境下工作，所以，变化应在他们所能接受的范围内并增加安全感。然而当我让他们认识到僵化不变的可怕时，其中有些人发生了改变，而且干得不错。这种景象使许多的哼哼变成了唧唧。”</p>
<p>　　“对那些没有改变的哼哼，你们怎么办呢？”弗兰克问道。</p>
<p>　　“我们不得不让他们走人。”迈克尔黯然答道：“我们希望留下所有的员工，但我们清楚，我们必须要迅速而充分地改变，否则我们全体都会陷入麻烦之中。”</p>
<p>　　他又说：“我们的唧唧们起初还有些犹豫，值得欣慰的是，他们思想开放，乐于去学习新的东西，及时调整并付诸实施，从而使我们获得成功。”</p>
<p>　　“他们甚至开始期待变化而且积极地寻求变化。他们了解大家究竟想要什么，和我们一起描绘出一幅实际可行的新奶酪的美景图，让所有的人充满期待并积极行动起来。”</p>
<p>　　“他们说他们希望在这样的组织中工作，能够给人自信和变化的工作。在我们追随新奶酪的过程中，他们还给我们带来了许多迎接挑战的乐趣。”</p>
<p>　　理查德揶揄道：“没想到你从一个小故事中得到了这么多东西？”</p>
<p>　　迈克尔笑了：“因为我并没有仅仅停留在听故事的层面上，而是从中找到了我想要的东西，并且采取了行动。”</p>
<p>　　安杰拉点头表示同意：“这做法真的很有趣。因为在我看来，这故事中最有影响力的部分是，当唧唧勇敢地嘲笑自己的畏惧，开始在头脑中描绘一幅自己在享受新奶酪的情景，然后充满信心和喜悦地走进迷宫，追寻新的奶酪，并最终获得了成功。我想这也是我常常想要做的事情。”</p>
<p>　　弗兰克笑了一下：“所以，甚至哼哼有时也能看到变化的好处。”</p>
<p>　　卡洛斯补充说：“甚至还有得到提拨的好处。”</p>
<p>　　理查德一直皱着眉头若有所思。这时他说：“我的上司一直在告诉我，公司需要有所改变。我想她实际上是想告诉我应该做出某些改变，但我实在不想听到这些。我觉得自己真的不知道，她想让我们去找的‘新奶酪’是什么，或者，我能从那新奶酪中得到些什么。”</p>
<p>　　说到这里，一丝微笑掠过他的脸庞：“听了这个故事我必须承认，我开始喜欢这个想法，看见新的奶酪并想像自己正在享用它。这种想法能使每件事都变得更有希望。当你想到变化能使事情变得更好时，你就会有很大的兴趣去促成变化的发生。”</p>
<p>　　“也许我应该把这些观念和方法运用到我的个人生活中去，”他说：“我的孩子们觉得他们的生活不应该改变。我看他们也有点像哼哼—-当事情发生改变时，他们会愤怒。因为他们不知道改变后会怎么样。这也许是我没有给他们描绘出一幅‘新奶酪’的美景的缘故。也许因为连我自己都害怕变化，连我自己都没有看到那‘新奶酪’的美景吧？”</p>
<p>　　听了这番话，所有人都想到了自己的生活，大家安静下来。</p>
<p>　　“呃，”杰西卡清了清嗓子，打破了宁静，“大家好像都在谈论自己的工作，但是我听到这个故事以后，却想到了我的个人生活。我觉得我目前的情况，我的家庭关系，就像一个‘旧奶酪’，上面长满了霉菌。”</p>
<p>　　柯瑞笑出声来，表示赞同：“我也是，也许我现在最该采取行动的就是让一段不愉快的关系尽快过去。”</p>
<p>　　安杰拉反驳道：“我不同意你的观点，也许这个‘旧奶酪’只是一种旧的方式。我们需要放弃的只是引起这种状态的旧的行为方式，而不是这个‘奶酪’。这样我们才会朝更好的思维和行为方式转变。”</p>
<p>　　“对呀!”柯瑞受到启发，“好观点。新奶酪说是用新的积极的行为方式与一个人建立新关系。”</p>
<p>　　理查德说：“我在想，也许这个故事还有更多有建设性的启发等待我们挖掘。我同意安杰拉的观点—-需要放弃的是旧的行为方式而不是关系本身。一成不变的行为方式还是会导致同样的结果。” “就工作而言，我应该成为帮助公司进行改变的人之一，而不是害怕公司的改变而辞去工作。如果早这么想、早这么做的话，我也许就会有一个更好的职位了。”</p>
<p>　　贝基生活在另一个城市，这次特意赶来参加同学聚会。这时她说：“当我在听这个故事，以及听到大家的讨论时，我真的禁不住要讥笑自己。许久以来，我一直像哼哼那样，害怕改变，凡事迟疑犹豫，拒绝改变，为此我不知道丢掉了多少美味的奶酪。我不知道其他人怎样，我恐怕已经在不得不中，把这种哼哼式的思想传给了我的孩子们。”</p>
<p>　　“当我反复思考这个问题和身边的一些人和事后，我在想或许变化真的能把你一个崭新的、更好的地方，尽管当时你担心事情的变化将并非如此。” “我记得有五段时间，在我儿子上中学二年级的时候。因为我先生工作的需要，我们必须从伊利诺搬到佛蒙特去，儿子为此很难过，因为他不得不离开他的朋友们了。他是学校里的游泳明星，但在佛蒙特的高中里却没有游泳队。因此，他对我们即将面临的变化感到很生气。”</p>
<p>　　“然而后来的情况是，他疯狂地迷上了佛蒙特的山区，开始学习滑雪，并参加了大学的滑雪队和登山队。现在，他有了更多的新伙伴，他愉快地生活在科罗拉多。” “如果当初面对改变时，我们全家能端上一杯热巧克力，一起享受这个故事的乐趣，或许我们家庭中的许多无谓的压力和紧张气氛早就烟消云散了。”</p>
<p>　　杰西卡赶忙说，“没错，我回去后，要把这个故事和全家分享。我还要问我的孩子们，我像故事中的谁—-嗅嗅、匆匆，还是哼哼和唧唧—-他们又觉得自己像谁。我们还要讨论，我们家的‘旧奶酪’是什么，‘新奶酪’又应该是什么。”</p>
<p>　　“这的确是个好主意!”理杰德大声赞同，把大家吓了一跳，连他自己都奇怪怎么会这么大声。</p>
<p>　　弗兰克也受到快乐情绪的感染，喜悦之情溢于言青：“我觉得自己越来越像唧唧，我已经做好准备随着奶酪的移动而移动，并且能够从中得到快乐!我也要把这个故事讲给我这中的朋友们，他们正担心离开部队后生活的变化。这一定会引起一场有趣的讨论。”</p>
<p>　　迈克尔接着说：“对，这也是我们当初改进我们企业的方法。我们搞过几场讨论，讨论我们从故事中学到什么，以及如何把它们运用到我们的实际工作中去。”</p>
<p>　　“这很重要。因为我们有了轻松的、共同的语言，用来谈论怎样应对变化，包括公司的和个人生活的。这方法非常有效，它已经深深地渗入到我们公司的各个方面。”</p>
<p>　　内森问道：“‘深深地’是什么意思？” “喔，是这样的，我们发现，越是组织的内层，就越缺乏活力。可以理解，他们比外层人员更加害怕改变，害怕上面强加给他们的改变会发生在他们身上。所以，他们拒绝改变。”</p>
<p>　　“简言之，强加的改变是最易遭到反抗及阻力的改变。”</p>
<p>　　“当‘奶酪的故事’以书面的形式在我们机构中分发出去以后，它改变了大家看待变化的态度。对于自己过去的畏惧，每个人都笑起来，至少是微笑了。每一个人都开始主动地考虑‘改变’这个题目。”</p>
<p>　　“但我要是能够早点听到‘奶酪’的故事并把它用于公司讨论就好了!”迈克尔加了一句。</p>
<p>　　“为什么？”卡洛斯不理解地问。</p>
<p>　　“因为当我们开始向变化靠拢的时候，我们的企业已经一团糟了。生意一落千丈，我们不得不解雇一些 员工，正如我前面提到的，甚至包括一些好朋友。这对我们大家来说都是一件痛苦的事情。惟一值得欣慰的是，所有留下来的和大多数离去的人都说，奶酪的故事使他们改变了看问题的方式，使他们能够更好地对付各种局面。”</p>
<p>　　“那些离开公司，出去找新工作的人说，开始时确实很艰难，但是，每每回想起这个故事，就会得到极大的帮助。”</p>
<p>　　安杰拉问道：“对他们最大的帮助是什么？”</p>
<p>　　迈克尔回答：“他们告诉我，超越自己的恐惧的最大好处是，他们认识到外面到处有新奶酪等着被发 现，只要他们愿意去寻找。”</p>
<p>　　“他们说，头脑中存有一幅新奶酪的景像—-看见自己在新的工作中干得很好—-会使他们的感觉好一些。尤其是使他们在面试的时候表现得更为出色。有些人还因此得到了比原来更好的工作。”</p>
<p>　　劳拉问：“那些留在公司的人又怎么样了呢？”</p>
<p>　　“噢，”迈克尔说：“人们不再抱怨市场环境正在发生的种种变化。他们说‘既然我们的旧奶酪已经不见了，那么让我们去找新的奶酪吧。’这省去了公司许多的协调时间，也减少了公司内部的紧张感和压力。”</p>
<p>　　“不久前还完全拒绝变化的人，如今也透过这个小故事看到了变化的好处。他们越来越喜欢变化，并且积极创造有利于公司发展的变化。”</p>
<p>　　柯瑞说：“是什么使得他们改变了呢？”</p>
<p>　　“我认为这和公司里面存在的同事之间的相互影响力有关系，”迈克尔答道：“如果这种影响力改变了，人们就会跟着发生改变。”</p>
<p>　　“大家可以回想一下，在你呆过的机构里面，当上级宣布一项改变时，大多数人会有什么反应？大多数人会说这改变是一个好主意还是一个坏主意？”</p>
<p>　　“一个坏主意。”弗兰克答道。</p>
<p>　　“没错。”迈克尔表示同意，又接着问道：“为什么会这样呢？”</p>
<p>　　卡洛斯说：“我想因为大多数人都喜欢稳定和有安全感，他们觉得改变会带给自己麻烦甚至有可能对自己不得。当有一个人说这种改变是一个坏主意时，其他人通常会随声附和。”</p>
<p>　　“的确如此，但这些随声附和的人在心里也许并不真的这样认为。”迈克尔说：“只是他们为了看起来和最先提议反对的那个人一样聪明以及显得合群，就会随声附和。这就是我所说的同事之间的相互影响力。这种影响力通常会阻碍机构中发生的变化。”</p>
<p>　　贝基问道：“那么当人们听到奶酪的故事以后，情况又怎么样了？”</p>
<p>　　迈克尔耸了耸肩膀，轻松地说：“情况是同事之间的相互影响力改变了，因为大家都不希望自己被别人叫作哼哼!”</p>
<p>　　大家听了都哈哈大笑了起来。</p>
<p>　　“他们都想提前嗅出变化的味道，并且赶快投入行动，而不再是落在后头哼哼不停。”</p>
<p>　　内森说：“这是一个好点子。我想我们家的人也都不愿做哼哼，他们很可能也会因为这个故事而改变。上一次同学聚会时，你为什么没有告诉我们这个故事？要不然，它早起作用了。”</p>
<p>　　“它确实有用。”迈克尔说。</p>
<p>　　“而且非常有用!尤其是当你的机构中的每个人都知道它时—-不管是大公司，还是小企业，或者是你的家庭—-因为，只有当其中的多数人的心态发生改变以后，一个组织才会发生变化。”</p>
<p>　　最后，迈克尔又给大家介绍了一个经验：“当这个故事对我的公司起作用以后，我们便把这故事告诉给那些我们希望能和他们在生意上有所合作的人，因为我们知道任何一个公司都正面临变化和选择。我们提议说，也许我们就是他们正在找寻的‘新奶酪’，也就是说，我们可能就是能让他们的生意更成功的合作伙伴。这方法的确为我们带来了许多新的机会和生意。”</p>
<p>　　这番话使杰西卡受到启发，她想起明天上午要谈的几笔业务。她赶紧看了看时间，说：“喔，时间到了，该是我离开这个奶酪站，去寻找新的奶酪的时候了。”</p>
<p>　　大家都会心地笑了起来，然后站起身来互道晚安。尽管许多人觉得兴犹未尽，还想继续聊这个话题，但时间的确已经不早了。分手的时候，他们再一次感谢迈克尔。</p>
<p>　　迈克尔说：“我非常高兴你们觉得这个故事对你们有所帮助，我也衷心希望你们有机会尽快与别人分享这个故事。”</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/archives/2e152a56.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/08/xe4MyIJXcmufOQa.jpg" style="zoom:50%;" />

<p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）</p>
<span id="more"></span>

<p>对于存储在链表中的数据，只需要对链表稍加改造，就可以支持类似“二分”的查找算法，我们把改造后的数据结构叫做<strong>跳表</strong>（Skip list）</p>
<h3 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h3><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<img data-src="https://i.loli.net/2021/08/17/xjHD5CGnqP3bKsW.jpg" style="zoom:50%;" />

<p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<strong>索引</strong>或<strong>索引层</strong>。</p>
<img data-src="https://i.loli.net/2021/08/17/BGqbofPdxgiJ3C4.jpg" style="zoom:50%;" />

<p>假如现在要查找结点16，我们可以先在索引层遍历，当遍历到索引值为13时，发现下一结点是17，那要查找的结点16就在这两结点之间。然后我们通过索引层结点的down指针，下降到原始链表层，继续遍历即可。原来需要遍历10个结点，现在只需要7个结点。</p>
<p>从这个例子里，我们看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。</p>
<p>数据量大的话，可以添加多层索引提升效率。<strong>这种链表加多级索引的结构，就是跳表</strong>。</p>
<img data-src="https://i.loli.net/2021/08/08/tKFQ2YcO1dnWS9E.jpg" style="zoom:50%;" />

<h3 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h3><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，**第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 $n/(2k)$**。</p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>
<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点，即 m=3。</p>
<img data-src="https://i.loli.net/2021/08/08/2tfn93XdPqk5oKi.jpg" style="zoom:50%;" />

<h3 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h3><p>跳表就是通过空间换时间的设计思路来实现了和二分查找一样的时间复杂度。根据前面的公式，可以得到跳表的空间复杂度就是$n/2+n/4+n/8…+8+4+2=n-2$​。</p>
<p>如果想要降低索引占用的内存空间，也可以选择三个结点或五个结点抽取一个到上级索引。</p>
<p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了</p>
<h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。因为插入、删除操作的耗时都在查找遍历上，要注意删除时如果结点在索引中也有出现，那要同事删除原始链表和索引的结点</p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<img data-src="https://i.loli.net/2021/08/17/GqCEabQFgxnKP93.jpg" style="zoom:50%;" />

<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<img data-src="https://i.loli.net/2021/08/17/rZVm9lJ1P3Rzd4Q.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/archives/2362a8ea.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/07/29/Y576HhpLyZSwtdR.jpg" style="zoom:50%;" />

<p>链表（Linked list）有一个经典应用场景：<strong>LRU缓存淘汰算法</strong>。</p>
<span id="more"></span>

<p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p>
<h3 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h3><p>链表，是通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，常见的有三种链表结构：单链表、双向链表和循环链表。</p>
<img data-src="https://i.loli.net/2021/07/29/HniWdagVZIUA9MS.jpg" style="zoom:50%;" />

<p>先来看<strong>单链表</strong>，所谓的内存块我们称为<strong>“结点”</strong>，为了将结点串起来，每个链表结点除了存储数据外，还要记录下一个结点地址，我们这个记录指针叫做<strong>后继指针next</strong></p>
<img data-src="https://i.loli.net/2021/07/29/z3OrpVFKA98bLxW.jpg" style="zoom:50%;" />

<p>我们习惯性把第一个结点叫做<strong>头结点</strong>，记录链表的基地址，最后一个结点叫做尾结点，指向一个<strong>空地址NULL</strong> 。</p>
<p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。</p>
<img data-src="https://i.loli.net/2021/07/29/7Z5nfTOEFGueJbv.jpg" style="zoom:50%;" />

<p>有利就有弊，链表的随机访问效率教数组差，因为需要一个结点一个结点依次遍历，需要 O(n)的时间复杂度。</p>
<p><strong>循环链表</strong>是一种特殊的单链表，区别在于尾结点是指向链表的头结点。</p>
<img data-src="https://i.loli.net/2021/07/29/QYUpe2c1oOZSVGt.jpg" style="zoom:50%;" />

<p>在实际软件开发中，更加常用的链表结构是另外一种：<strong>双向链表</strong>。它需要额外的两个空间来存储后继结点和前驱结点的地址，占用更多内存空间，但可以支持双向遍历，以此换来操作的灵活性。</p>
<img data-src="https://i.loli.net/2021/07/29/n3ZDTsVouNEgGvl.jpg" style="zoom:50%;" />

<p>要明白双向链表的高效性体现在哪里，我们可以看一下<strong>删除操作</strong>。</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点；</li>
<li>删除给定指针指向的结点。</li>
</ul>
<p>第一种情况，单链表和双向链表都需要遍历查找值而后进行删除，仅删除操作复杂度为 O(1)，但遍历查找是主要耗时步骤，复杂度为 O(n)。</p>
<p>第二种情况，已经明确要删除的结点，而单链表不支持获取前驱结点，仍需要从头遍历，直到 <code>p-&gt;next=q</code>,说明 p 是 q 的前驱结点。双向链表就可以在 O(1) 复杂度内完成，插入、查询操作同理分析。</p>
<p>在java语言中，LingedHashMap容器就是使用了双向链表结构。</p>
<p>一个很重要的知识点，<strong>用空间换时间</strong>的设计思想在实际开发中应用广泛。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p>
<p>将循环链表和双向链表整合到一起，就是一个新的版本：<strong>双向循环链表</strong></p>
<img data-src="https://i.loli.net/2021/07/29/wZFghGe3OvS8iPs.jpg" style="zoom:50%;" />

<h3 id="链表-VS-数组性能对比"><a href="#链表-VS-数组性能对比" class="headerlink" title="链表 VS 数组性能对比"></a>链表 VS 数组性能对比</h3><img data-src="https://i.loli.net/2021/07/29/Iizay4gULP2dmKR.jpg" style="zoom:50%;" />

<p>不过，实际软件开发中，不能仅用复杂度分析就决定使用那个数据结构。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，对CPU缓存不友好，没法有效预读。</p>
<p>数组缺点是大小固定，一经声明就要占用连续内存空间，如果数组过小，就要重新申请一个更大的空间，将原数组拷贝进去，非常费时。链表本身没有大小限制，天然支持动态扩容，这也是它与数组最大区别。</p>
<h3 id="如何实现LRU缓存淘汰算法"><a href="#如何实现LRU缓存淘汰算法" class="headerlink" title="如何实现LRU缓存淘汰算法?"></a>如何实现LRU缓存淘汰算法?</h3><p>通过哈希表辅以双向链表实现</p>
<ul>
<li>双向链表按照使用顺序存储键值对，越靠近头部是最近使用的，靠近尾部则是最久未使用的</li>
<li>哈希表通过缓存数据的键映射到双向链表中的结点位置</li>
</ul>
<p>如此便可使用哈希表定位，找出缓存项在双向链表中位置，再将其移到头部即可在 O(1) 时间内完成 get 或者 put 操作</p>
<ul>
<li>get 操作，首先判断 key 是否存在<ul>
<li>如果 key 存在，返回 -1</li>
<li>如果 key 存在，通过 hash 表定位后将结点移到头部位置，返回结点值</li>
</ul>
</li>
<li>put 操作，首先判断 key 是否存在<ul>
<li>如果key 存在，更新结点值，将其移动到头部</li>
<li>如果key 不存在，使用 key 和 value 创建一个新结点，在链表头部添加盖结点，并将key 和结点添加到哈希表中。然后判断双向链表结点数是否超出容量，是则删除尾结点，并删除哈希表中对应项 </li>
</ul>
</li>
</ul>
<p>Tips：在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p>
<hr>
<img data-src="https://i.loli.net/2021/07/29/JCDU5BngouvNVYh.jpg" style="zoom:50%;" />

<h3 id="如何轻松写出正确的链表代码？"><a href="#如何轻松写出正确的链表代码？" class="headerlink" title="如何轻松写出正确的链表代码？"></a>如何轻松写出正确的链表代码？</h3><p><strong>理解指针或引用的含义</strong></p>
<p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<p><strong>警惕指针丢失和内存泄漏</strong></p>
<p>看下面代码，现在需要在结点 a 和相邻的结点 b 之间插入结点 x，假设当前 p 指向结点 a，下面写法就会发生指针丢失和内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;next &#x3D; x;  &#x2F;&#x2F; 将p的next指针指向x结点；</span><br><span class="line">x-&gt;next &#x3D; p-&gt;next;  &#x2F;&#x2F; 将x的结点的next指针指向b结点；</span><br></pre></td></tr></table></figure>

<p>p-&gt;next 指针在完成第一步后已经不再指向结点 b 而是结点 a，第二行代码相当于将 x 赋值给 x-&gt;next。</p>
<p>插入结点时，一定要注意操作顺序，同理，删除结点时，也一定要记得手动释放内存空间。</p>
<ul>
<li>利用哨兵简化实现难度</li>
</ul>
<p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。引入哨兵结点后不管链表是否为空，head指针都会指向这个哨兵结点，我们把这种链表叫<strong>带头链表</strong>，没有哨兵结点的链表就叫做<strong>不带头链表</strong>。如此便可统一相同的代码实现逻辑。</p>
<img data-src="https://i.loli.net/2021/08/17/NdDxtkZ9u2HfyCl.jpg" style="zoom:50%;" />

<p>哨兵是用来解决边界问题的，可以理解为它可以减少特殊情况的判断，比如判空、越界等，增加效率。</p>
<p>代码一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 边界条件处理，如果a为空，或者n&lt;=0，说明数组中没有数据，就不用while循环比较了</span></span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里有两个比较操作：i&lt;n和a[i]==key.</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="comment">// 我举2个例子，你可以拿例子走一下代码</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 7</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 6</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span></span><br><span class="line">  <span class="keyword">if</span> (a[n<span class="number">-1</span>] == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。</span></span><br><span class="line">  <span class="comment">// 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span></span><br><span class="line">  <span class="keyword">char</span> tmp = a[n<span class="number">-1</span>];</span><br><span class="line">  <span class="comment">// 把key的值放到a[n-1]中，此时a = &#123;4, 2, 3, 5, 9, 7&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = key;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// while 循环比起代码一，少了i&lt;n这个比较操作</span></span><br><span class="line">  <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复a[n-1]原来的值,此时a= &#123;4, 2, 3, 5, 9, 6&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = tmp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (i == n<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，返回i，就是等于key值的元素的下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p>
<p><strong>重点留意边界条件处理</strong></p>
<ul>
<li><p>如果链表为空时，代码是否能正常工作？</p>
</li>
<li><p>如果链表只包含一个结点时，代码是否能正常工作？</p>
</li>
<li><p>如果链表只包含两个结点时，代码是否能正常工作？</p>
</li>
<li><p>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</p>
</li>
</ul>
<p><strong>举例画图，辅助思考</strong></p>
<p>找个具体例子，释放脑容量，进行更多的逻辑思考，有助于思路清晰。比如往单链表中插入一个数据，如图所示：</p>
<img data-src="https://i.loli.net/2021/08/17/u1SUf6shp8JoF3O.jpg" style="zoom:50%;" />

<p><strong>多写多练，没有捷径</strong></p>
<p>5个常见的链表操作：</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测 </li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第 n 个结点</li>
<li>求链表的中间结点</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归树</title>
    <url>/archives/66071d43.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/17/6jh1Rva2smYKbrw.jpg" style="zoom:50%;" />

<p>我们可以借助借助递归树来分析递归算法的时间复杂度</p>
<span id="more"></span>

<h3 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h3><p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p>
<p>如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作递归树。下图是斐波那契数列的递归树，结点数字表示数据规模，一个节点的求解可以分解为左右子节点两个问题的求解。</p>
<img data-src="https://i.loli.net/2021/08/17/YoIO3L29iPKdxwF.jpg" style="zoom:50%;" />

<p>我们借助归并排序来看看如何用递归树来分析递归代码的时间复杂度。</p>
<img data-src="https://i.loli.net/2021/08/17/MhHqG5vgtmOJE1n.jpg" style="zoom:50%;" />

<p>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。</p>
<p>现在，我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 $O(n∗h)$。从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。</p>
<p>满二叉树的高度大约是 $log_2n$，所以，归并排序递归实现的时间复杂度就是 $O(nlogn)$。我这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。</p>
<h3 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h3><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 $T(n)=2T(2n)+n$​，很容易就能推导出时间复杂度是 $O(nlogn)$。但是，我们并不可能每次分区都这么幸运，正好一分为二。</p>
<p>我们假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 $T(n)=T(10n)+T(109n)+n$。</p>
<p>我们还是取 k 等于 9，也就是说，每次分区都很不平均，一个分区是另一个分区的 9 倍。如果我们把递归分解的过程画成递归树:</p>
<img data-src="https://i.loli.net/2021/08/17/4iToLW3h2HlRtXy.jpg" style="zoom:50%;" />

<p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 $h$，这个快排过程遍历的数据个数就是 $h∗n$ ，也就是说，时间复杂度就是 $O(h∗n)$。因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？</p>
<p>我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 $\frac{1}{10}$​​，最长的一个路径每次都乘以$\frac{9}{10}$​​。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 $log_{10}n$​​，最长的路径是 $log_{\frac{10}{9}}n$​​。</p>
<img data-src="https://i.loli.net/2021/08/17/WqNR1oJbO4euB2X.jpg" style="zoom:50%;" />

<p>所以，遍历数据的个数总和就介于 $log_{10}n$​ 和 $log_{\frac{10}{9}}n$​ 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 $logn$​，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 $O(nlogn)$​。</p>
<p>依次类推，k=99 甚至更大时，时间复杂度仍是$O(nlogn)$</p>
<h3 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面代码画成递归树：</p>
<img data-src="https://i.loli.net/2021/08/17/jvwqh5yZo4GJ6rV.jpg" style="zoom:50%;" />

<p>f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 $\frac n2$。</p>
<p>每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 $2^2$。依次类推，第 k 层的时间消耗就是 $2^{k−1}$，​那整个算法的总的时间消耗就是每一层时间消耗之和。</p>
<p>如果路径长度都为 n，那这个总和就是 $2^n−1$。</p>
<img data-src="https://i.loli.net/2021/08/17/OTFrIJL4jR1yQnD.jpg" style="zoom:50%;" />

<p>如果路径长度都是 $\frac n2$ ，那整个算法的总的时间消耗就是 $2^{\frac n2}−1$​。</p>
<img data-src="https://i.loli.net/2021/08/16/XO7VnQdpHcPZeK2.jpg" style="zoom:50%;" />

<p>所以，这个算法的时间复杂度就介于 O($2^n$​​) 和 O($2^{\frac n2}$​​) 之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。</p>
<h3 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h3><p>在高中的时候都学过排列组合。“如何把 n 个数据的所有排列都找出来”，这就是全排列的问题。</p>
<p>如果我们确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。</p>
<p>如果我们把它写成递推公式，就是下面这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设数组中存储的是<span class="number">1</span>，<span class="number">2</span>， <span class="number">3.</span>..n。</span><br><span class="line">        </span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,...n) = &#123;最后一位是<span class="number">1</span>, f(n-<span class="number">1</span>)&#125; + &#123;最后一位是<span class="number">2</span>, f(n-<span class="number">1</span>)&#125; +...+&#123;最后一位是n, f(n-<span class="number">1</span>)&#125;。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用方式：</span></span><br><span class="line"><span class="comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span></span><br><span class="line"><span class="comment">// k表示要处理的子数组的数据个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPermutations</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      System.out.print(data[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = data[i];</span><br><span class="line">    data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">    data[k-<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    printPermutations(data, n, k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    tmp = data[i];</span><br><span class="line">    data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">    data[k-<span class="number">1</span>] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们来看下，如何借助递归树，轻松分析出这个代码的时间复杂度。不过，这个递归树已经不是标准的二叉树了。</p>
<img data-src="https://i.loli.net/2021/08/17/f42UkMeC6EIc3lQ.jpg" style="zoom:50%;" />

<p>第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 $n∗(n−1)$。第三层有 $n∗(n−1)$ 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 $n∗(n−1)∗(n−2)$。</p>
<p>以此类推，第 k 层总的交换次数就是 $n∗(n−1)∗(n−2)∗…∗(n−k+1)$。最后一层的交换次数就是 $n∗(n−1)∗(n−2)∗…∗2∗1$。每一层的交换次数之和就是总的交换次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n + n*(n-<span class="number">1</span>) + n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>) +... + n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>)*...*<span class="number">2</span>*<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个公式的求和比较复杂，我们看最后一个数，$n∗(n−1)∗(n−2)∗…∗2∗1$ 等于 $n!$，而前面的 $n−1$ 个数都小于最后一个数，所以，总和肯定小于 $n∗n!$，也就是说，全排列的递归算法的时间复杂度大于 $O(n!)$，小于 $O(n∗n!)$，虽然我们没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。</p>
<p>假设细胞是先分裂再死亡，三个小时后开始死亡的细胞个数，也就是存活了三个小时的细胞，即四个小时前的细胞个数。由此得到递推公式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(0) &#x3D; 1;</span><br><span class="line">f(1) &#x3D; 2;</span><br><span class="line">f(2) &#x3D; 4;</span><br><span class="line">f(4) &#x3D; 7;</span><br><span class="line">f(n) &#x3D; 2*f(n-1) - f(n-4);</span><br></pre></td></tr></table></figure>

<p>和斐波那契数列类似，复杂度介于 O($2^n$​) 和 O($2^{\frac n4}$​​) 之间，也是指数级</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/archives/b6c47025.html</url>
    <content><![CDATA[<img data-src="https://i.loli.net/2021/08/03/jAIGtd1VcyDXRLP.jpg" style="zoom:50%;" />

<p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p>
<span id="more"></span>

<h3 id="如何理解队列？"><a href="#如何理解队列？" class="headerlink" title="如何理解队列？"></a>如何理解队列？</h3><p><strong>先进先出者，就是典型的“队列”</strong></p>
<p>队列和栈十分相似，基本操作也是两个：**入队 enqueue()<strong>，放一个数据到队列尾部；</strong>出队 dequeue()**，从队列头部取一个元素</p>
<img data-src="https://i.loli.net/2021/08/17/J7Z5h34Yt8W2MXw.jpg" style="zoom:50%;" />

<p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p>
<p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p>
<h3 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h3><p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
<p>对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p>
<p>你可以结合下面这张图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p>
<img data-src="https://i.loli.net/2021/08/17/xmNQEBogrnG64hX.jpg" style="zoom:50%;" />

<p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p>
<img data-src="https://i.loli.net/2021/08/17/TEbdjKAhzRM2otr.jpg" style="zoom:50%;" />

<p>当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p>
<img data-src="https://i.loli.net/2021/08/03/wB1kazey4TXJsli.jpg" style="zoom:50%;" />

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面用数组实现队列时，当 tail == n，会有数据搬移操作，循环队列就能解决这个问题</p>
<img data-src="https://i.loli.net/2021/08/03/ulLfAPcW8H29kDx.jpg" style="zoom:50%;" />

<p>要想写出没有 bug 的循环队列的实现代码，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p>
<p>队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。</p>
<img data-src="https://i.loli.net/2021/08/17/iUzB8e5HanR6xpD.jpg" style="zoom:50%;" />

<p>就像图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。</p>
<h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<img data-src="https://i.loli.net/2021/08/17/YNc2VTa4zRjBI7e.jpg" style="zoom:50%;" />

<p>上述的定义其实就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p>
<p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p>
<p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p>
<img data-src="https://i.loli.net/2021/08/17/6rcIPkt9WKdDO1F.jpg" style="zoom:50%;" />

<p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
