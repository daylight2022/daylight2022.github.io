<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyacinthの博客</title>
  
  <subtitle>记录点滴日常</subtitle>
  <link href="https://hyacinth.fit/atom.xml" rel="self"/>
  
  <link href="https://hyacinth.fit/"/>
  <updated>2022-02-21T15:42:56.529Z</updated>
  <id>https://hyacinth.fit/</id>
  
  <author>
    <name>Hyacinth</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>爬虫笔记四 -- 数据的存储</title>
    <link href="https://hyacinth.fit/archives/39ed07bf.html"/>
    <id>https://hyacinth.fit/archives/39ed07bf.html</id>
    <published>2022-02-20T07:23:08.000Z</published>
    <updated>2022-02-21T15:42:56.529Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" /><p>解析库解析出数据后，可以将数据保存文本文件，如 TXT、JSON、CSV 等，也可以将数据保存到数据库 MySQL，非关系型数据库 MongoDB、Redis 等，另外，还可以直接把数据存储到搜索引擎（如 Elasticsearch）中，以便检索和查看。</p><span id="more"></span><h3 id="TXT-文本文件存储"><a href="#TXT-文本文件存储" class="headerlink" title="TXT  文本文件存储"></a>TXT  文本文件存储</h3><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"><span class="comment">#简化写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>文件打开方式包括：</p><ul><li>r：以只读方式打开，默认；</li><li>rb：以二进制只读方式打开，通常用于音频、图片、视频等二进制文件；</li><li>r+：以读写方式打开；</li><li>rb+：以二进制读写方式打开；</li><li>w：以写入方式打开，如存在则覆盖，不存在则新建；</li><li>wb：以二进制写入方式打开，如存在则覆盖，不存在则新建；</li><li>w+：以读写方式打开，如存在则覆盖，不存在则新建；</li><li>wb+：以二进制读写方式打开，如存在则覆盖，不存在则新建；</li><li>a：以追加方式打开，如存在则追加到已有内容后，不存在则新建；</li><li>ab：以二进制追加方式打开，如存在则追加到已有内容后，不存在则新建；</li><li>a+：以读写方式打开，如存在则追加到已有内容后，不存在则新建；</li><li>ab+：以二进制追加方式，如存在则追加到已有内容后，不存在则新建；</li></ul><h3 id="JSON-文件存储"><a href="#JSON-文件存储" class="headerlink" title="JSON 文件存储"></a>JSON 文件存储</h3><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 JSON，JSON 字符串中必须使用双引号，不然会报错</span></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Bob&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;: &quot;male&quot;</span></span><br><span class="line"><span class="string">&#125;, &#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Selina&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;: &quot;female&quot;</span></span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">data = json.loads(text) </span><br><span class="line">print(data1)</span><br><span class="line">print(<span class="built_in">type</span>(data2))</span><br><span class="line"><span class="comment"># load 方法传入文件对象，使用 open 方法读取；loads 传入 JSON 字符串，使用更灵活</span></span><br><span class="line">data2 = json.load(<span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">[&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Selina&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;]</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 输出 <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">with</span> <span class="title">open</span>(<span class="params"><span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span></span>) <span class="title">as</span> <span class="title">file</span>:</span></span><br><span class="line">    <span class="comment"># 使用 intend 参数可保存为 JSON 对象缩进格式，表示缩进字符个数</span></span><br><span class="line">    <span class="comment"># 默认输出 Unicode 字符，使用 ensure_ascii=False 可输出中文</span></span><br><span class="line">    file.write(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="CSV-文件存储"><a href="#CSV-文件存储" class="headerlink" title="CSV 文件存储"></a>CSV 文件存储</h3><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file: <span class="comment"># 可加 encodeing 指定编码格式</span></span><br><span class="line">    writer = csv.writer(file) <span class="comment"># 可加 delimiter=&#x27; &#x27; 参数，自定义输入内容分隔符</span></span><br><span class="line">    writer.writerow([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;20&#x27;</span>])</span><br><span class="line">    writer.writerows([[<span class="string">&#x27;10002&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], [<span class="string">&#x27;10003&#x27;</span>, <span class="string">&#x27;Jodan&#x27;</span>, <span class="string">&#x27;21&#x27;</span>]])</span><br><span class="line">    </span><br><span class="line">------------- result -------------</span><br><span class="line">data.csv:</span><br><span class="line"><span class="built_in">id</span>,name,age</span><br><span class="line"><span class="number">10001</span>,Mike,<span class="number">20</span></span><br><span class="line"><span class="number">10002</span>,Bob,<span class="number">21</span></span><br><span class="line"><span class="number">10003</span>,Jodan,<span class="number">21</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment"># 字典写入方式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    fieldnames = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    writer = csv.DictWriter(file, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;20&#x27;</span>&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><h3 id="MySQL-存储"><a href="#MySQL-存储" class="headerlink" title="MySQL 存储"></a>MySQL 存储</h3><p>关系型数据库是基于关系的数据库，而关系模型是基于二维表来保存的，所以关系型数据库中数据的存储方式就是行列组成的表，每一列代表一个字段、每一行代表一条记录。表可以看做实体的集合，实体之间存在的联系需要通过表与表之间的关联关系体现，例如主键和外键的关联关联。由多个表组成的数据库，就是关系型数据库。</p><p>关系型数据库有很多，如 SQLite、MySQL、Oracle、SQL Server、DB2 等，本节主要了解 MySQL 数据库的存储操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可同时指定数据库和编码方式，参数为 db, charset</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT VERSION()&#x27;</span>)</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&#x27;Database version: &#x27;</span>, data)</span><br><span class="line"><span class="comment"># 数据库和数据表都可以手动新建</span></span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8mb4&quot;</span>)</span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY(id))&quot;</span>)</span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="built_in">id</span> = <span class="string">&#x27;20220220&#x27;</span></span><br><span class="line">user = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO students(id, name, age) values(%s, %s, %s)&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (<span class="built_in">id</span>, user, age))</span><br><span class="line">    <span class="comment"># 数据增删改都需要 commit 操作</span></span><br><span class="line">    db.commit()</span><br><span class="line">    print(<span class="string">&#x27;Data inserted successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 执行失败则执行数据回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line">    print(e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p><strong>事务</strong>机制能够保证数据的完整性，例如插入一条数据，要么全部插入，要么都不插入，这就是事务的原子性，其他还有三个属性——一致性、隔离性和持久性，这四个属性通常称为 ACID 特性：</p><ul><li>原子性（atomicity）：事务是一个不可分割的工作单位，事务中包括的操作要么都做、要么都不做。</li><li>一致性（consistency）：事务必须从一个一致性状态变到另一个一致性状态。一致性和原子性是密切相关的。</li><li>隔离性（isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（durability）：也成永久性（permanence），指一个事务一旦提交，它对数据库中数据做的改变就该是永久性的。接下来的操作或故障不应该对数据有任何影响。</li></ul><p>上面的插入操作有一个弊端，如果需要增加字段，就需要该 SQL 语句，很不方便，我们可以将其改为一个通过方法，只需传入一个动态变化的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220220&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;:Bob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">keys = <span class="string">&#x27;, &#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES(&#123;values&#125;)&#x27;</span>.<span class="built_in">format</span>(table=table, keys=keys, values=values)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql, <span class="built_in">tuple</span>(data.values())):</span><br><span class="line">        print(<span class="string">&#x27;Successful&#x27;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line">    print(e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">    db.rollback()</span><br></pre></td></tr></table></figure><p>更新和删除操作类似，这里还需要说明下查询过程常用的几个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(sql)</span><br><span class="line">print(<span class="string">&#x27;Count: &#x27;</span>, cursor.rowcount) <span class="comment"># 获取查询结果条数</span></span><br><span class="line">result = cursor.fetchone() <span class="comment"># 获取第一条查询结果</span></span><br><span class="line">result = cursor.fetchall() <span class="comment"># 获取所有数据</span></span><br><span class="line"><span class="comment"># 如果数据较多，使用 fetchall() 占用开销较大，推荐下面方法</span></span><br><span class="line">row = cursor.fetchone()</span><br><span class="line"><span class="keyword">while</span> row:</span><br><span class="line">    print(<span class="string">&#x27;Row: &#x27;</span>, row)</span><br><span class="line">    row = cursor.fetchone()</span><br></pre></td></tr></table></figure><h3 id="MongoDB-文档存储"><a href="#MongoDB-文档存储" class="headerlink" title="MongoDB 文档存储"></a>MongoDB 文档存储</h3><p>NoSQL(Not Only SQL)，意为不仅仅是 SQL，泛指非关系型数据库。NoSQL 是基于键值对的，不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</p><p>非关系型数据库可细分为：</p><ul><li>键值存储数据库：Redis、Voldemort 和 Oracle BDD 等；</li><li>列存储数据库：Cassandra、HBase 和 Riak 等；</li><li>文档型数据库：CouchDB 和 MongoDB 等；</li><li>图形数据库：Neo4J、InfoGrid 和 Infinite Graph 等。</li></ul><p>对爬虫的数据存储来说，非关系型数据库往往更简单高效。</p><p>MongoDB 是用 C++ 编写的，内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># client = pymongo.MongoClient(&#x27;mongodb://localhost:27017/&#x27;)</span></span><br><span class="line">db = client.test  <span class="comment"># 或 client[&#x27;test&#x27;]</span></span><br><span class="line">collection = db.students  <span class="comment"># db[&#x27;students&#x27;]</span></span><br><span class="line">student = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220220&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jordan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert_one(student)</span><br><span class="line">result1 = collection.insert_many([student1, student2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;pymongo.results.InsertOneResult <span class="built_in">object</span> at <span class="number">0x000001F46043BE80</span>&gt;</span><br><span class="line">62123cdad1351490060fecf3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">result2 = collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>&#125;)</span><br><span class="line">result3 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">20</span>&#125;&#125;)  <span class="comment"># 查找所有数据，结果为生成器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查询条件中的比较符号一览：</span></span><br><span class="line"><span class="string">$lt, $gt, $lte, $gte, $ne, $in, $nin </span></span><br><span class="line"><span class="string">小于，大于，小于等于，大于等于，不等于，在范围内，不在范围内</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">功能符号一览：</span></span><br><span class="line"><span class="string">$regex</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数</span></span><br><span class="line">count = collection.find().count()  </span><br><span class="line"><span class="comment"># 排序，偏移，指定获取个数 -&gt; sort result: [&#x27;Harden&#x27;, &#x27;Jordan&#x27;, &#x27;Kevin&#x27;, &#x27;Mark&#x27;, &#x27;Mike&#x27;]</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line">-&gt; [&#x27;Kevin&#x27;, &#x27;Mark&#x27;]</span><br><span class="line"><span class="comment"># 数据量非常庞大时（千万、亿级别），最好不要用大偏移，可能导致内存溢出，可使用如下操作来查询</span></span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line">collection.find(&#123;<span class="string">&#x27;_id&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: ObjectId(<span class="string">&#x27;62123cdad1351490060fecf3&#x27;</span>)&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: student&#125;)  <span class="comment">## update_many()</span></span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)  <span class="comment"># 匹配数据条数和影响的数据条数</span></span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;pymongo.results.UpdateResult <span class="built_in">object</span> at <span class="number">0x10d17b678</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">result = collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Kevin&#x27;</span>&#125;)  <span class="comment">## delete_many()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">PyMongo 还提供了一些组合方法，如 </span></span><br><span class="line"><span class="string">find_one_and_delete, find_one_and_replace, find_one_and_update 等</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>还有一些功能符号</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">实例</th><th align="center">实例含义</th></tr></thead><tbody><tr><td align="center">$regex</td><td align="center">正则匹配</td><td align="center">{‘name’, {‘$regex’: ‘^M.*’}}</td><td align="center">name 以 M 开头</td></tr><tr><td align="center">$exists</td><td align="center">属性是否存在</td><td align="center">{‘name’, {‘$exists’: True}}</td><td align="center">存在 name 属性</td></tr><tr><td align="center">$type</td><td align="center">类型判断</td><td align="center">{‘age’, {‘$type’: ‘int’}}</td><td align="center">age 类型为 int</td></tr><tr><td align="center">$mod</td><td align="center">数字模操作</td><td align="center">{‘age’, {‘$mod’: [5, 0]}}</td><td align="center">age 模 5 余 0</td></tr><tr><td align="center">$text</td><td align="center">文本查询</td><td align="center">{‘$text’: {‘$search’: ‘Mike’}}</td><td align="center">text 类型属性中包含 Mike</td></tr><tr><td align="center">$where</td><td align="center">高级条件查询</td><td align="center">{‘$where’: ‘obj.fans_count == obj.follows_count’}</td><td align="center">自身粉丝数等于关注数</td></tr></tbody></table><h3 id="Redis-缓存存储"><a href="#Redis-缓存存储" class="headerlink" title="Redis 缓存存储"></a>Redis 缓存存储</h3><p>Redis 是一个基于内存的、高效的键值型非关系型数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">- 也可以这样连接</span></span><br><span class="line"><span class="string">pool = ConnectionPool(host=&#x27;localhost&#x27;, port=6379, db=0, password=&#x27;test&#x27;)</span></span><br><span class="line"><span class="string">redis = StrictRedis(connection_pool=pool)</span></span><br><span class="line"><span class="string">- ConnectionPool 支持 URL 连接</span></span><br><span class="line"><span class="string">url = &#x27;redis://:test@localhost:679/0&#x27;</span></span><br><span class="line"><span class="string">pool = ConnectionPool.from.url(url)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">print(redis.get(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>Redis 支持多种数据存储结构，并提供了丰富的 API，包括键操作、字符串操作、列表操作、集合操作、有序集合操作、散列操作。具体可以查看 <a href="https://redis.com.cn/commands.html">Redis 命令手册</a></p><h3 id="Elasticsearch-搜索引擎存储"><a href="#Elasticsearch-搜索引擎存储" class="headerlink" title="Elasticsearch 搜索引擎存储"></a>Elasticsearch 搜索引擎存储</h3><p>如果为了便于存储和检索，想要实现自己的搜索引擎，Elasticsearch 就是不二之选。这是一个全文搜索引擎，可以快速存储、检索和分析海量数据。</p><p>Elasticsearch是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 的基础之上。</p><p>Lucene 是目前拥有最先进、高性能的全功能搜索引擎功能的库，Elasticsearch 对 Lucene 做了一层封装，提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索，可以如此形容：</p><ul><li>一个分布式的实时文档存储库，每个字段都可以被索引与搜索；</li><li>一个分布式的实时分布搜索引擎；</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li></ul><p><a href="https://blog.csdn.net/winnershili/article/details/122944188">安装方法</a>， Kibana 支持对 Elasticsearch 数据进行可视化和分析，配合使用更佳。</p><p>有几个概念需要明确：</p><ul><li>节点和集群：单个 Elasticsearch 实例称为一个节点（Node），一组节点构成一个集群（Cluster）；</li><li>索引：即 index，Elasticsearch 会索引所有字段，经过处理后写入一个反向索引（inverted index）。Elasticsearch 数据管理的顶层单位就是索引，相当于数据库的概念，另外，索引名字必须小写；</li><li>文档：索引里的单条记录称为文档（document），同一个索引中的文档不要求有相同的结构（scheme），但最好保持一致，有助提高搜索效率；</li><li>类型：文档可以分组，叫做类型（Type），类似 MySQL 中的数据表、MongoDB 中的集合。不同类型的文档应该具有相似的结构，即应该把不同性质的数据存成两个索引。Elasticsearch 6.x 每个索引只能包含一个类型，而到 7.x 会移除类型；</li><li>字段：每个文档类似 JSON 结构，包含许多字段，每个字段有其对应的值，类比为 MySQL 数据表中字段。</li></ul><p>用对比图来直观类比 Elasticsearch 和传统关系型数据库：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reletional DB -&gt; Database -&gt; Tables -&gt; Rows      -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices  -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure><p>Elasticsearch 的特殊强大之处就在检索功能</p><ul><li>Elasticsearch 对模糊搜索非常擅长（搜索速度很快）</li><li>从 Elasticsearch 搜索到的数据可以根据<strong>评分</strong>过滤，如只返回评分高的给用户</li><li>没有那么准确的关键字也能搜出相关的结果（能匹配有相关性的记录）</li></ul><p><a href="https://elasticsearch-py.readthedocs.io/en/master/">使用手册</a>，<a href="https://cloud.tencent.com/developer/article/1583402">什么是 Elasticsearch？一篇搞懂</a></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>为了降低进程间的耦合度，需要一个类似消息队列的中间件来存储和转发消息，实现进程间通信。</p><p>RabbitMQ 是一款使用 Erlang 语言开发的，实现 AMQP(高级消息队列协议)的开源消息中间件，其主要特点有面向消息、队列、路由(包括点对点和发布/订阅)，可靠性、安全性。具体特点有以下这些：</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是 RabbitMQ 的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台 RabbitMQ 服务器可以组成一个集群，形成一个逻辑Broker。</li><li>高可用：消息队列在部分节点出问题的情况下仍然可用。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ 几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ 提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><p>使用上主要三个步骤，声明队列，生产内容和消费内容。</p><p><code>producer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME, body=<span class="string">&#x27;Hel World!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>consumer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;Get <span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># auto_ack=True 表示获取消息后会通知消息队列当前消息已处理</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;scrape&#x27;</span>, auto_ack=<span class="literal">True</span>, on_message_callback=callback)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>运行 <code>producer.py</code>后会往消息队列放入一个消息，<code>consumer.py</code>运行后会一直监听，可以发现输出结果为<code>Get b&#39;Hello World!&#39;</code></p><p>上面的例子实现的是最简单的生产者和消费者间通信，但这在实际爬虫中是不太现实的，因为把消费者实现为了“订阅”模式，会一直处于监听状态，一旦有消息就要立马处理，无法主动控制取用消息的时机。下面我们实现一种随取随用的例子，里面还用到了优先级队列和队列持久化技术：</p><p><code>producer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 input() 来获取生产者数据，输入字符串和优先级，输入后会被放入消息队列中</span></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, priority = <span class="built_in">input</span>().split()</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME, properties=pika.BasicProperties(priority=<span class="built_in">int</span>(priority)),</span><br><span class="line">                          body=data)</span><br><span class="line">    print(<span class="string">f&#x27;Put <span class="subst">&#123;data&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">foo <span class="number">40</span></span><br><span class="line">Put foo</span><br><span class="line">bar <span class="number">20</span></span><br><span class="line">Put bar</span><br><span class="line">baz <span class="number">50</span></span><br><span class="line">Put baz</span><br></pre></td></tr></table></figure><p><code>consumer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 input() 来控制消费者何时获取下一个数据，同时按照优先级取出对应消息</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    method_frame, header, body = channel.basic_get(queue=<span class="string">&#x27;scrape&#x27;</span>, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        print(<span class="string">f&#x27;Get <span class="subst">&#123;body&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure><p>实战，爬取电源网站链接</p><p><code>producer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle  <span class="comment"># 序列化</span></span><br><span class="line"></span><br><span class="line">TOTAL = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape_queue&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL + <span class="number">1</span>):</span><br><span class="line">    url = <span class="string">f&#x27;https://ssr1.scrape.center/detail/<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">    request = requests.Request(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME,</span><br><span class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>),</span><br><span class="line">                          body=pickle.dumps(request))</span><br><span class="line">    print(<span class="string">f&#x27;Put request of <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/21/M1kRlrJvc3uUDgE.png"></p><p><code>consumer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape_queue&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = session.send(request.prepare())</span><br><span class="line">        print(<span class="string">f&#x27;success scraped <span class="subst">&#123;response.url&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        print(<span class="string">f&#x27;error occurred when scraping <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    method_frame, header, body = channel.basic_get(queue=QUEUE_NAME, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        request = pickle.loads(body)</span><br><span class="line">        print(<span class="string">f&#x27;Get <span class="subst">&#123;request&#125;</span>&#x27;</span>)</span><br><span class="line">        scrape(request)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/21/qv4mLSx3awF8i79.png"></p><p>可以看到，消费者依次取出请求对象完成了一个个爬取任务。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;解析库解析出数据后，可以将数据保存文本文件，如 TXT、JSON、CSV 等，也可以将数据保存到数据库 MySQL，非关系型数据库 MongoDB、Redis 等，另外，还可以直接把数据存储到搜索引擎（如 Elasticsearch）中，以便检索和查看。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://hyacinth.fit/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记三 -- 解析库的使用</title>
    <link href="https://hyacinth.fit/archives/79659fc4.html"/>
    <id>https://hyacinth.fit/archives/79659fc4.html</id>
    <published>2022-02-19T02:36:20.000Z</published>
    <updated>2022-02-20T12:27:43.635Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" /><p>本章我们了解几种解析库的使用，包括 XPath、Beautiful Soup、PyQuery、Parsel，实际可根据场景和个人使用习惯来选择。</p><span id="more"></span><h3 id="XPath-的使用"><a href="#XPath-的使用" class="headerlink" title="XPath 的使用"></a>XPath 的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">html = etree.html(text)</span><br><span class="line"><span class="comment"># html = etree.parse(&#x27;./test.html&#x27;, etree.HTMLParser())</span></span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>全称是 XML Path Language，etree 模块可以自动修正 HTML 文本。其常用规则如下表：</p><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">nodename</td><td align="center">选取此节点的所有子节点</td></tr><tr><td align="center">/</td><td align="center">从当前节点选取直接子节点</td></tr><tr><td align="center">//</td><td align="center">从当前节点选取子孙节点</td></tr><tr><td align="center">.</td><td align="center">选取当前节点</td></tr><tr><td align="center">..  or parent::</td><td align="center">选取当前节点的父节点</td></tr><tr><td align="center">@</td><td align="center">选取属性</td></tr><tr><td align="center">text()</td><td align="center">文本获取</td></tr><tr><td align="center">contains()</td><td align="center">属性多值匹配，包含属性值即可匹配</td></tr><tr><td align="center">last()</td><td align="center">最后一个</td></tr><tr><td align="center">position()</td><td align="center">用于索引位置判断</td></tr><tr><td align="center">节点轴</td><td align="center">ancestor::, attribute::, child::, descendant::, following::, following-sibling::</td></tr></tbody></table><p>运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">or</td><td align="center">或</td><td align="center">age=19 or age=20</td><td align="center">ture or false</td></tr><tr><td align="center">and</td><td align="center">与</td><td align="center">age&gt;19 and age&lt;21</td><td align="center">ture or false</td></tr><tr><td align="center">mod</td><td align="center">计算除法余数</td><td align="center">5 mod 2</td><td align="center">1</td></tr><tr><td align="center">|</td><td align="center">计算两个节点集</td><td align="center">//book|//cd</td><td align="center">返回所有拥有 book 和 cd 元素的节点集</td></tr><tr><td align="center">+, -, *, div</td><td align="center">加减乘除</td><td align="center">—</td><td align="center">ture or false</td></tr><tr><td align="center">=, !=, &lt;, &lt;=, &gt;, &gt;=</td><td align="center">等于。。。</td><td align="center">—</td><td align="center">ture or false</td></tr></tbody></table><h3 id="Beautiful-Soup-的使用"><a href="#Beautiful-Soup-的使用" class="headerlink" title="Beautiful Soup 的使用"></a>Beautiful Soup 的使用</h3><p>借助网页结构和属性等特性来解析的一个库，它可以自动将输入文档转换为 Unicode 编码，将输出文档转换为 utf-8 编码，还有很多强大的功能，帮助使用者省去许多烦琐工作，提高解析效率。</p><p>Beautiful Soup 解析是依赖解释器的，除了支持 Python 标注库中的 HTML 解释器，还支持其他第三方解释器，如 LXML HTML、LXML XML、html5lib，推荐使用 lxml，初始化的时候这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>可以直接调用节点，调用后包含的常用属性和方法有：</p><ul><li>name: 节点名称</li><li>attrs: 属性内容</li><li>string: 文本内容</li><li>content: 直接子节点</li><li>children: 直接子节点，生成器类型</li><li>descendants: 子孙节点，生成器类型</li><li>parent: 直接父节点；复数取得所有祖先节点，生成器</li><li>previous_sibling: 上一个兄弟节点；复数取得前面所有兄弟节点，生成器</li><li>next_sibling: 下一个兄弟节点；复数取得后面所有兄弟节点，生成器</li></ul><p>Beautiful Soup 还提供许多查询方法：</p><ul><li>find_all(name, attrs, recursive, text, **kwargs) 所有元素，其中 attr 常用属性 id, text, class(关键词，需改为 class_) 可直接使用，如 <code>find_all(id=‘list-1’)</code></li><li>find() 第一个匹配元素</li><li>find_parent() 直接父节点，复数所有祖先节点</li><li>find_next_sibling(), find_previous_sibling()</li><li>find_all_next(), find_next(), find_all_previouf(), find_previous()</li><li>select()：CSS 选择器</li><li>get_text() 同 string 属性</li></ul><h3 id="PyQuery-的使用"><a href="#PyQuery-的使用" class="headerlink" title="PyQuery 的使用"></a>PyQuery 的使用</h3><p>更强大的 CSS 选择器功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">doc = pq(html)</span><br><span class="line"><span class="comment"># doc = pq(url=&#x27;example.com&#x27;)</span></span><br><span class="line"><span class="comment"># doc = pq(filename=&#x27;demo.html&#x27;)</span></span><br><span class="line">print(doc(<span class="string">&#x27;li&#x27;</span>))</span><br><span class="line">print(doc(<span class="string">&#x27;#container .list li&#x27;</span>))</span><br></pre></td></tr></table></figure><p>需要的参数是 CSS 选择器，常用方法和属性有：</p><ul><li>find() 返回所有子孙节点</li><li>children() 只返回子节点</li><li>parent() 直接父节点，复数是查找祖先节点</li><li>siblings() 兄弟节点</li><li>attr 调用方式可以是 a.attr(‘href’), a.attr.href，如果 a 是多个节点，只会返回第一个节点属性</li><li>text() html() 获取文本和 html 文本</li></ul><p>pyquery 提供了系列方法对节点进行动态修改：</p><ul><li>addClass()  -&gt; li.addClass(‘active’)</li><li>removeClass() -&gt; li.removeClass(‘active’)</li><li>attr() -&gt; li.attr(‘name’, ‘link’)</li><li>text() -&gt; li.text(‘changed item’)</li><li>html() -&gt; li.html(‘&lt;span&gt;changed item&lt;/span&gt;’)</li><li>remove() -&gt; li.find(‘p’).remove()</li></ul><p>CSS 选择器的强大之处还在于支持伪类选择器，下面依次选择了第一个 li 节点、最后一个 li 节点、第二个 li 节点、第三个 li 之后的节点、偶数位置 li 节点、包含 second 文本的 li 节点：</p><ul><li>doc(‘li:first-child’)</li><li>doc(‘li:last-child’)</li><li>doc(‘li:nth-child(2)’)</li><li>doc(‘li.gt(2)’)</li><li>doc(‘li:nth-child(2n’)</li><li>doc(‘li:contains(second)’)</li></ul><h3 id="Parsel-的使用"><a href="#Parsel-的使用" class="headerlink" title="Parsel 的使用"></a>Parsel 的使用</h3><p>这个库可以解析 HTML 和 XML，支持使用 XPath 和 CSS 选择器对内容进行提取和修改，还融合了正则表达式的提取功能，同时也是 Python 最流行的爬虫框架 Scrapy 的底层支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">items = selector.css(<span class="string">&#x27;.item-0&#x27;</span>)</span><br><span class="line">items2 = selector.xpath(<span class="string">&#x27;//li[contains(@class, &quot;item-0&quot;)]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取文本</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">text = item.xpath(<span class="string">&#x27;.//text()&#x27;</span>).get()</span><br><span class="line">print(text)</span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0 *::text&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取属性</span></span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0.active a::attr(href)&#x27;</span>).get()</span><br><span class="line">result2 = selector.xpath(<span class="string">&#x27;//li[contains(@class, &quot;item-0&quot;) and contains(@class, &quot;active&quot;)]/a/@href&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则提取</span></span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0&#x27;</span>).re(<span class="string">&#x27;link.*&#x27;</span>)</span><br><span class="line">result2 = selector.css(<span class="string">&#x27;.item-0&#x27;</span>).re_first(<span class="string">&#x27;&lt;span class=&quot;bold&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;本章我们了解几种解析库的使用，包括 XPath、Beautiful Soup、PyQuery、Parsel，实际可根据场景和个人使用习惯来选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://hyacinth.fit/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记二 -- 基本库的使用</title>
    <link href="https://hyacinth.fit/archives/50c99347.html"/>
    <id>https://hyacinth.fit/archives/50c99347.html</id>
    <published>2022-02-15T01:09:41.000Z</published>
    <updated>2022-02-16T14:33:07.759Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" /><p>本章我们了解基础的 HTTP 库，如 urllib、requests、httpx等，最后一起来完成对一个静态网站的爬取案例实战。</p><span id="more"></span><h3 id="urllib-库的使用"><a href="#urllib-库的使用" class="headerlink" title="urllib 库的使用"></a>urllib 库的使用</h3><p>urllib 库包含 4 个模块：request、error、parse、robotparser，具体用法如下：</p><ol><li><strong>发送请求</strong></li></ol><p>使用 request 库，可以很方便的发起请求并得到响应。</p><ul><li><strong>urlopen</strong></li></ul><p>以爬取 Python 官网为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img data-src="https://s2.loli.net/2022/02/15/JdV92QIylBomrgU.png" alt="image-20220215101452116"></p><p>可看到我们得到了网页的源代码，其中的链接、图片、文本信息就可以提取出来了。</p><p>使用 <code>print(type(response))</code>，输出结果是<code>&lt;class &#39;http.client.HTTPResponse&#39;</code>，响应是一个 HTTPResponse 类型的对象，主要包含 read、readinto、getheader、getheaders、fileno 等方法，以及 msg、version、status、reason、debuglevel、closed 等属性，我们可以调用上述方法和属性，得到返回的一系列信息。</p><p>urlopen最基本用法就是传入 URL 参数，其完整 API 如下：</p><p><code>urllib.request.urlopen(url, data=None, [timeout,]*, cafile=None, capath=None, cadefault=False, context=None)</code></p><p>下面详细说明参数含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data：添加该参数时，需要使用 bytes 方法将其参数转化为字节流编码格式的内容，即 bytes 类型。另外，如果传递了这个参数，，请求方式就变为 POST 了。urllib.parse 模块中 的urlencode(data, encode&#x3D;‘utf-8’)可以转化编码，第二个参数指定编码方式；</span><br><span class="line"></span><br><span class="line">timeout：超时时间，单位秒，超时会抛出 socket.timeout 类型的异常</span><br><span class="line"></span><br><span class="line">其他参数：context 参数必须是 ssl.SSLContext 类型，用来指定 SSL 的设置。cafile 和 capath 用来指定 CA 证书和其路径。cadefault 参数已弃用，默认 False。</span><br></pre></td></tr></table></figure><ul><li><strong>Request</strong></li></ul><p>urlopen 发起的是最基本的请求，如果需要加上 Headers 等信息，就得用到 Request 类来构建请求。构造方法如下：</p><p><code>urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url 和 data 参数解释同 urlopen</span><br><span class="line"></span><br><span class="line">headers：请求头，这也可通过调用请求实例的 add_headers 方法添加。最常见的方法就是通过修改 User-Agent 来伪装浏览器，默认的 UA 是 Python-urllib。如可设置 UA 为 Mozilla&#x2F;5.0 (X11; U; Linux i686) Gecko&#x2F;20071127 FireFox&#x2F;2.0.0.11</span><br><span class="line"></span><br><span class="line">origin_req_host：请求方的 host 名称或 IP 地址</span><br><span class="line"></span><br><span class="line">unverifiable：表示请求是否是无法验证的，默认 False，为 True 则表示用户没有权限来接收这个请求结果</span><br><span class="line"></span><br><span class="line">method：指示请求使用的方法，如 GET、POST 和 PUT 等</span><br><span class="line"></span><br><span class="line">其他参数：context 参数必须是 ssl.SSLContext 类型，用来指定 SSL 的设置。cafile 和 capath 用来指定 CA 证书和其路径。cadefault 参数已弃用，默认 False。</span><br></pre></td></tr></table></figure><p>下面尝试构建请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/post&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.httpbin.org&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">query = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>&#125;</span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(query), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">req = request.Request(url, data, headers, method=<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;form&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;germey&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;identity&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-620b1624-3d236f007cd3de6c15dfe6ba&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;json&quot;</span>: null, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;117.136.71.145&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>高级用法</strong></li></ul><p>为了进行 Cookie 处理、代理设置等操作，就绪也用到 urllib.request 中的 BaseHandler 类，有各种子类继承 BaseHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPDefaultErrorHandler 用于处理响应错误，所有错误会抛出 HTTPError 类型异常</span><br><span class="line">HTTPRedirectHandler 用于处理重定向</span><br><span class="line">HTTPCookieProcessor 用于处理 Cookie</span><br><span class="line">ProxyHandler 用于设置代理，默认为空</span><br><span class="line">HTTPPasswordMgr 用于管理密码</span><br><span class="line">HTTPBasicAuthHandler 用于管理认证</span><br></pre></td></tr></table></figure><ul><li><strong>代理</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason</span><br></pre></td></tr></table></figure><ul><li><strong>Cookie</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;cookie.txt&#x27;</span></span><br><span class="line">cookie = http.cookiejar.CookieJar(filename)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>) <span class="comment"># save as file</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name + <span class="string">&#x27;=&#x27;</span> + item.value)</span><br><span class="line"> </span><br><span class="line">------------- result -------------</span><br><span class="line">BAIDUID=BB78F3CB65EB85782F1ECF6B3C04D0DB:FG=<span class="number">1</span></span><br><span class="line">BIDUPSID=BB78F3CB65EB8578C40219B54CB0A2E7</span><br><span class="line">PSTM=<span class="number">1644894666</span></span><br><span class="line">BD_NOT_HTTPS=<span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>处理异常</strong></li></ol><ul><li><strong>URLError</strong></li></ul><p>来自 urllib库的 error 模块，继承自 OSError 模块，由 request 模块产生的异常都可以用这个类处理。</p><ul><li><strong>HTTPError</strong><ul><li>code：HTTP状态码</li><li>reason：返回错误原因</li><li>headers：返回请求头</li></ul></li></ul><p>URLError 的子类，专门用于处理 HTTP 请求错误，有 3 个属性。</p><ol start="3"><li><strong>解析链接</strong></li></ol><p>本小节介绍 parse 模块的常用方法。</p><ul><li><strong>urlparse</strong></li></ul><p>API <code>urllib.parse.urlparse(urlstring, scheme=&#39;&#39;, allow_fragments=True)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">urlstring：必填项，待解析 URL</span><br><span class="line">scheme：默认协议（如 http、https 等）。如果 urlstring 没有带协议值，则赋该值</span><br><span class="line">allow_fragments：是否忽略 fragment，如果忽略，则会被解析为 path、params 或 query 的一部分</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">&#x27;https://www.baidu.com/index.html;user?a=6#comment&#x27;</span>)</span><br><span class="line">print(<span class="built_in">type</span>(result))</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">urllib</span>.<span class="title">parse</span>.<span class="title">ParseResult</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">ParseResult</span>(<span class="params">scheme=<span class="string">&#x27;https&#x27;</span>, netloc=<span class="string">&#x27;www.baidu.com&#x27;</span>, path=<span class="string">&#x27;/index.html&#x27;</span>, params<span class="string">&#x27;user&#x27;</span>, query=<span class="string">&#x27;id=5&#x27;</span>, fragment=<span class="string">&#x27;comment&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><ul><li><strong>urlunparse</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse</span><br><span class="line"></span><br><span class="line">data = [<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;a=6&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>]</span><br><span class="line">print(urlunparse(data))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/index.html;user?a=6#comment</span><br></pre></td></tr></table></figure><ul><li><strong>urlsplit、urlunsplit</strong></li></ul><p>和 urlparse、urlunparse 很相似，但不在单独解析 params，也不用组合 params内容 。</p><ul><li><strong>urljoin</strong></li></ul><p>API <code>urllib.parse.urljoin(base_url, new_url)</code></p><p>urljoin 会分析 base_url  中的 scheme、netloc 和 path，并对 new_url 缺失的部分进行补充，最后返回结果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">urljoin(<span class="string">&#x27;https://www.baidu.com?wd=abc&#x27;</span>, <span class="string">&#x27;https://example.com/index.php&#x27;</span>)</span><br><span class="line">urljoin(<span class="string">&#x27;https://www.baidu.com&#x27;</span>, <span class="string">&#x27;?category=2#comment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/index.php</span><br><span class="line">https://www.baidu.com?category=2#comment</span><br></pre></td></tr></table></figure><ul><li><strong>urlencode</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">&#x27;https;//www.baidu.com&#x27;</span></span><br><span class="line">url = base_url + urlencode(params)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https;//www.baidu.com?name=germey&amp;age=25</span><br></pre></td></tr></table></figure><ul><li><strong>parse_qs</strong></li></ul><p>反序列化，可将一串 GET 请求参数转化为字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">query = <span class="string">&#x27;name=germey&amp;age=25&#x27;</span></span><br><span class="line">print(parse_qs(query))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;germey&#x27;</span>], <span class="string">&#x27;age&#x27;</span>: [<span class="string">&#x27;25&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>parse_qsl</strong></li></ul><p>与 parse_qs 相似，但运行结果是元组列表，运行结果如下：</p><p><code>&#123;(&#39;name&#39;: &#39;germey&#39;), (&#39;age&#39;: &#39;25&#39;)&#125;</code></p><ul><li><strong>quote</strong></li></ul><p>将内容转化为 URL 编码格式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">keyword = <span class="string">&#x27;壁纸&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?wd=&#x27;</span> + quote(keyword)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</span><br></pre></td></tr></table></figure><ul><li><strong>unquote</strong></li></ul><p>URL 解码，用上面代码运行结果可以解码出中文。</p><ul><li><strong>Robots 协议</strong></li></ul><p>也叫做爬虫协议、机器人协议，全名为网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取、哪些不可以。通常是一个 robots.txt 的文本文件，放在网站根目录下。</p><p>样例，限定搜索爬虫只能爬取 public 目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: * <span class="comment"># 搜索爬虫名称，常见名称见下表</span></span><br><span class="line">Disallow: /</span><br><span class="line">Allow: /public/</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">爬虫名称</th><th align="center">网站名称</th></tr></thead><tbody><tr><td align="center">BaiduSpider</td><td align="center">百度</td></tr><tr><td align="center">Googlebot</td><td align="center">谷歌</td></tr><tr><td align="center">360Spider</td><td align="center">360 搜索</td></tr><tr><td align="center">YodaoBot</td><td align="center">有道</td></tr><tr><td align="center">ia_archiver</td><td align="center">Alexa</td></tr><tr><td align="center">Scooter</td><td align="center">altavista</td></tr><tr><td align="center">Bingbot</td><td align="center">必应</td></tr></tbody></table><p>了解 Robots 协议后，就可以使用 robotparser 模块来解析 robots.txt 文件了，用法：</p><p><code>urllib.robotparse.RobotFileParse(url=&#39;&#39;)</code></p><h3 id="requests-的使用"><a href="#requests-的使用" class="headerlink" title="requests 的使用"></a>requests 的使用</h3><p>requests 库比 urllib 库更强大，在处理网页验证、Cookie 以及实现 POST、PUT 等请求会更方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line">headers = &#123; <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;...&#x27;</span> &#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url, headers=headers, params=data) <span class="comment"># 发起请求，返回结果是 str 类型</span></span><br><span class="line">print(r.json()) <span class="comment"># 如果结果是 JSON 格式，可将结果转化为字典</span></span><br><span class="line">print(r.text()) <span class="comment"># 返回 Unicode 类型数据，即取文本内容</span></span><br><span class="line">print(r.content()) <span class="comment"># 结果转化为 bytes 类型数据 </span></span><br><span class="line">print(r.cookies) <span class="comment"># 获取 Cookie，通过 for key, value in r.cookies.item() 解析</span></span><br><span class="line"><span class="comment"># 登录网站后，将请求头中的 Cookie 内容复制加到爬虫的请求头中，便可获取登录后的信息结果</span></span><br><span class="line">print(r.__dict__) <span class="comment"># 可查看返回结果的所有属性内容</span></span><br><span class="line">print(<span class="built_in">dir</span>(r)) <span class="comment"># 查看所有属性名</span></span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;test.com&#x27;</span>, files=files) <span class="comment"># post 请求</span></span><br></pre></td></tr></table></figure><ul><li><strong>Session 维持</strong></li></ul><p>设想，某次利用 post 请求登录网站后，想再次获取登录后的个人信息，使用 get 方法请求，这样是无法获取到的，这相当于开了两个浏览器。</p><p>下面举例 Session 的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line">s.get(<span class="string">&#x27;https://www.httpbin.org/cookies/set/number/123456&#x27;</span>)</span><br><span class="line">r = s.get(<span class="string">&#x27;https://www.httpbin.org/cookies&#x27;</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123; <span class="string">&quot;cookies&quot;</span>: &#123;<span class="string">&quot;number&quot;</span>: <span class="string">&quot;123456&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>可看到 Cookie 获取成功，利用 Session 可以模拟在同一个浏览器中打开同一站点的不同页面。</p><ul><li><strong>其他参数配置</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify： 设置为 False 可忽略 SSL 证书的验证</span><br><span class="line">timeout：超时设置，可设置为固定值，也可是元组（请求实际可分为连接和读取两个阶段，超时时间可自定）</span><br><span class="line">auth：身份认证，传递元组 (&#39;user&#39;, &#39;password&#39;)</span><br><span class="line">proxies：代理设置，如果代理需要使用身份认证，可使用类似 http:&#x2F;&#x2F;user:password@host:port 语法设置</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>用一定语法规则将特定文本提取出来的方式就是正则表达式匹配，常用匹配规则见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式规则</a>。</p><ul><li><strong>match</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line">print(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.match(<span class="string">&#x27;Hello\s\d\d\d\s(\d&#123;4&#125;)\s\w&#123;10&#125;&#x27;</span>, content)</span><br><span class="line">print(result) <span class="comment"># \s 匹配空白字符，\d 匹配数字，\w 匹配单字字符（字母、数字或者下划线）</span></span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line">print(result.span())</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">25</span>), match=<span class="string">&#x27;Hello 123 4567 World_This&#x27;</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line"><span class="number">4567</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>从字符串开头开始匹配，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。用 () 将想提取的字符串括起来，匹配结果调用 group 方法，传入分组索引即可获取提取结果。另外<code>.*</code>是通用匹配，代码中的表达式也可以变为 <code>^Hello.*Demo$</code>，<code>^ $</code> 表示开始和结束标识。</p><p><strong>贪婪与非贪婪</strong></p><p>来看一种情况，想要获取目标字符串中的数字，用 <code>.*</code> 简化成下面的表达式，运行如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;^Hello.*(\d+).*Demo$&#x27;</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">41</span>), match=<span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>只得到了数字 7，这是因为前面的 <code>.*</code> 会匹配尽可能多的字符，只给 \d+ 剩下一个可满足条件的数字 7，表现出贪婪性，这里我们需要将其变成非贪婪匹配，写法是 <code>.*?</code>，如此运行结果就正常了。</p><p><strong>修饰符</strong></p><p>在网页匹配过程中会遇到换行符等情况，这时候运行就会报错，因为无法匹配换行符，解决方法是 match 加上第三个参数 re.S，常见的修饰符见下表：</p><table><thead><tr><th align="center">修饰符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">re.I</td><td align="center">使匹配对大小写不敏感</td></tr><tr><td align="center">re.L</td><td align="center">实现本地化识别（locale-aware）匹配</td></tr><tr><td align="center">re.M</td><td align="center">多行匹配，影响 ^ 和 $</td></tr><tr><td align="center">re.S</td><td align="center">使匹配内容包括换行符在内的所有字符</td></tr><tr><td align="center">re.U</td><td align="center">根据 Unicode 字符集解析字符，影响 \w、\W、\b 和 \B</td></tr><tr><td align="center">re.X</td><td align="center">忽略表达式中空白和注释（# 引导），以便将正则表达式写得更易于理解</td></tr></tbody></table><p><strong>转移匹配</strong></p><p>当在目标字符串中遇到用作正则匹配模式的特殊字符时，在此字符前加 \ 转义即可。</p><ul><li><strong>search</strong></li></ul><p>匹配时会扫描整个字符串，返回第一个匹配成功的结果，为了匹配方便，尽量使用、 search()。</p><ul><li><strong>findall</strong></li></ul><p>返回所有匹配成功的结果，结果是列表类型，列表中每个元素则是元组类型。</p><ul><li><strong>sub</strong></li></ul><p>正则替换，<code>re.sub(&#39;\d+&#39;, &#39;str&#39;, content)</code>，解释：在 content 中匹配所有数字，将其替换为 str 字符（可为空）。很多时候爬取下来的数据都需要进行清洗，再进行匹配提取操作，sub 方法是不错的选择。</p><ul><li><strong>compile</strong></li></ul><p>为了复用正则表达式，可以用 compile 方法给表达式做一层封装，方便使用，且 compile 中还可加入修饰符。</p><h3 id="httpx-的使用"><a href="#httpx-的使用" class="headerlink" title="httpx 的使用"></a>httpx 的使用</h3><p>urllib 和 requests 有个问题就是只支持 HTTP/1.1，对采用 HTTP/2.0 的网站无法爬取数据，目前支持 HTTP/2.0 有代表性的库有 hyper 和 httpx，后者使用更方便，功能也更强大，用法上和 requests 基本差不多，这里主要说明不一样的地方。</p><ul><li><strong>Client 对象</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> httpx.Client() <span class="keyword">as</span> client:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="comment"># 推荐 with as 用法，等价于：</span></span><br><span class="line">client = httpx.Client()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure><p>声明 Client 对象时也可指定 headers 等参数，如果开启 HTTP/2.0（默认关闭），写法为：</p><p><code>client = httpx.Client(http2=True)</code></p><blockquote><p>注意：启用 HTTP/2.0 前必须保证客户端和服务器都支持 HTTP/2.0，不然就得改用 1.1 版本</p></blockquote><ul><li>支持异步请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient(http2=<span class="literal">True</span>) <span class="keyword">as</span> client:</span><br><span class="line">        response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(fetch(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本节爬取一个基本的静态网站来练手。</p><p><strong>链接</strong> <a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a></p><p><img data-src="https://s2.loli.net/2022/02/15/kbYzSNa8wFvcWsC.png"></p><p><strong>目标</strong></p><ul><li>使用 requests 爬取电影列表，包括每个电影的详情页；</li><li>用正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等；</li><li>爬取的内容保存为 JSON 文本文件；</li><li>使用多线程加速爬取</li></ul><p><strong>分析</strong></p><p>进入网页后，打开开发者工具（F12），如下图：</p><p><img data-src="https://s2.loli.net/2022/02/16/1SDINWzmiwVCBEx.png"></p><p>可以看到电影名称就是一个 h2 节点文本，父节点是一个 a 节点，带有 href 属性，表示的是电影详情页的 URL，其他的电影信息都可以通过提取源代码节点中的内容来获得。下面，再来看分页逻辑，将页面拉到底，点击第 2 页，可看到跳转链接为原链接加上 /page/2，继续点击第 3 页、第 4 页，发现逻辑一样，分页思路就清晰了。</p><p><img data-src="https://s2.loli.net/2022/02/16/MAkavb7fxm689wj.png"></p><p>要完成列表页的爬取，我们可以这么实现：</p><ul><li>遍历所有页面，索引为1-10</li><li>从每个页面提取每个电影的详情页 URL</li><li>提取每个详情页的页面元素信息并存储</li></ul><p>具体实现中，我们使用 requests 获取源代码，用 re 库采用正则表达式提取有关信息，并保存为 json 格式的 txt 文本，代码中用到了 logging 库输出信息，可区分内容级别，相比 print 输出定制化程度更高，且线程安全。还用到了 multiprocessing 库实现多进程爬取，全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"></span><br><span class="line"><span class="comment"># logging 用来输出信息，相比 print 线程安全</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br><span class="line">BASE_URL = <span class="string">&#x27;https://ssr1.scrape.center&#x27;</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span>  <span class="comment"># 定义页面数量</span></span><br><span class="line">RESULT_DIR = <span class="string">&#x27;results&#x27;</span>  <span class="comment"># 存储文件夹</span></span><br><span class="line">exists(RESULT_DIR) <span class="keyword">or</span> makedirs(RESULT_DIR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl page by url and return its html</span></span><br><span class="line"><span class="string">    :param url: page url</span></span><br><span class="line"><span class="string">    :return: html of the page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        logging.error(<span class="string">&#x27;get invalid status code %s while scraping %s&#x27;</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occured while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_index</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl index page</span></span><br><span class="line"><span class="string">    :param page: page of index page</span></span><br><span class="line"><span class="string">    :return: html of index page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    index_url = <span class="string">f&#x27;<span class="subst">&#123;BASE_URL&#125;</span>/page/<span class="subst">&#123;page&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> crawl_page(index_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    parse detail url</span></span><br><span class="line"><span class="string">    :param html: html of index page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?class=&quot;name&quot;&gt;&#x27;</span>)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> items:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        detail_url = urljoin(BASE_URL, item)</span><br><span class="line">        <span class="comment"># logging.info(&#x27;get detail url %s&#x27;, detail_url)</span></span><br><span class="line">        <span class="keyword">yield</span> detail_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    单独定义一个 crawl_detail 可使逻辑更清晰，灵活性更好</span></span><br><span class="line"><span class="string">    如果后续需要添加日志输出、预处理等功能就不用改动 crawl_page 方法</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> crawl_page(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>(<span class="params">html</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    parse detail page</span></span><br><span class="line"><span class="string">    :param html:</span></span><br><span class="line"><span class="string">    :return: data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cover_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;class=&quot;item.*?&lt;img.*?src=&quot;(.*?)&quot;.*?class=&quot;cover&quot;&gt;&#x27;</span>, re.S)</span><br><span class="line">    name_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;h2.*?&gt;(.*?)&lt;/h2&gt;&#x27;</span>)</span><br><span class="line">    categories_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;button.*?category.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;/button&gt;&#x27;</span>, re.S)</span><br><span class="line">    published_at_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)\s?上映&#x27;</span>)</span><br><span class="line">    drama_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;class=&quot;drama.*?&lt;p.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br><span class="line">    score_pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;p.*?class=&quot;score.*?&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line">    cover = re.search(cover_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(cover_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    name = re.search(name_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(name_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    categories = re.findall(categories_pattern, html) <span class="keyword">if</span> re.findall(categories_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    published_at = re.search(published_at_pattern, html).group(<span class="number">1</span>) <span class="keyword">if</span> re.search(published_at_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    drama = re.search(drama_pattern, html).group(<span class="number">1</span>).strip() <span class="keyword">if</span> re.search(drama_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    score = <span class="built_in">float</span>(re.search(score_pattern, html).group(<span class="number">1</span>).strip()) <span class="keyword">if</span> re.search(score_pattern, html) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;publish_at&#x27;</span>: published_at,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Save data to json file</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULT_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">page</span>):</span></span><br><span class="line">    index_html = crawl_index(page)</span><br><span class="line">    detail_urls = parse_index(index_html)</span><br><span class="line">    <span class="comment"># logging.info(&#x27;detail urls %s&#x27;, list(detail_urls))</span></span><br><span class="line">    <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">        detail_html = crawl_detail(detail_url)</span><br><span class="line">        data = parse_detail(detail_html)</span><br><span class="line">        logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>, data)</span><br><span class="line">        logging.info(<span class="string">&#x27;save data to json file&#x27;</span>)</span><br><span class="line">        save_data(data)</span><br><span class="line">        logging.info(<span class="string">&#x27;data saved successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># Pycharm 输入快捷键 main</span></span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;本章我们了解基础的 HTTP 库，如 urllib、requests、httpx等，最后一起来完成对一个静态网站的爬取案例实战。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://hyacinth.fit/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记一 -- 爬虫基础</title>
    <link href="https://hyacinth.fit/archives/fc84b201.html"/>
    <id>https://hyacinth.fit/archives/fc84b201.html</id>
    <published>2022-02-14T08:26:50.000Z</published>
    <updated>2022-02-16T14:32:55.614Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" /><p>本章我们会详细了解 HTTP 原理、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，有助于我们更好理解和编写网络爬虫程序。</p><span id="more"></span><h3 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h3><ol><li><strong>URI 和 URL</strong></li></ol><p>URI (Uniform Resource Identifier)，即统一资源标识符；URL (Uniform Resource Locator)，即统一资源定位符。用来寻找互联网上某个资源的链接就是 URI/URL，且具有唯一性。URL 是 URI 的子集，URI 还包括一个子类，叫做URN(Universal Resource Name)，即统一资源名称，只为资源命名而不指定定位，使用很少。对于一般网页链接，都称为 URI 或 URL（习惯）。</p><p>URL遵循一定格式规范，中括号部分为非必要部分，如下：</p><p><code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][#fragment]</code></p><ul><li><code>scheme</code>:：协议。常用的有 http、https、ftp等，也称作 protocol</li><li><code>username</code>、password：用户名和密码。某些情况下 URL 需要提供用户名和密码才能访问</li><li><code>hostname</code>：主机地址。可以是域名或 IP 地址，如 <code>https://www.baidu.com</code>，<code>https://8.8.8.8</code></li><li><code>port</code>：端口。服务器设定的服务端口，如<code>https://8.8.8.8:1234</code>，有些 URL 没有端口信息，是使用默认端口，http 协议默认端口是 80，https 则是 443</li><li><code>path</code>：路径。指网络资源在服务器中的指定地址，如<code>https://github.com/favicon.ico</code>中的 favicon.ico</li><li><code>parameters</code>：参数。用来访问某个资源时的附加信息，如<code>https://8.8.8.8:1234/hello;user</code>，这和 query 不同，勿混用，parameters 是分号后内容</li><li><code>query</code>：查询。如果有多个查询，用 &amp; 隔开，如<code>https://www.example.com/s?wd=nba%ie=utf-8</code></li><li><code>fragment</code>：片段。是对资源描述的部分补充，可理解为资源内容的书签</li></ul><ol start="2"><li><strong>HTTP 和 HTTPS</strong></li></ol><p>在爬虫中，我们抓取的页面通常是基于 HTTP(Hypertext Transfer Protocol) 和 HTTPS(Hypertext Transfer Protocol over Secure Socket Layer) 协议的。</p><p>HTTPS 是在 HTTP 下加入 SSL 层，通过该协议传输的内容都是经过 SSL 加密的，SSL 主要作用如下：</p><ul><li>建立一个信息安全通道，保证数据传输的安全性</li><li>确认网站的真实性。凡是使用 HTTPS 协议的网站，可通过单机浏览器地址栏锁头标志来查看网站认证之后的真实信息，也可通过 CA 机构颁发的安全签章来查询</li></ul><ol start="3"><li><strong>HTTP 请求过程</strong></li></ol><p>在浏览器地址栏输入一个 URL，按下回车后便会向网站所在服务器发送一个请求，网站服务器接收到请求后对其进行处理和解析，然后返回对应响应并传回浏览器，响应中包含页面源代码等内容，浏览器对其进行解析呈现所需网页。</p><ol start="4"><li><strong>请求</strong></li></ol><p>Request，由浏览器发往服务器，分为四部分：请求方法（Request Method）、请求网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。</p><ul><li>请求方法</li></ul><table><thead><tr><th align="center">方法</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">GET *</td><td align="center">请求页面，返回页面内容</td></tr><tr><td align="center">HEAD</td><td align="center">类似于 GET 请求，但响应无内容，用于获取报头</td></tr><tr><td align="center">POST *</td><td align="center">大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td align="center">PUT</td><td align="center">用客户端传向服务器的数据替换指定文档中的内容（更新）</td></tr><tr><td align="center">DELETE</td><td align="center">请求服务器删除指定页面</td></tr><tr><td align="center">CONNECT</td><td align="center">把服务器当做跳板，让服务器代替客户端访问其他网页</td></tr><tr><td align="center">OPTIONS</td><td align="center">允许客户端查看服务器的性能</td></tr><tr><td align="center">TRACE</td><td align="center">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><ul><li><p>请求网址<br>可唯一确定客户端需求资源。</p></li><li><p>请求头</p></li></ul><table><thead><tr><th align="center">请求头</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">请求报头域，用于指定客户端可接受哪些类型的信息</td></tr><tr><td align="center">Accept-Language</td><td align="center">用于指定客户端可接受的语言类型</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">用于指定客户端可接受的内容编码</td></tr><tr><td align="center">Host</td><td align="center">用于指定请求资源的主机 IP 和端口号，内容为请求 URL 的原始服务器或网关位置</td></tr><tr><td align="center">Cookie</td><td align="center">也常用 Cookies，网站为了辨别用户，进行会话跟踪而存储在用户本地的数据。主要功能是维持当前访问会话</td></tr><tr><td align="center">Referer</td><td align="center">用于标识请求的来源页面，服务器可据此做相应处理，如来源统计、防盗链处理等</td></tr><tr><td align="center">User-Agent</td><td align="center">简称 UA，使服务器识别，客户端使用的操作系统及版本、浏览器及版本信息。爬取时加上使得伪装浏览器程度更高</td></tr><tr><td align="center">Content-Type</td><td align="center">也叫互联网媒体类型（Internet Media Type）或 MIME 类型，表示请求中的媒体类型信息</td></tr></tbody></table><ul><li>请求体<br>一般承载的的是 POST 请求中的表单数据，对于 GET 请求，请求头为空。</li></ul><table><thead><tr><th align="center">Content-Type</th><th align="center">POST 提交数据方式</th></tr></thead><tbody><tr><td align="center">application/x-www-form-urlencoded</td><td align="center">表单数据</td></tr><tr><td align="center">multipart/form-data</td><td align="center">表单文件上传</td></tr><tr><td align="center">application/json</td><td align="center">序列化 JSON 数据</td></tr><tr><td align="center">text/html</td><td align="center">XML 数据</td></tr></tbody></table><ol start="5"><li><strong>响应</strong></li></ol><p>Response，由服务器返回给客户端，分为三部分：响应状态码（Response Status Code）、响应头（Response Headers）和响应体（Response Body）。</p><ul><li>响应状态码&emsp;&emsp;&emsp;&emsp;&emsp; </li></ul><table><thead><tr><th align="center"><span style="display:inline-block;width:60px">状态码</span></th><th align="center">说明</th><th align="center">详  情</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="center"><strong>200</strong></td><td align="center">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="center">202</td><td align="center">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="center">203</td><td align="center">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="center">204</td><td align="center">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="center">205</td><td align="center">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="center">206</td><td align="center">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="center">300</td><td align="center">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="center">301</td><td align="center">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">303</td><td align="center">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="center">304</td><td align="center">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="center">305</td><td align="center">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="center">306</td><td align="center">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="center">307</td><td align="center">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="center">402</td><td align="center">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="center">405</td><td align="center">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">406</td><td align="center">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="center">407</td><td align="center">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="center">408</td><td align="center">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="center">409</td><td align="center">Conflict</td><td align="center">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="center">410</td><td align="center">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="center">411</td><td align="center">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="center">412</td><td align="center">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="center">413</td><td align="center">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="center">414</td><td align="center">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="center">415</td><td align="center">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="center">416</td><td align="center">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="center">417</td><td align="center">Expectation Failed</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="center">504</td><td align="center">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="center">505</td><td align="center">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><ul><li>响应头</li></ul><table><thead><tr><th align="center">响应头</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">Date</td><td align="center">用于标识响应产生的时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">用于指定资源的最后修改时间</td></tr><tr><td align="center">Content-Encoding</td><td align="center">用于指定响应内容的编码</td></tr><tr><td align="center">Server</td><td align="center">包含服务器信息，如名称、版本号等</td></tr><tr><td align="center">Content-Type</td><td align="center">文档类型，指定返回数据类型</td></tr><tr><td align="center">Set-Cookie</td><td align="center">设置 Cookie，用于告诉浏览器需要将此内容放在 Cookie 中，下次请求时将 Cookie 带上</td></tr><tr><td align="center">Expires</td><td align="center">用于指定响应过期时间，可让代理服务器或浏览器将加载的内容更新到缓存中</td></tr></tbody></table><ul><li>响应体<br>响应正文数据都在响应体中，爬虫请求后要解析的就是响应体。在浏览器开发者工具中单机 Preview，可看到网页源代码。</li></ul><ol start="6"><li><strong>HTTP 2.0</strong></li></ol><p>HTTP 协议自 2015 年发布 2.0 版本，特点是更快、更简单、更稳定。HTTP 2.0 在传输层做了很多优化，主要目标是通过支持完整的请求与响应复用来减少延迟，并通过有效压缩 HTTP 请求头字段的方式将协议开销降到最低，同时增加对请求优先级和服务器推送的支持。另外，修改版本为 2.0 是因为 2.0 版本实现了二进制分帧层，无法与 HTTP 1.x 的服务器和客户端兼容。</p><ul><li>二进制分帧层<br>在 1.x 版本中，请求和响应都是用文本格式传输的，头部和实体间是用文本换行符隔开的，HTTP 2.0 则将文本格式改为二进制格式，使得解析更高效。同时将请求和响应数据分割为更小的帧，并采用二进制编码，将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息，所有这些都可以在一个 TCP 连接中复用。</li><li>多路复用<br>在 HTTP 1.x 中，如果客户端要发起多个并行请求以提升性能，需要使用多个 TCP 连接，而且浏览器为了控制资源，对单个域名会有 6~8 个 TCP 连接请求的限制。但在 HTTP 2.0 中，客户端和服务器可将 HTTP 消息分解为互不依赖的帧，然后交错发送，再在另一端将其重新组装，达到以下效果：<ul><li>并行交错地发送多个请求，请求之间互不影响</li><li>并行交错地发送多个响应，响应之间互不干扰</li><li>使用一个连接并行发送多个请求和响应</li><li>不必再为绕过 HTTP 1.x 限制而做很多工作</li><li>消除不必要的延迟和提高现有网络容量的利用率，减少页面加载时间</li><li>同域名只需占用一个 TCP 连接，并行发送多个请求和响应，消除多余的延时和内存消耗</li><li>每个请求可以带一个 31 位的优先值，0 表示最高优先级，数值越大优先级越低。据此，客户端和服务器可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧   </li></ul></li><li>流控制<br>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。HTTP 2.0 提供了一组简单的构建块，允许客户端和服务器实现它们自己的数据流和连接级流控制。<ul><li>流控制具有方向性。每个接收方都可根据自身需要选择为每个数据流和整个连接设置任意的窗口大小</li><li>流控制的窗口大小是动态调整的。每个接收方都可公布其初始连接和数据流控制窗口（字节单位），当发送放发出 DATA 帧时窗口减小，在接收方发出 WINDOW_UPDATE 帧时窗口增大</li><li>流控制无法停用。建立 HTTP 2.0 连接后，客户端与服务器交换 SETTINGS 帧，这会在两个方向上设置流控制窗口</li></ul></li><li>服务器推送<br>服务器可对一个客户端请求发送多个响应，除了对最初请求响应外，也可主动推送资源，无须客户端明确请求。</li><li>HTTP 2.0 发展现状<br>任重而道远，虽然一些主流网站和主流浏览器实现了对 HTTP 2.0 的支持，但总体上大部分网站仍以 HTTP 1.1 为主。另外，一些编程语言库还未完全支持 HTTP’ 2.0，对 Python 来说，hyper、httpx 等库已支持 2.0，但广泛使用的 request 库依然只支持 HTTP 1.1。</li></ul><h3 id="爬虫基本原理"><a href="#爬虫基本原理" class="headerlink" title="爬虫基本原理"></a>爬虫基本原理</h3><p>把互联网比作一张大网，爬虫（网络爬虫）便是在网上爬行的蜘蛛。把网中的节点比作一个个网页，蜘蛛爬到节点相当于爬虫访问了一个页面。节点间的连线可比作网页间的链接关系，蜘蛛通过一个节点后，顺着节点连线继续爬行到下一个节点，意味着爬虫通过网页间的链接关系继续获取后续网页，直至将整个网站涉及页面都访问到并存储获取到的数据。</p><p>爬虫就是获取网页并提取和保存信息的自动化程序。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>很多页面需要登录才可以访问，为了保持这种登录状态，就要用到 Session 和 Cookie。</p><p>HTTP 有一个特点，无状态。是指 HTTP 协议对事物处理是没有记忆能力的，服务器并不知道客户端处于什么状态，如果需要多次处理之前的消息，客户端就需要额外传递一些重复请求，才能获取后续响应。</p><p>Session，即会话，本义指有始有终的一系列动作、消息。如打电话时，从拿起电话拨号通话，到挂断电话之间的一系列过程可称为一个 Session。它位于服务端，用来保持用户的 Session 信息。当用户请求到来，如果还没对应 Session，则会新建。当 Session 过期或被放弃后，服务器会终止该 Session。</p><p>Cookie 在客户端，浏览器在下次访问相同网页时会自动带上，Cookie 中携带了 Session ID 信息，服务器通过识别 Cookie 鉴定出具体用户，然后判断是否处于登录状态，并返回对应响应。</p><p>Cookie 包含的内容如下：</p><table><thead><tr><th>条目</th><th align="center">描  述</th></tr></thead><tbody><tr><td>Name</td><td align="center">Cookie 名称，一经创建，不可更改</td></tr><tr><td>Value</td><td align="center">Cookie 值，若为 Unicode 字符，则需要为字符编码；若为二进制数据，则需要使用 BASE64 编码</td></tr><tr><td>Domain</td><td align="center">指定可以访问该 Cookie 的域名</td></tr><tr><td>Path</td><td align="center">Cookie 的使用路径。如 / 表示所有页面，/path/ 表示路径为 /path/ 的页面才能访问</td></tr><tr><td>Max-Age</td><td align="center">Cookie 的失效时间，单位秒，常和 Expires 一起使用，通过此属性可计算 Cookie 的有效时间。若为负数，Cookie 在浏览器关闭后失效</td></tr><tr><td>Size</td><td align="center">Cookie 的大小</td></tr><tr><td>HTTP</td><td align="center">Cookie 的 httponly 属性。若为 true，则只有在 HTTP Headers中才会带有此 Cookie 的信息，不能通过 document.cookie 访问此 Cookie</td></tr><tr><td>Secure</td><td align="center">是否仅允许使用安全协议传输 Cookie。使用安全协议在传输数据前会先加密，默认为 false</td></tr></tbody></table><p><strong>tips</strong></p><p>除非程序通知服务器删除一个 Session，否则服务器会一直保留。当浏览器关闭后 Cookie 就消失的情况，等再次打开连接服务器，新 Cookie 无法连接到原先的 Session。如果将 Cookie 保存到硬盘上，或使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookie 发给服务器，则又能保持登录状态。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>网站会采取一些反爬虫措施，如检测某个 IP 在单位时间内的请求次数，如果请求次数超过设定阈值，会拒绝响应请求，并返回一些错误信息，这种情况称为封 IP。一种有效的伪装 IP 的方式就是使用代理。</p><ol><li><strong>基本原理</strong></li></ol><p>代理是发挥着网络信息中转站的作用，当客户端发起请求时，先由代理服务器接收，再由代理服务器发给 Web 服务器，返回的响应也是先由代理服务器接收，再发给客户端。如此，Web 服务器便无法识别真实 IP。</p><ol start="2"><li><strong>代理作用</strong></li></ol><ul><li>突破自身 IP 的访问限制，访问一些平时不能访问的站点</li><li>访问一些单位和团体的内部资源，如使用教育网内地址段的免费代理服务器，就可以下载和上传对教育网开放的各类 FTP，也可以查询、共享各类资料等</li><li>提高访问速度。通常，代理服务器会设置一个较大的硬盘缓冲区，当外界信息通过时，会保存到缓冲区中，当其他用户访问相同信息时，直接从缓冲区取出信息，提高访问速度</li><li>隐藏真实 IP。上网者可以隐藏自己的 IP，免受攻击或防止被封锁</li></ul><ol start="3"><li><strong>代理分类</strong></li></ol><p>根据<strong>协议</strong>区分：</p><ul><li>FTP 代理服务器：主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121等</li><li>HTTP 代理服务器：主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128等</li><li>SSL/TLS 代理：主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位），端口一般为 443</li><li>RTSP 代理：主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554</li><li>Telnet 代理：主要用于 Telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为 23</li><li>POP3/SMTP 代理：主要用于以 POP3/SMTP 方式收发邮件，一般有缓存功能，端口一般为 110/25</li><li>SOCKS 代理：单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 只支持 TCP，后者则支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等</li></ul><p>根据<strong>匿名程序</strong>区分</p><ul><li>高度匿名代理：会将数据包原封不动地转发</li><li>普通匿名代理：会对数据包对一些改动，服务器可能会发现访问的是代理服务器，并有一定概率去追查真实 IP。这里代理服务器通常会加入的 HTTP 头有 HTTP_VIA 和 HTTP_X_FORWARDED_FOR</li><li>透明代理：不但改动了数据包，还告诉服务器客户端的真实 IP。这种代理主要利用缓存技术提高访问速度，用内容过滤提高安全性，如内网中的硬件防火墙</li><li>间谍代理：由阻止或个人创建的代理服务器，用于记录用户传输的数据，然后对记录的数据进行研究、监控等</li></ul><ol start="4"><li><strong>常见代理设置</strong></li></ol><h3 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h3><ol><li><strong>多线程含义</strong></li></ol><p>进程是线程的集合，进程是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的最小运行单元。如在一个浏览器中，播放音乐是一个线程，播放视频也是一个线程，这些线程并发或并行执行使得浏览器可以同时运行多个任务。</p><ol start="2"><li><strong>并发与执行</strong></li></ol><p>处理器同一时间只能执行一条指令。并发（concurrency）是指多个线程对应的多条指令被快速轮换执行，从宏观上看起来是同时运行的，但同一时刻只有一个线程被执行。</p><p>并行（parallel）是指同一时刻有多条指令在多个处理器上同时执行，意味着并行必须依赖多个处理器。</p><ol start="3"><li><strong>多线程适用场景</strong></li></ol><p>在一个程序的进程中，有些操作是比较耗时的，如等待数据库查询结果的返回、等待网页的响应。处理器在等待过程中，是可以使用多线程去执行其他操作的。</p><p>网络爬虫就是一个典型例子，爬虫向服务器发起请求后，有一段时间需要等待服务器响应，这属于 IO 密集型任务，对于这种任务，使用多线程就可以提高整体爬取效率。</p><ol start="4"><li><strong>多进程含义</strong></li></ol><p>进程（progress）是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。多进程就是指同时运行多个进程。</p><ol start="5"><li><strong>Python 中的多线程和多进程</strong></li></ol><p>Python 中 GIL(Global Interpreter Lock，全局解释锁) 的限制导致不论是在单核还是多核条件下，同一时刻只能运行一个线程，使得 Python 多线程无法发挥多核并行优势。</p><p>GIL设计之初是出于对数据安全的考虑，Python 多线程下，每个线程执行方式如下：</p><ul><li>获取 GIL</li><li>执行对应线程代码</li><li>释放 GIL</li></ul><p>GIL 就好像一个通行证，一个 Python 进程中，只有一个 GIL，线程只有拿到通行证才能执行，也就是说多进程能更好发挥多核优势。</p><p>对于爬虫这种 IO 密集型任务来说，多线程和多进程产生影响差别不大，但对于计算密集型任务来说，由于 GIL 的存在，Python 多线程的整体运行效率在多核情况下可能反而比单核还低。而 Python 多进程相比多线程，运行效率在多核情况下比单核会有成倍提升。</p><p>整体来看，Python 多进程比多线程更有优势。另外，由于进程是系统进行资源分配和调度的一个独立单位，所以各进程间的数据是不共享的，进程之间的数据须有单独的机制来实现。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;本章我们会详细了解 HTTP 原理、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，有助于我们更好理解和编写网络爬虫程序。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://hyacinth.fit/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://hyacinth.fit/archives/fb40efc5.html"/>
    <id>https://hyacinth.fit/archives/fb40efc5.html</id>
    <published>2021-10-31T02:46:09.000Z</published>
    <updated>2022-02-16T14:26:10.861Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/10/31/IshnK7BdfaJVo4l.jpg" alt="img" style="zoom:50%;" /><p>编译器是如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？</p><span id="more"></span><p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图，每个源文件对应一个顶点，依赖关系就是边。</p><p>而且，这个图不仅是有向图，还要是一个有向无环图，拓扑排序本身就是一个有向无环图的算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// s先于t，边s-&gt;t</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是数据结构，实现拓扑排序的算法有两种，分别是 <strong>Kahn 算法</strong>和 <strong>DFS 深度优先搜索</strong></p><p><strong>1. Kahn 算法</strong></p><p>主要用了贪心思想</p><p>遍历到某个顶点时，入度 -1，入度为 0 时即输出到拓扑排序的结果序列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[v]; <span class="comment">// 统计每个顶点的入度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">      inDegree[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = queue.remove();</span><br><span class="line">    System.out.print(<span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = adj[i].get(j);</span><br><span class="line">      inDegree[k]--;</span><br><span class="line">      <span class="keyword">if</span> (inDegree[k] == <span class="number">0</span>) queue.add(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. DFS 深度优先搜素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span></span><br><span class="line">  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 申请空间</span></span><br><span class="line">    inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 通过邻接表生成逆邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">      inverseAdj[w].add(i); <span class="comment">// w-&gt;i</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 深度优先遍历图</span></span><br><span class="line">    <span class="keyword">if</span> (visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">      visited[i] = <span class="keyword">true</span>;</span><br><span class="line">      dfs(i, inverseAdj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = inverseAdj[vertex].get(i);</span><br><span class="line">    <span class="keyword">if</span> (visited[w] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    visited[w] = <span class="keyword">true</span>;</span><br><span class="line">    dfs(w, inverseAdj, visited);</span><br><span class="line">  &#125; <span class="comment">// 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span></span><br><span class="line">  System.out.print(<span class="string">&quot;-&gt;&quot;</span> + vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序应用"><a href="#拓扑排序应用" class="headerlink" title="拓扑排序应用"></a>拓扑排序应用</h3><p>凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环。</p><p>关于图中环的检测，在解决查找最终推荐人的问题时，就说到可能存在脏数据，导致循环推荐，如，A 推荐 B，B 推荐 C，C 推荐 A。我们可以把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/10/31/IshnK7BdfaJVo4l.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;编译器是如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>A* 算法</title>
    <link href="https://hyacinth.fit/archives/8ec8a19a.html"/>
    <id>https://hyacinth.fit/archives/8ec8a19a.html</id>
    <published>2021-10-28T12:49:15.000Z</published>
    <updated>2022-02-16T14:38:42.336Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2021/10/28/UvuOAae9QGZ2FmN.png"></p><p>A Star 算法是一种很常用的路径查找和图形遍历算法。利用当前与问题有关的信息作为启发式信息，有效提升查找效率，具有较好的性能和准确度。</p><span id="more"></span><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p>$f(n) = g(n) + h(n)$</p><ul><li>f(n) 是节点 n 的综合优先级，我们总会选取 f(n) 最小的值（优先级最高）的下一个节点，也因此 A* 算法会借助<strong>优先队列</strong>来实现；</li><li>g(n) 是节点 n 距离起点的代价；</li><li>h(n) 是节点 n 距离终点的估计代价，也是 A* 算法的启发函数</li></ul><p>A* 算法具有两个性质：</p><ul><li><p>如果对于任意的节点 $x$，$H(x) \leq H^*(x)$  恒成立，即我们「估计」出的从节点 $x$ 到终点 $t$ 的最短路径长度总是不超过「实际」的最短路径长度，那么称启发函数 $H(x)$ 是可接纳的（admissible heuristic）。在这种情况下，$A*$ 算法一定能找到最短路，但同一节点可能需要加入优先队列并搜索多次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 并不一定等于从起点到节点 $x$ 的「实际」最短路径的长度；</p></li><li><p>如果对于任意的两个节点 $x$ 和 $y$，并且 $x$ 到 $y$ 有一条长度为 $D(x, y)$ 的有向边，$H(x)−H(y)≤D(x,y)$ 恒成立，并且 $H(t)=0$，那么称启发函数 $H(x)$ 是一致的（consistent heuristic）。可以证明，一致的启发函数一定也是可接纳的。在这种情况下，同一节点只会被加入优先队列一次，并搜索不超过一次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 一定等于从起点到节点 $x$ 的「实际」最短路径的长度。</p></li></ul><p>算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">frontier &#x3D; PriorityQueue()</span><br><span class="line">frontier.put(start, 0)</span><br><span class="line">came_from &#x3D; dict()</span><br><span class="line">cost_so_far &#x3D; dict()</span><br><span class="line">came_from[start] &#x3D; None</span><br><span class="line">cost_so_far[start] &#x3D; 0</span><br><span class="line"></span><br><span class="line">while not frontier.empty():</span><br><span class="line">   current &#x3D; frontier.get()</span><br><span class="line"></span><br><span class="line">   if current &#x3D;&#x3D; goal:</span><br><span class="line">      break</span><br><span class="line">   </span><br><span class="line">   for next in graph.neighbors(current):</span><br><span class="line">      new_cost &#x3D; cost_so_far[current] + graph.cost(current, next)</span><br><span class="line">      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:</span><br><span class="line">         cost_so_far[next] &#x3D; new_cost</span><br><span class="line">         priority &#x3D; new_cost + heuristic(goal, next)</span><br><span class="line">         frontier.put(next, priority)</span><br><span class="line">         came_from[next] &#x3D; current</span><br></pre></td></tr></table></figure><p>作为启发式函数的 h(n)，以八数码问题为例，可以使用曼哈顿距离作为启发搜索条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def heuristic(a, b):</span><br><span class="line">   # Manhattan distance on a square grid</span><br><span class="line">   return abs(a.x - b.x) + abs(a.y - b.y)</span><br></pre></td></tr></table></figure><hr><p>下面以 LeetCode 第 773 题为例</p><p>在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.<br>一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.<br>最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。<br>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 </p><p>示例：</p><blockquote><p>输入：board = [[1,2,3],[4,0,5]]<br>输出：1<br>解释：交换 0 和 5 ，1 步完成</p><p>输入：board = [[1,2,3],[5,4,0]]<br>输出：-1<br>解释：没有办法完成谜板</p><p>输入：board = [[4,1,2],[5,0,3]]<br>输出：5<br>解释：<br>最少完成谜板的最少移动次数是 5 ，<br>一种移动路径:<br>尚未移动: [[4,1,2],[5,0,3]]<br>移动 1 次: [[4,1,2],[0,5,3]]<br>移动 2 次: [[0,1,2],[4,5,3]]<br>移动 3 次: [[1,0,2],[4,5,3]]<br>移动 4 次: [[1,2,0],[4,5,3]]<br>移动 5 次: [[1,2,3],[4,5,0]]<br>输入：board = [[3,2,4],[1,5,0]]<br>输出：14</p></blockquote><p>提示：</p><blockquote><p>board 是一个如上所述的 2 x 3 的数组.<br>board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>启发函数 $H(status)= \sum_{i=1}^5(status中数字 i 的位置与目标状态中数字 i 的位置之间的曼哈顿距离)$</p><p>我们同时可以预处理出任意两个位置的曼哈顿距离，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AStar</span>:</span></span><br><span class="line">    DIST = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算启发函数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getH</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">if</span> status[i] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                ret += AStar.DIST[i][<span class="built_in">int</span>(status[i]) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, status: <span class="built_in">str</span>, g: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.status = status</span><br><span class="line">        self.g = g</span><br><span class="line">        self.h = AStar.getH(status)</span><br><span class="line">        self.f = self.g + self.h</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other: <span class="string">&quot;AStar&quot;</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.f &lt; other.f</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slidingPuzzle</span>(<span class="params">self, board: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># board 压缩成一维数组，记录砖瓦的 neighbor index</span></span><br><span class="line">        neighbor = [[<span class="number">1</span>, <span class="number">3</span>],[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>],[<span class="number">1</span>, <span class="number">5</span>],[<span class="number">0</span>, <span class="number">4</span>],[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],[<span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line">        <span class="comment"># 获取 status 操作一次后的所有状态</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; Generator[str, <span class="keyword">None</span>, <span class="keyword">None</span>]:</span></span><br><span class="line">            s = <span class="built_in">list</span>(status)</span><br><span class="line">            x = s.index(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> neighbor[x]:</span><br><span class="line">                s[x], s[y] = s[y], s[x]</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br><span class="line">                s[x], s[y] = s[y], s[x]</span><br><span class="line"></span><br><span class="line">        target = <span class="string">&#x27;123450&#x27;</span></span><br><span class="line">        start = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> i <span class="keyword">in</span> board <span class="keyword">for</span> x <span class="keyword">in</span> i])</span><br><span class="line">        <span class="keyword">if</span> start == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [AStar(start, <span class="number">0</span>)]</span><br><span class="line">        visited = <span class="built_in">set</span>(start)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">for</span> next_status <span class="keyword">in</span> get(node.status):</span><br><span class="line">                <span class="keyword">if</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">if</span> next_status == target:</span><br><span class="line">                        <span class="keyword">return</span> node.g + <span class="number">1</span></span><br><span class="line">                    heapq.heappush(q, AStar(next_status, node.g + <span class="number">1</span>))</span><br><span class="line">                    visited.add(next_status)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/10/28/UvuOAae9QGZ2FmN.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;A Star 算法是一种很常用的路径查找和图形遍历算法。利用当前与问题有关的信息作为启发式信息，有效提升查找效率，具有较好的性能和准确度。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划实战</title>
    <link href="https://hyacinth.fit/archives/2f0539d8.html"/>
    <id>https://hyacinth.fit/archives/2f0539d8.html</id>
    <published>2021-09-06T01:55:57.000Z</published>
    <updated>2021-10-28T12:46:14.433Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/07/mLQUsPOgKWCtrbn.jpg" style="zoom:50%;" /><p>当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。那这个功能是如何实现的呢？</p><span id="more"></span><h3 id="如何量化两个字符串的相似度？"><a href="#如何量化两个字符串的相似度？" class="headerlink" title="如何量化两个字符串的相似度？"></a>如何量化两个字符串的相似度？</h3><p>先来看，如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是<strong>编辑距离</strong>（Edit Distance）。指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p><p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（Levenshtein distance）和<strong>最长公共子串长度</strong>（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p><p>莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。</p><p>下图例子中，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><img data-src="https://i.loli.net/2021/09/07/R6jMzknfrpBd5JV.jpg" style="zoom:50%;" /><h3 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h3><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合多阶段决策最优解模型。</p><p>先看下用回溯算法如何解决。</p><p>回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：</p><ul><li>可以删除 a[i]，然后递归考察 a[i+1] 和 b[j]；</li><li>可以删除 b[j]，然后递归考察 a[i] 和 b[j+1]；</li><li>可以在 a[i] 前面添加一个跟 b[j] 相同的字符，然后递归考察 a[i] 和 b[j+1];</li><li>可以在 b[j] 前面添加一个跟 a[i] 相同的字符，然后递归考察 a[i+1] 和 b[j]；</li><li>可以将 a[i] 替换成 b[j]，或者将 b[j] 替换成 a[i]，然后递归考察 a[i+1] 和 b[j+1]。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] a = <span class="string">&quot;mitcmu&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] b = <span class="string">&quot;mtacnu&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="comment">// 调用方式 lwstBT(0, 0, 0);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lwstBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> edist)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == n || j == m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) edist += (n-i);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m) edist += (m - j);</span><br><span class="line">    <span class="keyword">if</span> (edist &lt; minDist) minDist = edist;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a[i] == b[j]) &#123; <span class="comment">// 两个字符匹配</span></span><br><span class="line">    lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 两个字符不匹配</span></span><br><span class="line">    lwstBT(i + <span class="number">1</span>, j, edist + <span class="number">1</span>); <span class="comment">// 删除a[i]或者b[j]前添加一个字符</span></span><br><span class="line">    lwstBT(i, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 删除b[j]或者a[i]前添加一个字符</span></span><br><span class="line">    lwstBT(i + <span class="number">1</span>, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 将a[i]和b[j]替换为相同字符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p><img data-src="https://static001.geekbang.org/resource/image/86/89/864f25506eb3db427377bde7bb4c9589.jpg" style="zoom:50%;" /><p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。</p><p>在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p><p>这个例子的状态转移方式相对矩阵最短路径问题要复杂一点：</p><img data-src="https://i.loli.net/2021/09/07/H9xvPDmWbSzs4ER.jpg" style="zoom:50%;" /><p>将状态转移方程写出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-<span class="number">1</span>,j)+<span class="number">1</span>, min_edist(i,j-<span class="number">1</span>)+<span class="number">1</span>, min_edist(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">如果：a[i]==b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-<span class="number">1</span>,j)+<span class="number">1</span>, min_edist(i,j-<span class="number">1</span>)+<span class="number">1</span>，min_edist(i-<span class="number">1</span>,j-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">其中，min表示求三数中的最小值。     </span><br></pre></td></tr></table></figure><p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值。</p><img data-src="https://i.loli.net/2021/09/07/xLBdvnz43ZDJa6s.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lwstDP</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] minDist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123; <span class="comment">// 初始化第0行:a[0..0]与b[0..j]的编辑距离</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) minDist[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) minDist[<span class="number">0</span>][j] = minDist[<span class="number">0</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minDist[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化第0列:a[0..i]与b[0..0]的编辑距离</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) minDist[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) minDist[i][<span class="number">0</span>] = minDist[i-<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minDist[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 按行填表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) minDist[i][j] = min(</span><br><span class="line">          minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">else</span> minDist[i][j] = min(</span><br><span class="line">          minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minDist[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> minv = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; minv) minv = x;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; minv) minv = y;</span><br><span class="line">  <span class="keyword">if</span> (z &lt; minv) minv = z;</span><br><span class="line">  <span class="keyword">return</span> minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何编程计算最长公共子串长度？"><a href="#如何编程计算最长公共子串长度？" class="headerlink" title="如何编程计算最长公共子串长度？"></a>如何编程计算最长公共子串长度？</h3><p>每个状态包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。</p><p>先来看回溯的处理思路。我们从 a[0]和 b[0]开始，依次考察两个字符串中的字符是否匹配。</p><ul><li>如果 a[i]与 b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li><li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</li><li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li><li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line">如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>, max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))；</span><br><span class="line"></span><br><span class="line">如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-<span class="number">1</span>,j-<span class="number">1</span>), max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))；</span><br><span class="line"></span><br><span class="line">其中max表示求三数中的最大值。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] maxlcs = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;<span class="comment">//初始化第0行：a[0..0]与b[0..j]的maxlcs</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) maxlcs[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) maxlcs[<span class="number">0</span>][j] = maxlcs[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> maxlcs[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;<span class="comment">//初始化第0列：a[0..i]与b[0..0]的maxlcs</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) maxlcs[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) maxlcs[i][<span class="number">0</span>] = maxlcs[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> maxlcs[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) maxlcs[i][j] = max(</span><br><span class="line">          maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> maxlcs[i][j] = max(</span><br><span class="line">          maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxlcs[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxv = Integer.MIN_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; maxv) maxv = x;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; maxv) maxv = y;</span><br><span class="line">  <span class="keyword">if</span> (z &gt; maxv) maxv = z;</span><br><span class="line">  <span class="keyword">return</span> maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p><p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。</p><p>针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。</p><ul><li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</li><li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</li><li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</li></ul><p>针对纠错性能方面，我们也有相应的优化方式。我讲两种分治的优化思路。</p><ul><li>如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</li><li>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/07/mLQUsPOgKWCtrbn.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。那这个功能是如何实现的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划理论</title>
    <link href="https://hyacinth.fit/archives/f5510e8e.html"/>
    <id>https://hyacinth.fit/archives/f5510e8e.html</id>
    <published>2021-09-06T01:55:52.000Z</published>
    <updated>2021-10-28T12:46:14.435Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/06/vP3QhA5EgiRsc92.jpg" style="zoom:50%;" /><p>什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？</p><span id="more"></span><h3 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h3><p>什么是<strong>“一个模型”</strong>？它指的是动态规划适合解决的问题的模型。我把这个模型定义为<strong>“多阶段决策最优解模型”</strong>。</p><p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>什么是<strong>“三个特征”</strong>？它们分别是<strong>最优子结构、无后效性和重复子问题</strong>。</p><ol><li><strong>最优子结构</strong></li></ol><p>指问题的最优解包含子问题的最优解。也就是说我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><ol start="2"><li><strong>无后效性</strong></li></ol><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><ol start="3"><li>重复子问题</li></ol><p>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h3 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h3><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p><img data-src="https://i.loli.net/2021/09/06/7SkDG8MzWBLE3yo.jpg" style="zoom:50%;" /><p>我们先看看，这个问题是否符合“一个模型”？</p><p>从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>我们把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p><img data-src="https://i.loli.net/2021/09/06/sHrlK8AgqpG3LbJ.jpg" style="zoom: 33%;" /><p>我们再来看，这个问题是否符合“三个特征”？</p><p>我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。</p><img data-src="https://i.loli.net/2021/09/06/Rgj7xYBlyU6V4pF.jpg" style="zoom:50%;" /><p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p><p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="number">1</span>), min_dist(i-<span class="number">1</span>, j))</span><br></pre></td></tr></table></figure><h3 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h3><ol><li><strong>状态转移表法</strong></li></ol><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。</p><p><strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong></p><p>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p><p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。</p><p>现在，我们来看一下，如何套用这个状态转移表法，来解决之前那个矩阵最短路径的问题？</p><p>从起点到终点，我们有很多种不同的走法。我们可以穷举所有走法，然后对比找出一个最短走法。不过如何才能无重复又不遗漏地穷举出所有走法呢？我们可以用回溯算法这个比较有规律的穷举算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"><span class="comment">// 调用方式：minDistBacktracing(0, 0, 0, w, n);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span></span><br><span class="line">  <span class="keyword">if</span> (i == n &amp;&amp; j == n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; minDist) minDist = dist;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; n) &#123; <span class="comment">// 往下走，更新i=i+1, j=j</span></span><br><span class="line">    minDistBT(i + <span class="number">1</span>, j, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &lt; n) &#123; <span class="comment">// 往右走，更新i=i, j=j+1</span></span><br><span class="line">    minDistBT(i, j+<span class="number">1</span>, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了回溯代码之后，接下来，我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了</p><img data-src="https://i.loli.net/2021/09/06/vH4RMShyizjWGKD.jpg" style="zoom:50%;" /><p>既然存在重复子问题，我们就可以尝试看下，是否可以用动态规划来解决呢？</p><p>我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充</p><img data-src="https://i.loli.net/2021/09/06/8YpWJRoqOnrcNgh.jpg" style="zoom:50%;" /><img data-src="https://i.loli.net/2021/09/06/jtu7ImVde3GslTF.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123; <span class="comment">// 初始化states的第一行数据</span></span><br><span class="line">    sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">    states[<span class="number">0</span>][j] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states的第一列数据</span></span><br><span class="line">    sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">    states[i][<span class="number">0</span>] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      states[i][j] = </span><br><span class="line">            matrix[i][j] + Math.min(states[i][j-<span class="number">1</span>], states[i-<span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> states[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>状态转移方程法</strong></li></ol><p><strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong></p><p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。</p><p>拿刚才例子举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) &#x3D; w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span><br></pre></td></tr></table></figure><p>状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p><p>下面我用递归加“备忘录”的方式，将状态转移方程翻译成来代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = </span><br><span class="line">         &#123;&#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">9</span>&#125;, &#123;<span class="number">2</span>，<span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，&#123;<span class="number">5</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">7</span>&#125;，&#123;<span class="number">6</span>，<span class="number">8</span>，<span class="number">4</span>，<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="comment">// 调用minDist(n-1, n-1);</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (mem[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">  <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    minLeft = minDist(i, j-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    minUp = minDist(i-<span class="number">1</span>, j);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);</span><br><span class="line">  mem[i][j] = currMinDist;</span><br><span class="line">  <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h3><p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/06/vP3QhA5EgiRsc92.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>初识动态规划</title>
    <link href="https://hyacinth.fit/archives/2da9f3b9.html"/>
    <id>https://hyacinth.fit/archives/2da9f3b9.html</id>
    <published>2021-09-06T01:29:42.000Z</published>
    <updated>2021-10-28T12:46:14.430Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/06/W1iAxbGIe42PtRs.jpg" style="zoom:50%;" /><p>淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。如何从 n 个商品中抉择出方案使得商品价格总和最大程度接近满减条件（200元）?</p><span id="more"></span><p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。</p><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><p>相比上节回溯算法，使用动态规划来解决这个背包问题能有效降低时间复杂度</p><p>我们将整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放入背包，我们会把每一层重复的状态合并，然后基于上一层的状态集合来推导下一层的状态集合。通过合并每一层重复状态可以保证每层状态个数不会超过 w（背包承载重量） 个，避免每层状态个数的指数增长。</p><p>我们使用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p><p>第 0 个物品重量是 2，决策完后，用 states[0][0]=true 和 states[0][2]=true 来表示其放入和不放入两种状态。第 1 个物品重量也是 2，基于之前的背包状态，这个物品决策完后，就有三种状态： states[1][0]=true，states[1][2]=true，states[1][2]=true。</p><p>整个状态数组计算完后，只需在最后一层找一个值为 true 的最接近 w 的值，就是背包中物品总重量的最大值。</p><img data-src="https://static001.geekbang.org/resource/image/aa/b5/aaf51df520ea6b8056f4e62aed81a5b5.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">weight:物品重量，n:物品个数，w:背包可承载重量</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w+<span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">  <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;<span class="comment">// 不把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) states[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p><p>代码复杂度好分析，就是 O(n*w)，n 表示物品个数，w 表示背包可以承载总重量。</p><p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。所以，有时候，我们会说，动态规划是一种空间换时间的解决思路。那有什么办法可以降低空间消耗吗？</p><p>实际上，我们只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack2</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[w+<span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">  states[<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">  <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="comment">// 按照 j 从小到大处理的话，会出现 for 循环重复计算的问题。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w-items[i]; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[j]==<span class="keyword">true</span>) states[j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (states[i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h3><p>现在引入物品价值这一变量，对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p><p>先看回溯算法代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int maxV &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 结果放到maxV中</span><br><span class="line">private int[] items &#x3D; &#123;2，2，4，6，3&#125;;  &#x2F;&#x2F; 物品的重量</span><br><span class="line">private int[] value &#x3D; &#123;3，4，8，9，6&#125;; &#x2F;&#x2F; 物品的价值</span><br><span class="line">private int n &#x3D; 5; &#x2F;&#x2F; 物品个数</span><br><span class="line">private int w &#x3D; 9; &#x2F;&#x2F; 背包承受的最大重量</span><br><span class="line">public void f(int i, int cw, int cv) &#123; &#x2F;&#x2F; 调用f(0, 0, 0)</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了，i&#x3D;&#x3D;n表示物品都考察完了</span><br><span class="line">    if (cv &gt; maxV) maxV &#x3D; cv;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw, cv); &#x2F;&#x2F; 选择不装第i个物品</span><br><span class="line">  if (cw + weight[i] &lt;&#x3D; w) &#123;</span><br><span class="line">    f(i+1,cw+weight[i], cv+value[i]); &#x2F;&#x2F; 选择装第i个物品</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p><img data-src="https://i.loli.net/2021/09/06/lQfxFzAW7pb8Oyr.jpg" style="zoom:50%;" /><p>可以发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p><p>接下来看动态规划如何解决。</p><p>还是把整个求解过程分为 n 个阶段，用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack3</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">      states[i][j] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">//动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123; <span class="comment">// 不选择第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123; <span class="comment">// 选择第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = states[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">        <span class="keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">          states[i][j+weight[i]] = v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找出最大值</span></span><br><span class="line">  <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] &gt; maxvalue) maxvalue = states[n-<span class="number">1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)。跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>开篇问题和0-1背包问题很像，“重量”换成了“价格”而已。购物车有 n 个商品，用一个二维数组 states[n][x]，来记录每次决策之后所有可达的状态。</p><p>0-1 背包问题中，我们找的是小于等于 w 的最大值，x 就是背包的最大承载重量 w+1。对于这个问题来说，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际的问题而言，如果要购买的物品的总价格超过 200 太多，比如 1000，那这个羊毛“薅”得就没有太大意义了。所以，我们可以限定 x 值为 1001。</p><p>不过，这个问题不仅要求大于等于 200 的总价格中的最小的，我们还要找出这个最小总价格对应都要购买哪些商品。实际上，我们可以利用 states 数组，倒推出这个被选择的商品序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// items商品价格，n商品个数, w表示满减条件，比如200</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">double11advance</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][<span class="number">3</span>*w+<span class="number">1</span>];<span class="comment">//超过3倍就没有薅羊毛的价值了</span></span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= <span class="number">3</span>*w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w; ++j) &#123;<span class="comment">// 不购买第i个商品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w-items[i]; ++j) &#123;<span class="comment">//购买第i个商品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) states[i][j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">for</span> (j = w; j &lt; <span class="number">3</span>*w+<span class="number">1</span>; ++j) &#123; </span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] == <span class="keyword">true</span>) <span class="keyword">break</span>; <span class="comment">// 输出结果大于等于w的最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">3</span>*w+<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 没有可行解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">// i表示二维数组中的行，j表示列</span></span><br><span class="line">    <span class="keyword">if</span>(j-items[i] &gt;= <span class="number">0</span> &amp;&amp; states[i-<span class="number">1</span>][j-items[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.print(items[i] + <span class="string">&quot; &quot;</span>); <span class="comment">// 购买这个商品</span></span><br><span class="line">      j = j - items[i];</span><br><span class="line">    &#125; <span class="comment">// else 没有购买这个商品，j不变。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j != <span class="number">0</span>) System.out.print(items[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下代码中如何打印选择购买的商品的：</p><p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j]或者 states[i-1][j-value[i]]是否是 true。</p><p>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/06/W1iAxbGIe42PtRs.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。如何从 n 个商品中抉择出方案使得商品价格总和最大程度接近满减条件（200元）?&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://hyacinth.fit/archives/376d0826.html"/>
    <id>https://hyacinth.fit/archives/376d0826.html</id>
    <published>2021-09-02T05:23:27.000Z</published>
    <updated>2021-10-28T12:46:14.440Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/02/FrjA7iKm9pH5vGX.jpg" style="zoom: 50%;" /><p>深度优先搜索算法利用的是回溯算法思想。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p><span id="more"></span><h3 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h3><p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><p>还是看几个经典的例子，增强理解：</p><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p><img data-src="https://i.loli.net/2021/09/02/ejCzlPhv4HitT9R.jpg" style="zoom:50%;" /><p>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p><p>回溯算法非常适合用递归算法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];<span class="comment">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第i行leftup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第i行rightup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">&quot;Q &quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p><p>用回溯的方法，我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p><p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>为了方便讲解，我假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。当遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;?&#x27;</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/02/FrjA7iKm9pH5vGX.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;

&lt;p&gt;深度优先搜索算法利用的是回溯算法思想。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="https://hyacinth.fit/archives/7474c898.html"/>
    <id>https://hyacinth.fit/archives/7474c898.html</id>
    <published>2021-09-01T02:13:50.000Z</published>
    <updated>2021-10-28T12:46:14.428Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/01/FGtVSwuW4oCkJ6X.jpg" style="zoom:50%;" /><p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。</p><span id="more"></span><h3 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h3><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong>实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ul><h3 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h3><p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p><img data-src="https://i.loli.net/2021/09/01/KeSPqbwpETat1FD.jpg" style="zoom:50%;" /><p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p><p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 O(n^2)。那有没有更加高效的处理方法呢？</p><p>我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p>使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？</p><p>这里就要借助归并排序算法了。归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><img data-src="https://i.loli.net/2021/09/01/MnFv139ZwjAOYIt.jpg" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num += (q-i+<span class="number">1</span>); <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123; <span class="comment">// 从tmp拷贝回a</span></span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于分治算法，还有几道比较经典的问题。</p><ul><li><p>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</p></li><li><p>有两个 n<em>n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A</em>B？</p></li></ul><h3 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h3><p>比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。在此就可以利用分治的思想。</p><p>给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>为什么说 MapReduce 的本质就是分治思想？</p><p>刚刚举的订单的例子，数据有 10GB 大小，可能给你的感受还不强烈。那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p><p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p><p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/01/FGtVSwuW4oCkJ6X.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://hyacinth.fit/archives/a4ce31d2.html"/>
    <id>https://hyacinth.fit/archives/a4ce31d2.html</id>
    <published>2021-08-31T02:09:39.000Z</published>
    <updated>2021-10-28T12:46:14.449Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/31/MoGBOnAhSrNsIic.jpg" style="zoom:50%;" /><p>贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。先来看看如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。</p><span id="more"></span><h3 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h3><p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？</p><img data-src="https://i.loli.net/2021/08/31/9XlHKkf26GV1Mej.jpg" style="zoom:50%;" /><p>我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。</p><p>这个问题本质上就是贪心算法，可以总结一下贪心算法解决问题的步骤：</p><ol><li><p>当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p></li><li><p>尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</p></li><li><p>举例验证贪心算法是否得到最优结果。严格证明贪心算法的正确性是很复杂的，设计较多数学推理，一般举几个例子验证即可。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p></li></ol><h3 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h3><ol><li><strong>分糖果</strong></li></ol><p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。</p><p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p><p>可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。</p><p>如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p><ol start="2"><li><strong>钱币找零</strong></li></ol><p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p><p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。</p><ol start="3"><li><strong>区间覆盖</strong></li></ol><p>假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p><img data-src="https://i.loli.net/2021/08/31/pex8BA6jSbROlfW.jpg" style="zoom:50%;" /><p>这个处理思想在很多贪心算法问题中都有用到，比如任务调度、教师排课等等问题。</p><p>这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</p><p>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p><img data-src="https://i.loli.net/2021/08/31/HkgiFSfI7yljNLQ.jpg" style="zoom:50%;" /><h3 id="如何用贪心算法实现霍夫曼编码？"><a href="#如何用贪心算法实现霍夫曼编码？" class="headerlink" title="如何用贪心算法实现霍夫曼编码？"></a>如何用贪心算法实现霍夫曼编码？</h3><p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p><p>假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)</span><br></pre></td></tr></table></figure><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。它不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p>对于等长的编码来说，我们解压缩起来很简单。比如刚才那个例子中，我们用 3 个 bit 表示一个字符。在解压缩的时候，我们每次从文本中读取 3 位二进制码，然后翻译成对应的字符。但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</p><img data-src="https://i.loli.net/2021/08/31/wX4VyIJAriGnZxp.jpg" style="zoom:50%;" /><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p><img data-src="https://i.loli.net/2021/08/31/f25VwgtNoeSpLba.jpg" style="zoom:50%;" /><p>如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？这里的处理稍微有些技巧。</p><p>我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><img data-src="https://i.loli.net/2021/08/31/MTwHPpVdEYgNLum.jpg" style="zoom:50%;" /><p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><img data-src="https://i.loli.net/2021/08/31/vu5VPLzaEH8mWO6.jpg" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/31/MoGBOnAhSrNsIic.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。先来看看如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="https://hyacinth.fit/archives/5c28c80e.html"/>
    <id>https://hyacinth.fit/archives/5c28c80e.html</id>
    <published>2021-08-24T03:26:32.000Z</published>
    <updated>2021-10-28T12:46:14.422Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/24/LkDRBtW8EFIz17y.jpg" style="zoom:50%;" /><p>如何用多模式串匹配实现敏感词过滤功能？</p><span id="more"></span><p>实际上，这些功能最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。如果有，就用“***”把它替代掉。</p><p>前面讲过好几种字符串匹配算法了,但是，对于访问量巨大的网站来说，比如淘宝，用户每天的评论数有几亿、甚至几十亿。这时候，我们对敏感词过滤系统的性能要求就要很高。那如何才能实现一个高性能的敏感词过滤系统呢？这就要用到今天的多模式串匹配算法。</p><h3 id="基于单模式串和-Trie-树实现的敏感词过滤"><a href="#基于单模式串和-Trie-树实现的敏感词过滤" class="headerlink" title="基于单模式串和 Trie 树实现的敏感词过滤"></a>基于单模式串和 Trie 树实现的敏感词过滤</h3><p>字符串匹配算法，有 BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树。前面四种算法都是单模式串匹配算法，只有 Trie 树是多模式串匹配算法。</p><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p><p>尽管，单模式串匹配算法也能完成多模式串的匹配工作。但是，这样做的话，每个匹配过程都需要扫描一遍用户输入的内容。整个过程下来就要扫描很多遍用户输入的内容。如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那我们就需要扫描几千遍这样的输入内容。很显然，这种处理思路比较低效。</p><p>多模式匹配算法在这个问题的处理上就很高效了。它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p><p>我们可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，那我们只需要动态更新一下 Trie 树就可以了。</p><p>当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？这就要用到 AC 自动机算法了。</p><h3 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。其实，Trie 树跟 AC 自动机之间的关系，就像单串匹配中朴素的串匹配算法，跟 KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，<strong>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">char</span> data; </span><br><span class="line">  <span class="keyword">public</span> AcNode[] children = <span class="keyword">new</span> AcNode[<span class="number">26</span>]; <span class="comment">// 字符集只包含a~z这26个字符</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>; <span class="comment">// 结尾字符为true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> length = -<span class="number">1</span>; <span class="comment">// 当isEndingChar=true时，记录模式串长度</span></span><br><span class="line">  <span class="keyword">public</span> AcNode fail; <span class="comment">// 失败指针</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AcNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC 自动机的构建，包含两个操作：</p><ul><li>将多个模式串构建成 Trie 树；</li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li></ul><p>重点看下，<strong>构建好 Trie 树之后，如何在它之上构建失败指针?</strong></p><p>这里有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p><img data-src="https://i.loli.net/2021/08/24/8icgp6rBCk2Rdsj.jpg" style="zoom:50%;" /><p>假设我们沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p><p>这里的最长可匹配后缀子串，解释一下。字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p><p>我们从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。我们将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点。</p><img data-src="https://i.loli.net/2021/08/24/sAqD4aPIWNQBCiF.jpg" style="zoom:50%;" /><p>如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。我们可以逐层依次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历树的过程。</p><p>首先 root 的失败指针为 NULL，也就是指向自己。<strong>当我们已经求得某个节点 p 的失败指针之后，如何寻找它的子节点的失败指针呢？</strong></p><p>我们假设节点 p 的失败指针指向节点 q，我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p><img data-src="https://i.loli.net/2021/08/24/gezXtKb72xWDqFN.jpg" style="zoom:50%;" /><p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针，这里有没有很像 KMP 算法里求 next 的过程？），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p><img data-src="https://i.loli.net/2021/08/24/uWMzIFU3gePGfki.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFailurePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  root.fail = <span class="keyword">null</span>;</span><br><span class="line">  queue.add(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    AcNode p = queue.remove();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">      AcNode pc = p.children[i];</span><br><span class="line">      <span class="keyword">if</span> (pc == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (p == root) &#123;</span><br><span class="line">        pc.fail = root;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AcNode q = p.fail;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">          AcNode qc = q.children[pc.data - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">          <span class="keyword">if</span> (qc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pc.fail = qc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          q = q.fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">          pc.fail = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.add(pc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后构建完成之后的 AC 自动机就是下面这个样子：</p><img data-src="https://i.loli.net/2021/08/24/7Or954NY2ojnCLf.jpg" style="zoom:50%;" /><p>构建完后，<strong>如何在 AC 自动机上匹配主串？</strong></p><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p><ul><li>如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，你可以结合代码看。处理完之后，我们将 i 加一，继续这两个过程；</li><li>如果 p 指向的节点没有等于 b[i]的子节点，那失败指针就派上用场了，我们让 p=p-&gt;fail，然后继续这 2 个过程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123; <span class="comment">// text是主串</span></span><br><span class="line">  <span class="keyword">int</span> n = text.length;</span><br><span class="line">  AcNode p = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> idx = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p.children[idx] == <span class="keyword">null</span> &amp;&amp; p != root) &#123;</span><br><span class="line">      p = p.fail; <span class="comment">// 失败指针发挥作用的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p.children[idx];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) p = root; <span class="comment">// 如果没有匹配的，从root开始重新匹配</span></span><br><span class="line">    AcNode tmp = p;</span><br><span class="line">    <span class="keyword">while</span> (tmp != root) &#123; <span class="comment">// 打印出可以匹配的模式串</span></span><br><span class="line">      <span class="keyword">if</span> (tmp.isEndingChar == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i-tmp.length+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配起始下标&quot;</span> + pos + <span class="string">&quot;; 长度&quot;</span> + tmp.length);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = tmp.fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AC 自动机实现的敏感词过滤系统，是否比单模式串匹配方法更高效呢？</strong></p><p>，Trie 树构建的时间复杂度是 O(m*len)，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。那构建失败指针的时间复杂度是多少呢？我这里给出一个不是很紧确的上界。</p><p>假设 Trie 树中总的节点个数是 k，每个节点构建失败指针的时候，（可以看下代码）最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。整个失败指针的构建过程就是 O(k*len)。</p><p>不过，AC 自动机的构建过程都是预先处理好的，构建好之后，并不会频繁地更新，所以不会影响到敏感词过滤的运行效率。</p><p><strong>用 AC 自动机做匹配的时间复杂度是多少？</strong></p><p>跟刚刚构建失败指针的分析类似，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 O(n)，所以 AC 自动机做敏感词过滤，性能非常高。</p><p>你可以会说，从时间复杂度上看，AC 自动机匹配的效率跟 Trie 树一样啊。实际上，因为失效指针可能大部分情况下都指向 root 节点，所以绝大部分情况下，在 AC 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度。只有在极端情况下，如图所示，AC 自动机的性能才会退化的跟 Trie 树一样。</p><img data-src="https://i.loli.net/2021/08/24/dCR25hBlzAqXUea.jpg" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/24/LkDRBtW8EFIz17y.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;如何用多模式串匹配实现敏感词过滤功能？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="https://hyacinth.fit/archives/10a61f34.html"/>
    <id>https://hyacinth.fit/archives/10a61f34.html</id>
    <published>2021-08-24T03:04:02.000Z</published>
    <updated>2021-10-28T12:46:14.425Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/24/YuXkxBWnls2jbrO.jpg" style="zoom: 50%;" /><p>如何实现搜索引擎的搜索关键词提示功能？</p><span id="more"></span><h3 id="什么是“Trie-树”？"><a href="#什么是“Trie-树”？" class="headerlink" title="什么是“Trie 树”？"></a>什么是“Trie 树”？</h3><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p>假设有 6 个字符串：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 6 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p><p>我们可以先对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。<strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。</p><img data-src="https://i.loli.net/2021/08/24/mk4nPXRaIU8bJ5h.jpg" style="zoom:50%;" /><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p>Trie 树构造的分解过程：</p><img data-src="https://i.loli.net/2021/08/24/7jgq8GPRzkS4HVT.jpg" style="zoom:50%;" /><img data-src="https://i.loli.net/2021/08/24/FMPESoCABkUhD6X.jpg" style="zoom:50%;" /><p>当我们在 Trie 树中查找一个字符串的时候，比如查找字符串“her”，那我们将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。</p><img data-src="https://i.loli.net/2021/08/24/ZzJgXcoRf5xNiWk.jpg" style="zoom:50%;" /><p>如果我们要查找的是字符串“he”呢？我们还用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串“he”匹配的路径。但是，路径的最后一个节点“e”并不是红色的。也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><img data-src="https://i.loli.net/2021/08/24/5HpTzZVrctJ6jfG.jpg" style="zoom:50%;" /><h3 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作，<strong>一个是将字符串集合构造成 Trie 树</strong>。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。<strong>另一个是在 Trie 树中查询一个字符串</strong>。</p><p>Trie 树是一个多叉树，<strong>如何存储一个 Trie 树？</strong></p><p>可以借助散列表的思想，我们通过一个下标与字符一一映射的数组，来存储子节点的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在 Trie 树中查找字符串的时候，我们就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">&#x27;/&#x27;</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往Trie树中插入一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TrieNode newNode = <span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">        p.children[index] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Trie树中查找一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = pattern[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不存在pattern</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 找到pattern</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Trie 树中，查找某个字符串的时间复杂度是多少？</strong></p><p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p><h3 id="Trie-树真的很耗内存吗？"><a href="#Trie-树真的很耗内存吗？" class="headerlink" title="Trie 树真的很耗内存吗？"></a>Trie 树真的很耗内存吗？</h3><p>如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</p><p>当然也可稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。比如有序数组、跳表、散列表、红黑树等。</p><p>实际上，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，缩点优化，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。</p><img data-src="https://i.loli.net/2021/08/24/sTfhwtImGOESykz.jpg" style="zoom:50%;" /><h3 id="Trie-树与散列表、红黑树的比较"><a href="#Trie-树与散列表、红黑树的比较" class="headerlink" title="Trie 树与散列表、红黑树的比较"></a>Trie 树与散列表、红黑树的比较</h3><p>在刚刚讲的这个场景，在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有极其严苛的要求。</p><ol><li><p>字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p></li><li><p>要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p></li><li><p>如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p></li><li><p>我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p></li></ol><p>综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。</p><p>实际上，Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串。</p><h3 id="如何利用-Trie-树，实现搜索关键词的提示功能？"><a href="#如何利用-Trie-树，实现搜索关键词的提示功能？" class="headerlink" title="如何利用 Trie 树，实现搜索关键词的提示功能？"></a>如何利用 Trie 树，实现搜索关键词的提示功能？</h3><p>我们假设关键词库由用户的热门搜索关键词组成。我们将这个词库构建成一个 Trie 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 Trie 树中匹配。为了讲解方便，我们假设词库里只有 hello、her、hi、how、so、see 这 6 个关键词。当用户输入了字母 h 的时候，我们就把以 h 为前缀的 hello、her、hi、how 展示在搜索提示框内。当用户继续键入字母 e 的时候，我们就把以 he 为前缀的 hello、her 展示在搜索提示框内。这就是搜索关键词提示的最基本的算法原理。</p><img data-src="https://i.loli.net/2021/08/24/ZQxcBk5lOaUqfEu.jpg" style="zoom:50%;" /><p>实际上，搜索引擎的搜索关键词提示功能远非这么简单。</p><ul><li>我刚讲的思路是针对英文的搜索关键词提示，对于更加复杂的中文来说，词库中的数据又该如何构建成 Trie 树呢？</li><li>如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？</li><li>像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？</li></ul><p>实际上，Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/24/YuXkxBWnls2jbrO.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;

&lt;p&gt;如何实现搜索引擎的搜索关键词提示功能？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配基础下</title>
    <link href="https://hyacinth.fit/archives/5ed0a93c.html"/>
    <id>https://hyacinth.fit/archives/5ed0a93c.html</id>
    <published>2021-08-20T05:57:32.000Z</published>
    <updated>2021-10-28T12:46:14.447Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/24/RAabjOpiExNPqdU.jpg" style="zoom:50%;" /><p>如何借助BM算法轻松理解KMP算法？</p><span id="more"></span><h3 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h3><p>KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的，算法的全称是 Knuth Morris Pratt 算法，简称为 KMP 算法。</p><p>KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p><p>我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p><img data-src="https://i.loli.net/2021/08/24/Zk4Ujxpd7MYaSQN.jpg" style="zoom:50%;" /><p>现将好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。</p><p>类似 BM 算法，KMP 算法也定义了一个 <strong>next 数组</strong>，也称为<strong>失效函数</strong>（failing function），数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标，即模式子串前后缀子串匹配的最大长度。</p><img data-src="https://static001.geekbang.org/resource/image/16/a8/1661d37cb190cb83d713749ff9feaea8.jpg" style="zoom:50%;" /><p>有了 next 数组后就能实现 KMP 算法的框架代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h3><p>我们按照下标从小到大，依次计算 next 数组的值。当我们要计算 next[i]的时候，前面的 next[0]，next[1]，……，next[i-1]应该已经计算出来了。</p><p>如果 next[i-1]=k-1，也就是说，子串 b[0, k-1]是 b[0, i-1]的最长可匹配前缀子串。如果子串 b[0, k-1]的下一个字符 b[k]，与 b[0, i-1]的下一个字符 b[i]匹配，那子串 b[0, k]就是 b[0, i]的最长可匹配前缀子串。那如果不相等呢？</p><img data-src="https://i.loli.net/2021/08/24/4jJnk9TOv2ZP6tg.jpg" style="zoom:50%;" /><p>我们假设 b[0, i]的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1]肯定是 b[0, i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 b[0, i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么我们就可以考察 b[0, i-1]的次长可匹配后缀子串 b[x, i-1]对应的可匹配前缀子串 b[0, i-1-x]的下一个字符 b[i-x]是否等于 b[i]。如果等于，那 b[x, i]就是 b[0, i]的最长可匹配后缀子串。</p><img data-src="https://i.loli.net/2021/08/24/rUJmQK8yIXzLijF.jpg" style="zoom:50%;" /><p>可是，如何求得 b[0, i-1]的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1]的次长可匹配后缀子串，这个问题就变成，查找 b[0, y]的最长匹配后缀子串的问题了。</p><img data-src="https://i.loli.net/2021/08/24/7MbqCdna59RiWK3.jpg" style="zoom:50%;" /><p>按照这个思路，我们可以考察完所有的 b[0, i-1]的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i]就是 b[0, i]的最长可匹配后缀子串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b表示模式串，m表示模式串的长度</span><br><span class="line">private static int[] getNexts(char[] b, int m) &#123;</span><br><span class="line">  int[] next &#x3D; new int[m];</span><br><span class="line">  next[0] &#x3D; -1;</span><br><span class="line">  int k &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; m; ++i) &#123;</span><br><span class="line">    while (k !&#x3D; -1 &amp;&amp; b[k + 1] !&#x3D; b[i]) &#123;</span><br><span class="line">      k &#x3D; next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if (b[k + 1] &#x3D;&#x3D; b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] &#x3D; k;</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h3><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。</p><p>KMP 算法包含两部分，第一部分是构建 next 数组，第二部分才是借助 next 数组匹配。</p><p>计算 next 数组的代码中，第一层 for 循环中 i 从 1 到 m-1，也就是说，内部的代码被执行了 m-1 次。for 循环内部代码中 while 循环里 k=next[k]。k 累积没有增加超过 m，即while 循环里面 k=next[k]总的执行次数也不可能超过 m，所以 next 数组计算的时间复杂度是 O(m)。</p><p> i 从 0 循环增长到 n-1，j 的增长量不可能超过 i，所以肯定小于 n。而 while 循环中的那条语句 j=next[j-1]+1，不会让 j 增长的，那有没有可能让 j 不变呢？也没有可能。因为 next[j-1]的值肯定小于 j-1，所以 while 循环中的这条语句实际上也是在让 j 的值减少。而 j 总共增长的量都不会超过 n，那减少的量也不可能超过 n，所以 while 循环中的这条语句总的执行次数也不会超过 n，所以这部分的时间复杂度是 O(n)。</p><p>KMP 算法总得时间复杂度就是 O(m+n)。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/24/RAabjOpiExNPqdU.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;如何借助BM算法轻松理解KMP算法？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配基础中</title>
    <link href="https://hyacinth.fit/archives/8cdd2cc1.html"/>
    <id>https://hyacinth.fit/archives/8cdd2cc1.html</id>
    <published>2021-08-20T02:20:47.000Z</published>
    <updated>2021-10-28T12:46:14.451Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/20/81gEtfNlqMjF7IU.jpg" style="zoom:50%;" /><p>如何实现文本编辑器中的查找功能？</p><span id="more"></span><h3 id="BM-算法核心思想"><a href="#BM-算法核心思想" class="headerlink" title="BM 算法核心思想"></a>BM 算法核心思想</h3><p>BM 算法全称 Boyer-Moore</p><p>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。</p><img data-src="https://i.loli.net/2021/08/20/fqmogn3VZ9J2MGs.jpg" style="zoom:50%;" /><p>在这个例子里，主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串没有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。</p><img data-src="https://i.loli.net/2021/08/20/OIlstdJP7Kyxmrk.jpg" style="zoom:50%;" /><p>由现象找规律，你可以思考一下，当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？</p><p>我们今天要讲的 BM 算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p><h3 id="BM-算法原理分析"><a href="#BM-算法原理分析" class="headerlink" title="BM 算法原理分析"></a>BM 算法原理分析</h3><p>算法包含两部分，分别是<strong>坏字符规则</strong>（bad character rule）和<strong>好后缀规则</strong>（good suffix shift）。</p><ol><li><strong>坏字符规则</strong></li></ol><p>它是按照模式串下标从大到小的顺序，倒着匹配的。</p><img data-src="https://i.loli.net/2021/08/20/5fFWXi7HlxDVbZK.jpg" style="zoom: 50%;" /><p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，我们把这个没有匹配的字符叫作坏字符（主串中的字符）。</p><img data-src="https://i.loli.net/2021/08/20/aupTr1yz9wxqUei.jpg" style="zoom:50%;" /><p>我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p><img data-src="https://i.loli.net/2021/08/20/X1tCeEWmBb2SLP5.jpg" style="zoom:50%;" /><p>这时我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p><img data-src="https://i.loli.net/2021/08/20/SzxWQtislj4rPGA.jpg" style="zoom:50%;" /><p>能不能找出规律？</p><p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 $s_i$。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 $x_i$ 记作 -1。那模式串往后移动的位数就等于 $s_i-x_i$。</p><img data-src="https://i.loli.net/2021/08/20/u1xSBaPwRze3gyr.jpg" style="zoom:50%;" /><p>要特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p><p>利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。</p><p>不过，单纯使用坏字符规则还是不够的。因为根据 $s_i-x_i$ 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。</p><ol start="2"><li><strong>好后缀规则</strong></li></ol><img data-src="https://i.loli.net/2021/08/20/EQf43vmXxcRhptY.jpg" style="zoom:50%;" /><p>上图中模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。这个时候该如何滑动模式串呢？当然，我们还可以利用坏字符规则来计算模式串的滑动位数，不过，我们也可以使用好后缀处理规则。</p><p>我们把已经匹配的 bc 叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{u*}，那我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p><img data-src="https://i.loli.net/2021/08/20/7ckiIh92pyRDmEu.jpg" style="zoom:50%;" /><p>如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。</p><img data-src="https://i.loli.net/2021/08/20/QS6RctKfWlTqXBe.jpg" style="zoom:50%;" /><p>不过，当模式串中不存在等于{u}的子串时，我们直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？我们来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。</p><img data-src="https://static001.geekbang.org/resource/image/9b/70/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg" style="zoom:50%;" /><p>如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p><img data-src="https://i.loli.net/2021/08/20/jKCvG3UtLMWyRQ9.jpg" style="zoom:50%;" /><p>所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p><p>所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。</p><img data-src="https://i.loli.net/2021/08/20/wACRkprVNY1L7bX.jpg" style="zoom:50%;" /><p>那当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？</p><p>我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</p><h3 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h3><p>如果我们拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，我们可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p><p>关于这个散列表，我们只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，我们用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p><img data-src="https://i.loli.net/2021/08/20/7IFYKQuBmy2Dv1s.jpg" style="zoom:50%;" /><p>将上面的过程翻译成代码，就是下面这个样子。其中，变量 b 是模式串，m 是模式串的长度，bc 表示刚刚讲的散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] = -<span class="number">1</span>; <span class="comment">// 初始化bc</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算b[i]的ASCII值</span></span><br><span class="line">    bc[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掌握了坏字符规则之后，我们先把 BM 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 $s_i-x_i$ 计算得到的移动位数可能会出现负数的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">    i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img data-src="https://i.loli.net/2021/08/20/CBvGE2JNypt9eWV.jpg" style="zoom:50%;" /><p>至此，我们已经实现了包含坏字符规则的框架代码，只剩下往框架代码中填充好后缀规则了。现在，我们就来看看，如何实现好后缀规则。它的实现要比坏字符规则复杂一些。</p><ul><li>在模式串中，查找跟好后缀匹配的另一个子串；</li><li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li></ul><p>因为好后缀也是模式串本身的后缀子串，所以，我们可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。</p><p>如何表示模式串中不同的后缀子串呢？因为后缀子串的最后一个字符的位置是固定的，下标为 m-1，我们只需要记录长度就可以了。通过长度，我们可以确定一个唯一的后缀子串。</p><img data-src="https://i.loli.net/2021/08/20/FeSiamwoTYvMnJ5.jpg" style="zoom:50%;" /><p>现在，我们要引入最关键的变量 suffix 数组。suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值。这句话不好理解，我举一个例子。</p><img data-src="https://i.loli.net/2021/08/20/1iUjzWegF4h2IKM.jpg" style="zoom:50%;" /><p>如果模式串中有多个（大于 1 个）子串跟后缀子串{u}匹配，为了避免模式串往后滑动得过头了，我们肯定要存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。</p><p>实际上，仅仅是选最靠后的子串片段来存储是不够的。</p><p>我们不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。</p><p>如果我们只记录刚刚定义的 suffix，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 suffix 数组之外，我们还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。</p><p><img data-src="https://i.loli.net/2021/08/20/V1lUEuBjT69AZhx.jpg"></p><p><strong>如何来计算并填充这两个数组的值？</strong></p><p>我们拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p><img data-src="https://i.loli.net/2021/08/20/SeUzMdRpi81QvoE.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">    suffix[i] = -<span class="number">1</span>;</span><br><span class="line">    prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123; <span class="comment">// b[0, i]</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123; <span class="comment">// 与b[0, m-1]求公共后缀子串</span></span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>; <span class="comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>; <span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这两个数组之后，我们现在来看，<strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p><p>假设好后缀的长度是 k。我们先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段。我们可以用下面这条规则来处理。</p><p><img data-src="https://i.loli.net/2021/08/20/iZFTDabxf8cGMYn.jpg"></p><p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p><p><img data-src="https://i.loli.net/2021/08/20/vsKhLj1kip3mMX5.jpg"></p><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，我们就将整个模式串后移 m 位。</p><p><img data-src="https://i.loli.net/2021/08/20/EK1gYmLIcpR82dZ.jpg"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">  <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BM-算法的性能分析及优化"><a href="#BM-算法的性能分析及优化" class="headerlink" title="BM 算法的性能分析及优化"></a>BM 算法的性能分析及优化</h3><p>我们先来分析 BM 算法的内存消耗。整个算法用到了额外的 3 个数组，其中 bc 数组的大小跟字符集大小有关，suffix 数组和 prefix 数组的大小跟模式串长度 m 有关。</p><p>如果我们处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果我们运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免 bc 数组过多的内存消耗。不过，单纯使用好后缀规则的 BM 算法效率就会下降一些了。</p><p>对于执行效率来说，我们可以先从时间复杂度的角度来分析。</p><p>实际上，我前面讲的 BM 算法是个初级版本。为了让你能更容易理解，有些复杂的优化我没有讲。基于我目前讲的这个版本，在极端情况下，预处理计算 suffix 数组、prefix 数组的性能会比较差。</p><p>比如模式串是 aaaaaaa 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 O(m^2)。当然，大部分情况下，时间复杂度不会这么差。关于如何优化这种极端情况下的时间复杂度退化，如果感兴趣，你可以自己研究一下。</p><p>实际上，BM 算法的时间复杂度分析起来是非常复杂，这篇论文“<a href="http://dl.acm.org/citation.cfm?id=1382431.1382552">A new proof of the linearity of the Boyer-Moore string searching algorithm</a>”证明了在最坏情况下，BM 算法的比较次数上限是 5n。这篇论文“<a href="http://dl.acm.org/citation.cfm?id=127830">Tight bounds on the complexity of the Boyer-Moore string matching algorithm</a>”证明了在最坏情况下，BM 算法的比较次数上限是 3n。你可以自己阅读看看</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>算法分析注重于思维训练，从上面的 BM 算法中就可以总结出：</p><ul><li>要有优化意识，BF、RK算法已经能够满足需求了，为什么还要发明 BM算法？是为了减少时间复杂度，但也带来了代码变复杂难以维护的弊端</li><li>需要减少查找或遍历的时间复杂度，应该想到什么？散列表</li><li>如果表达式计算开销过大，有需要频繁使用怎么办？预处理并缓存</li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/20/81gEtfNlqMjF7IU.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;如何实现文本编辑器中的查找功能？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配基础上</title>
    <link href="https://hyacinth.fit/archives/29d799aa.html"/>
    <id>https://hyacinth.fit/archives/29d799aa.html</id>
    <published>2021-08-20T01:49:52.000Z</published>
    <updated>2021-10-28T12:46:14.445Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/20/5LtXPdp1zUMowqj.jpg" style="zoom:50%;" /><p>RK 算法是如何借助哈希算法来实现高效字符串匹配的呢？</p><span id="more"></span><h3 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h3><p>BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p><p>假设我们在字符串 A（<strong>主串</strong>，长度为 n） 中查找字符串 B（<strong>模式串</strong>， 长度为 m），BF 算法思想简单概况就是在主串中，检查起始位置分别是 0、1、2….n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</p><img data-src="https://i.loli.net/2021/08/20/EUpOGSrki9yj2NL.jpg" style="zoom:50%;" /><p>最坏情况，每次要比对 m 个字符，要比对 n-m+1 此，时间复杂度为 O(n*m)。但尽管 BF 算法时间复杂度高，在实际开发中，却是比较常用的：</p><ul><li>实际软件开发中，模式串和主串长度都不会太长，也不需要每次都把 m 个字符都比对以下，也就是说绝大部分情况下算法执行效率都比这个高。</li><li>朴素字符串匹配算法思想简单，代码实现也简单，意味着不容易出错。在工程中，在满足性能要求的前提下，简单是首选，也是我们常说的<a href="https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99">KISS（Keep it Simple and Stupid）设计原则</a>。</li></ul><h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>全称是 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。其实也就是 BF 算法的升级版。</p><p>其思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了，因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p><img data-src="https://i.loli.net/2021/08/20/NbMf7k6JGDgEzHp.jpg" style="zoom:50%;" /><p>不过，这种做法只是提高了模式串和子串的比较效率，没有提高算法整体效率。</p><p>这里用到一个巧妙设计的哈希算法：假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p><p>比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。</p><img data-src="https://i.loli.net/2021/08/20/LjmXUZFRlufh2gE.jpg" style="zoom:50%;" /><p>这种哈希算法有一个特点，在主串中，相邻两个子串 s[i-1] 和 s[i] 的哈希值的计算公式有一定关系。</p><img data-src="https://i.loli.net/2021/08/20/Mo2KEpHBq8I39jC.jpg" style="zoom:50%;" /><p>这里还可以优化，可以事先计算好 26^0 、26^1 、26^2 …… 26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p><img data-src="https://i.loli.net/2021/08/20/ULJMzZWxHpyDtwi.jpg" style="zoom:50%;" /><p>整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。</p><p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK 算法整体的时间复杂度就是 O(n)。</p><p>上面设计的哈希算法是没有散列冲突的，但如果模式串很长，得到的哈希值也会很大，可能会超过计算机中整型数据可以表示范围。如此，我们可以牺牲下，允许哈希冲突。</p><p>们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。不过这样带来的冲突概率也很高，还可以优化，比如将每一个字母从小到大对应一个素数，而不是 1，2，3……这样的自然数。</p><p>当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。其实容易解决，当发现子串哈希值和模式串哈希值相等时，再对比一下子串和模式串本身就好。</p><p>如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/20/5LtXPdp1zUMowqj.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;RK 算法是如何借助哈希算法来实现高效字符串匹配的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度和广度优先搜索</title>
    <link href="https://hyacinth.fit/archives/578d0877.html"/>
    <id>https://hyacinth.fit/archives/578d0877.html</id>
    <published>2021-08-18T02:45:45.000Z</published>
    <updated>2021-08-18T05:15:21.198Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/18/eQqsCz3FBWHtDiR.jpg" style="zoom:50%;" /><p>在社交网络中，有一个六度分割理论，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p><p>在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。那给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？</p><span id="more"></span><h3 id="什么是“搜索”算法？"><a href="#什么是“搜索”算法？" class="headerlink" title="什么是“搜索”算法？"></a>什么是“搜索”算法？</h3><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p><p>图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如这两种最简单、最“暴力”的深度优先、广度优先搜索，还有 A*、IDA*等启发式搜索算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">// 无向图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p>度优先搜索（Breadth-First-Search），我们平常都简称 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p><img data-src="https://i.loli.net/2021/08/18/DVuS7w9mAT5CBI8.jpg" style="zoom:50%;" /><p>下面代码里，bfs() 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 s 表示起始顶点，t 表示终止顶点。我们搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印s-&gt;t的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。</p><p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。</p><p><strong>prev</strong> 用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。为了正向打印出路径，我们需要递归地来打印。</p><img data-src="https://i.loli.net/2021/08/18/f513vUuR42prk6a.jpg" style="zoom:50%;" /><img data-src="https://i.loli.net/2021/08/18/YMK954CkxLmSWwG.jpg" style="zoom:50%;" /><img data-src="https://i.loli.net/2021/08/18/EFjHTwLK2bgmlqh.jpg" style="zoom:50%;" /><p>广度优先搜索的时间、空间复杂度是多少呢？</p><p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。</p><p>广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p><h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。</p><p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略</p><p>看下图，搜索的起始顶点是 s，终止顶点是 t，我们希望在图中寻找一条从顶点 s 到顶点 t 的路径。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径。</p><img data-src="https://i.loli.net/2021/08/18/z7E48td9X2H63ZM.jpg" style="zoom:50%;" /><p>深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先搜索的时间、空间复杂度是多少呢？</p><p>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/18/eQqsCz3FBWHtDiR.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;在社交网络中，有一个六度分割理论，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。&lt;/p&gt;
&lt;p&gt;在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。那给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图的表示</title>
    <link href="https://hyacinth.fit/archives/2f590e8e.html"/>
    <id>https://hyacinth.fit/archives/2f590e8e.html</id>
    <published>2021-08-18T02:08:54.000Z</published>
    <updated>2021-08-18T02:40:54.582Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/18/cJ3h8xXgzmMdfSo.jpg" style="zoom:50%;" /><p>微博、微信、LinkedIn 这些社交软件我想你肯定都玩过吧。在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。那你知道，，如何存储微博、微信等这些社交网络的好友关系吗？</p><span id="more"></span><h3 id="如何理解“图”（Graph）？"><a href="#如何理解“图”（Graph）？" class="headerlink" title="如何理解“图”（Graph）？"></a>如何理解“图”（Graph）？</h3><p>图中的元素我们叫做<strong>顶点</strong>（vertex），顶点之间建立的连接关系叫做<strong>边</strong>（edge），跟顶点相连接的边的条数叫做顶点的<strong>度</strong>（degree）。拿微信举例子，我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边，每个用户有多少好友对应到图中就是顶点的度。</p><img data-src="https://i.loli.net/2021/08/18/bCxUjkyIY2wH1eT.jpg" style="zoom:50%;" /><p>我们还把边有方向的图叫做“有向图”，把边没有方向的图叫做“无向图”。有向图中又把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。微博的社交关系就需要用到有向图，它允许单向关注，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。</p><img data-src="https://i.loli.net/2021/08/18/l1mUSZFCvcTkhDq.jpg" style="zoom:50%;" /><p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p><p>再来看QQ，它里面的社交关系要更复杂一点，其中的QQ亲密度功能不仅记录了用户间的好友关系，还记录了两个用户间的亲密度，这里就需要用到另一种图，<strong>带权图</strong>（weighted graph），每条边都有一个权重（weight），依次表示QQ好友间的亲密度。</p><img data-src="https://i.loli.net/2021/08/18/sRNGC6YnBmDh8lw.jpg" style="zoom:50%;" /><h3 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h3><p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。</p><img data-src="https://i.loli.net/2021/08/18/t7pSoh9XeB56yiv.jpg" style="zoom:50%;" /><p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。无向图的二维数组中，如果我们将其用对角线划分为上下两部分，可知一半空间都浪费了。</p><p>还有，如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p><p>邻接矩阵的存储方法也有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall</a>算法，就是利用矩阵循环相乘若干次得到结果。</p><h3 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h3><p>针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，<strong>邻接表</strong>（Adjacency List）。</p><p>乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p><img data-src="https://i.loli.net/2021/08/18/rQ3DlCLZMR42Gsg.jpg" style="zoom:50%;" /><p>还记得我们之前讲过的时间、空间复杂度互换的设计思想吗？邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p><p>比如图中的例子，如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p><p>当然，如果链过长，也可以将链表换成其他更高效的数据结构，比如平衡二叉查找树（红黑树）、跳表等</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/18/cJ3h8xXgzmMdfSo.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;微博、微信、LinkedIn 这些社交软件我想你肯定都玩过吧。在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。那你知道，，如何存储微博、微信等这些社交网络的好友关系吗？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆的应用</title>
    <link href="https://hyacinth.fit/archives/629ab5f5.html"/>
    <id>https://hyacinth.fit/archives/629ab5f5.html</id>
    <published>2021-08-17T07:11:08.000Z</published>
    <updated>2021-08-18T02:45:12.715Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/17/f8rB9iq4zHYaTQt.jpg" style="zoom:50%;" /><p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？</p><span id="more"></span><h3 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h3><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><ol><li> <strong>合并有序小文件</strong></li></ol><p>我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p><p>假设，这个最小的字符串来自于 13.txt 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p><p>这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</p><p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p><p>我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 $O(logn)$，n 表示堆中的数据个数，这里就是 100，这样就比原来数组存储的方式高效多了。</p><ol start="2"><li><strong>高效能定时器</strong></li></ol><p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p><img data-src="https://i.loli.net/2021/08/17/486vhqnBfGMzUjL.jpg" style="zoom:50%;" /><p>这样每过 1 秒就扫描一遍任务列表的做法比较低效：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p><p>针对这些问题，我们可以采用优先级队列来解决。按照任务的执行时间，将这些任务存储到优先级队列中，队里首部（小顶堆堆顶）存储的是最先执行的任务。</p><p>它可以拿首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。定时器便可以设定在时间 T 之后，再执行任务，从当前时间到（T-1）秒这段时间不需要做任何事情。</p><p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</p><h3 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h3><p>首先把这种求 Top K 的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p><p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p><p>遍历数组需要 $O(n)$ 的时间复杂度，一次堆化操作需要 $O(logK)$ 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 $O(nlogK)$。</p><p>针对动态数据求得 Top K 就是实时 Top K。我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。</p><h3 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h3><p>中位数，顾名思义，就是处在中间位置的数。如果数的个数是奇数，取第 $\frac n2+1$ 个；如果个数是偶数，就取第 $\frac n2$ 个或第 $\frac n2 + 1$ 个中一个。</p><p>对于一组<strong>静态数据</strong>，可以想先排序，直接取中位数。如果面对<strong>动态数据</strong>集合，中位数在不断变动，如果也采用先排序的方式，那效率就不高了。</p><p>我们借助堆就能高效解决这个问题。需要维护两个堆，一个大顶堆，一个小顶堆，大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆数据都大于大顶堆中数据。如此，大顶堆堆顶元素便是需要的中位数：</p><img data-src="https://i.loli.net/2021/08/17/VIqdAzwDiZWbLtm.jpg" style="zoom:50%;" /><p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p><p>当两个堆中的数据个数不符合约定时便需要调整：</p><img data-src="https://i.loli.net/2021/08/17/3PQBvqkG74oXemT.jpg" style="zoom:50%;" /><p>实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。</p><p>比如求 99% 响应时间。大顶堆中保存 99% 个数据，小顶堆中保存 1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。</p><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p><strong>有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？</strong></p><p>限定内存为 1GB。</p><p>考虑到关键词中有很多重复的，首先统计每个关键词的频率，可以通过散列表、平衡二叉查找树等记录关键词及其出现次数。</p><p>假设选用散列表顺序扫描这10亿个关键词，统计存储后，在用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表即可。</p><p>这里有个漏洞，10亿关键词还是很多的，假设不重复的有1 亿条，每条关键词平均长度为 50 字节，那存储这些关键词需要5GB的内存空间，而且散列表为了避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间更多。</p><p>这时可以用到哈希算法，通过哈希算法现将10亿条关键词分片到10个文件中。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/17/f8rB9iq4zHYaTQt.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
